!+---+-----------------------------------------------------------------+
!.. This subroutine was written by Istvan Geresdi at University of Pecs,
!.. Hungary.  Complete descriptions found in Geresdi (1998) and
!.. Rasmussen et al (2002).  It is a detailed/bin/spectral double-moment
!.. (predicts mass mixing ratio and number concentrations) microphysics
!.. scheme predicting 4 hydrometeor species utilizing 36 mass-doubling
!.. size bins.
!.. New in 2011 is the treatment of snow riming to form graupel
!.. including new mass/number vars for the mass of rime held on snow
!.. before it is converted to graupel.  Also new is partially melted
!.. snow and graupel using mass variables, but not number.
!.. Adapted to WRFv3.2.1 by G. Thompson (NCAR-RAL) 04 Apr 2012.
!.. Modifications related to piggybacking with bin scheme added by 
!.. N. Sarkadi 2018.
!+---+-----------------------------------------------------------------+
!wrft:model_layer:physics
!+---+-----------------------------------------------------------------+
!
      MODULE module_mp_detailed

      USE module_wrf_error
      USE module_state_description
      USE module_mp_radar

      IMPLICIT NONE

      INTEGER, PARAMETER, PRIVATE :: ls = 100                         ! vertical layers for bulk conversion rates
      LOGICAL, PRIVATE :: old_adv = .true.                          ! Setting old moist and scalar arrays before advection values
      LOGICAL, PRIVATE :: MELT_SHED = .false.                          ! Setting instantaneous shedding from melted particles
      INTEGER, PARAMETER, PRIVATE :: nbins = 36                          ! Not allowed to change this
      INTEGER, PARAMETER, PRIVATE :: n_rain = 13
      REAL, PARAMETER, PRIVATE :: DTCOND = 1.0
      REAL, PARAMETER, PRIVATE :: RIMTHRES = 0.5
      REAL, PARAMETER, PRIVATE :: MELTS_THRES = 0.80
      REAL, PARAMETER, PRIVATE :: MELTG_THRES = 0.80
      INTEGER, PARAMETER, PRIVATE :: IBREAKUP = 1
      DOUBLE PRECISION, PARAMETER, PRIVATE :: RDR_1 = 1.56250000d-6
      DOUBLE PRECISION, PARAMETER, PRIVATE :: PK = 2.d0
      LOGICAL, PRIVATE :: graupel_flag = .true.                          ! Setting to true uses variable density graupel
     
      CHARACTER(len=53), PRIVATE:: path_prefix =                        &
     &  '/glade/u/home/sarkadin/src/Serial_WRF_BIN/kernels_new'
      CHARACTER(len=128), PRIVATE:: filen

      DOUBLE PRECISION, PARAMETER, PRIVATE :: PI=3.1415926535897932384626433832795d0
      REAL, PARAMETER, PRIVATE :: ROA0 = 1.2
      REAL, PARAMETER, PRIVATE :: ROW=1000.
      REAL, PARAMETER, PRIVATE :: RHOW=1000.
      REAL, PARAMETER, PRIVATE :: ROI=900.
      REAL, PARAMETER, PRIVATE :: ROGR=800.
      REAL, PARAMETER, PRIVATE :: RHOI=900.
      REAL, PARAMETER, PRIVATE :: RADA=1.0e-7
      REAL, PARAMETER, PRIVATE :: EPS=1.0e-15
      REAL, PARAMETER, PRIVATE :: EPSC=1.0e-3
      REAL, PARAMETER, PRIVATE :: T0 = 273.15
      REAL, PARAMETER, PRIVATE :: T00 = 273.15
      REAL, PARAMETER, PRIVATE :: P00 = 101325.0
      REAL, PARAMETER, PRIVATE :: RG = 287.06
      REAL, PARAMETER, PRIVATE :: RGD = 287.06
      REAL, PARAMETER, PRIVATE :: RGV = 467.10
      REAL, PARAMETER, PRIVATE :: CP = 1004.
      REAL, PARAMETER, PRIVATE :: CW = 4186.
      REAL, PARAMETER, PRIVATE :: LV0 = 2500297.8
      REAL, PARAMETER, PRIVATE :: LF0 = 333624.2
      REAL, PARAMETER, PRIVATE :: EWS0 = 610.0
      REAL, PARAMETER, PRIVATE :: alfa = 0.04
      REAL, PARAMETER, PRIVATE :: ALFAI = 0.1
      REAL, PARAMETER, PRIVATE :: nsch1=0.63d0**0.33333d0
      REAL, PARAMETER, PRIVATE :: HCI0=4./(16.28*16.28*PI*ROI)             ! height of the hexagonal plate ice crystal, the base is approximated with a circle
      DOUBLE PRECISION, PARAMETER, PRIVATE :: MV=(4.d0/pi/roi)**2.d0/16.28d0**6.d0

      INTEGER, PARAMETER, PRIVATE:: slend = 512
      CHARACTER(len=slend), PRIVATE:: mp_debug
      LOGICAL debug_flag
!
!.. Arrays of precalculated kernel functions and look-up tables. 
!
      INTEGER, PARAMETER, PRIVATE:: R4SIZE = 4
      INTEGER, PARAMETER, PRIVATE:: R8SIZE = 8
      REAL (KIND=R8SIZE) ::                                             &
      CCW(36,3),CCCW(36,36,12),C5W(36,36,4),CICEM(36,36,2),        &  ! water - water, water - aerosol, icemultp.
      CCCWMEAN(36,36),QTN(36,36,36),                               &  ! kernels for the break up (collision and number of fragments)
      CCGW1(36,4),CCCGW1(36,36,12),CCCVGW1(36,36,4),               &  ! graupel - water drops collision efficiency
      C5VGW1(36,36,4),                                             &
      CCIW(36,4),CCCIW(36,36,8),C5IW(36,36,4),CCCVIW(36,36,4),     &  ! pristine ice - water drops
      C5VIW(36,36,4),                                              &
      CCRIW(36,4),CCCRIW(36,36,12),CCCVRIW(36,36,4),               &  ! snow flake - water drops (qw < qwtrhes)
      C5VRIW(36,36,4),                                             &
      CCRIW2(36,4),CCCRIW2(36,36,8),C5RIW2(36,36,4),               &  ! snow flake - water drops (qw > qwtrhes)
      CCCVRIW2(36,36,4),C5VRIW2(36,36,4),                          &
      CCSNOW1(36,4),CCCSNOW1(36,36,8),CSNOW15(36,36,4),            &  ! pristine ice - pristine ice
      CCSNOW2(36,3),CCCSNOW2(36,36,12),                            &  ! snow flake - snow flake
      CCCICIR(36,4),CCCCICIR(36,36,12),CCCVCICIR(36,36,4),         &  ! snow flake - pristine ice
      C5VCICIR(36,36,4),                                           &
      CCCBR(36,20,12),CBR5(36,20,4),                               &  ! Brownian collection of aerosol particles
      CCCPH(36,20,12),CPH5(36,20,4),                               &  ! phoretic collection of aerosol particles
      CCCGRA(36,36,12),CGRA5(36,36,4),                              &  ! gravitational collection of aerosol particles
      CCCTRB(36,36,12),CTRB5(36,36,4)                                 ! turbulence generated collision kernel

      REAL (KIND=R8SIZE) :: DMSNOW(30,40)
!
!.. Terminal velocities of the different type of hidrometeors
!
      REAL (KIND=R4SIZE), DIMENSION (nbins) :: VTC,VTCI,VTCIR,VTGRA,VTGRA1
!
!.. Parameters for calculation of the mass at the bin borders and for calculation
!.. size of the different particles types
!
      DOUBLE PRECISION :: M(nbins+1)
      REAL :: RDR(nbins+1),DDCI(nbins+1),DDSNOW(nbins+1),DDGRA(nbins+1)
      REAL :: MSNOW100,MSNOW500,MSNOWTV,ROSNOW0,ROSNOW1,ROSNOW,         &
            RSNOW0,RSNOW1,RSNOW,A1,A2,B1,B2

      DOUBLE PRECISION, DIMENSION(nbins) :: MTC, NTC, MTCI, NTCI,       &
            MTCIR, NTCIR, MTGRA, NTGRA, MTSNOWR, NTSNOWR,               &
            MTSNOWM, MTGRAM, MTSNOWI, MTGRAI

!.. total of production terms
      REAL*8 TDSNTC0,TDSMTC0,TDSNTC1,TDSMTC1,TDSNTC1B,                  &
     &     TDSMTC1B,TDSNTC2,TDSMTC2,TDSNTC3,TDSMTC3,TDSNTC4,TDSMTC4,    &
     &     TDSNTC5,TDSMTC5,TDSNTC6,TDSMTC6,                             &
     &     TDSNTC8,TDSMTC8,TDSMTC9,TDSNTC10,TDSMTC10,                   &
     &     TDSNTC8S,TDSMTC8S,                                           &
     &     TDSNTCI0,TDSMTCI0,TDSNTCI1,TDSMTCI1,TDSNTCI2,TDSMTCI2,       &
     &     TDSNTCI3,TDSMTCI3,TDSNTCI4,TDSMTCI4,TDSNTCI5,TDSMTCI5,       &
     &     TDSNTCI6,TDSMTCI6,TDSNTCI9,TDSMTCI9,TDSNTCI10,TDSMTCI10,     &
     &     TDSNTCI11,TDSMTCI11,                                         &
     &     TDSNTCIR0,TDSMTCIR0,TDSNTCIR1,TDSMTCIR1,TDSNTCIR2,TDSMTCIR2, &
     &     TDSNTCIR2V,TDSMTCIR2V,TDSNTCIR4,TDSMTCIR4,                   &
     &     TDSNTCIR5,TDSMTCIR5,TDSNTCIR6,TDSMTCIR6,                     &
     &     TDSNTCIR7,TDSMTCIR7,TDSNTCIR8,TDSMTCIR8,                     &
     &     TDSNTCIR9,TDSMTCIR9,                                         &
     &     TDSNTGRA0,TDSMTGRA0,TDSNTGRA2,TDSMTGRA2,                     &
     &     TDSNTGRA3,TDSMTGRA3,TDSNTGRA3V,TDSMTGRA3V,                   &
     &     TDSNTGRA4,TDSMTGRA4,TDSNTGRA5,TDSMTGRA5,                     &
     &     TDSNTGRA7,TDSMTGRA7,TDSNTGRA10,TDSMTGRA10,                   &
     &     TDSNTGRA11,TDSMTGRA11,TDSNTGRA12,TDSMTGRA12,                 &
     &     TDSMTRIME0,TDSNTRIME0,TDSMTRIME1,TDSNTRIME1,                 &
     &     TDSMTRIME2,TDSNTRIME2,TDSMTRIME3,TDSNTRIME3,                 &
     &     TDSMTRIME4,TDSNTRIME4,TDSMTRIME5,TDSNTRIME5,                 &
     &     TDSMTSNOWM0,TDSMTSNOWM1,TDSMTSNOWM2,TDSMTSNOWM3,             &
     &     TDSMTSNOWM4,TDSMTGRAM0,TDSMTGRAM3,TDSMTGRAM4,                &
     &     TDSMTGRAM5

! xue add for shedding
      REAL*8 ::                                                         &
     &     TDSNTC11,TDSMTC11,TDSNTC12,TDSMTC12,                         &
     &     TDSNTCIR10,TDSMTCIR10,TDSNTCIR11,TDSMTCIR11,                 &
     &     TDSNTGRA13,TDSMTGRA13,TDSNTGRA14,TDSMTGRA14

! .. bulk conversion rates added by L. Xue
      REAL, DIMENSION(ls),PRIVATE::                                     &
     &                DNWZ_ACTV,DNWZ_COAG,DNWZ_BRUP,DNIZ_COLL,          &  ! change of drop N by act, c-c, brup and ice N by c-c
     &                DMWZ_DIFF,DMWZ_FRML,DMIZ_DIFF,DMWIZ_MELT,         &  ! change of water M by diff & melt, ice M by diff and water M by melt on ice
     &                DMWIZ_DIFF,DMWZ_RIME,DNWZ_SHED,DMGZ_RIME             ! change of water M by diff on ice, by riming, freez and graup M by riming

      INTEGER, PRIVATE :: ipt, jpt, kpt

      CONTAINS

!
!+---+-----------------------------------------------------------------+
!

      SUBROUTINE geresdi_init

      USE module_domain
      USE module_dm

      IMPLICIT NONE

      INTEGER :: k, km1, chlen, i
!      INTEGER :: iunit = -1
      INTEGER :: iunit = 777
!      LOGICAL :: opened
!      LOGICAL, EXTERNAL :: wrf_dm_on_monitor
      CHARACTER*512 errmess

!+---+

      CALL wrf_debug(150, '  Initializing for Geresdi microphysics')

!.. Create the mass and diameter bins
!
!  rdr(1) - radius of drop in first category in meters
!  m(1) - mass of drop in first category in kg
!
      M(1)=4.d0*PI*ROW*RDR_1**3.d0/3.d0
      RDR(1)=RDR_1
      DO K=1,nbins+1
       KM1=K-1
       M(K)=M(1)*PK**KM1
       RDR(K)=RDR(1)*PK**(KM1/3.d0)
       DDCI(K)=16.3*DSQRT(M(K))                      ! diameter of hexagonal ice crystal
       DDGRA(K)=(6.*M(K)/PI/ROGR)**0.33333333
      ENDDO
      MSNOW100=3.773e-11
      MSNOW500=2.22529e-8
      MSNOWTV=3.2906e-8
      ROSNOW0=900.0
      ROSNOW1=340.0
      RSNOW0=0.08
      RSNOW1=0.5 !1.0  ! decrease the axis ratio for large snow to represent ellipsoid rather than sphere
      DO K=1,nbins+1
       IF (M(K).LE.MSNOW100) THEN
          RSNOW=RSNOW0
          DDSNOW(K)=16.28*SQRT(M(K))
       ENDIF
       IF (M(K).GE.MSNOW500) THEN
          RSNOW=RSNOW1
          DDSNOW(K)=SQRT(6.*M(K)/PI/0.17)
          rosnow = 0.17/ddsnow(K)
          if (rosnow .lt. 20.0) then
             rosnow=20.0
             ddsnow(K) = (6.0*M(K)/3.14159/rsnow/rosnow)**0.33333333
          endif
       ENDIF
       IF (M(K).GT.MSNOW100.AND.M(K).LT.MSNOW500) THEN
          A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B1=RSNOW1-A1*ALOG10(MSNOW500)
          A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B2=ROSNOW1-A2*ALOG10(MSNOW500)
          RSNOW=A1*DLOG10(M(K))+B1
          ROSNOW=A2*DLOG10(M(K))+B2
          DDSNOW(K)=(6.0*M(K)/PI/RSNOW/ROSNOW)**0.33333333
       ENDIF
      ENDDO

!#define DM_BCAST_MACRO(A) CALL wrf_dm_bcast_bytes(A, size(A)*R8SIZE)
!#define DM_BCAST_MACROB(B) CALL wrf_dm_bcast_bytes(B, size(B)*R4SIZE)

      chlen = len(filen)
      do i = 1, chlen
         filen(i:i) = char(0)
      enddo

!      IF ( wrf_dm_on_monitor() ) THEN
!        DO i = 33, 93
!          INQUIRE ( i , OPENED = opened )
!          IF ( .NOT. opened ) THEN
!            iunit = i
!            GOTO 2010
!          ENDIF
!        ENDDO
! 2010   CONTINUE
!        IF ( iunit < 0 ) THEN
!          CALL wrf_error_fatal ( 'module_mp_detailed:  '//              &
!           'Can not find unused fortran unit to read in lookup table.')
!        ENDIF
!        WRITE(errmess, '(A,I2)') '  for usage in module_mp_detailed, file unit, iunit = ', iunit
!        CALL wrf_debug(150, errmess)
!        CALL wrf_dm_bcast_bytes ( iunit, IWORDSIZE )
!      ENDIF


!      IF ( wrf_dm_on_monitor() ) THEN
       IF (IBREAKUP == 0) THEN
         FILEN = path_prefix//'/coefdd1.dat'
         WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
         CALL wrf_debug(150, errmess)
         OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
         REWIND iunit
         READ(iunit, ERR=9010) CCW
         READ(iunit, ERR=9010) CCCW
         READ(iunit, ERR=9010) C5W
         CLOSE(iunit)
!            DM_BCAST_MACRO(CCW)
!            DM_BCAST_MACRO(CCCW)
       ELSE
!         FILEN = path_prefix//'/coefddbr1.dat'
         FILEN = path_prefix//'/coefddbr1_new.dat'
         WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed opening ',filen,' on unit ',iunit
         CALL wrf_debug(150, errmess)
         OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
         REWIND iunit
         READ(iunit, ERR=9010) CCW
         READ(iunit, ERR=9010) CCCW
         WRITE(errmess,'(A,A,A,I2)')'Finish reading',filen,'on unit',iunit
         CALL wrf_debug(150, errmess)
         CLOSE(iunit)
!            DM_BCAST_MACRO(CCW)
!            DM_BCAST_MACRO(CCCW)
!         FILEN = path_prefix//'/coefddbr2.dat'
         FILEN = path_prefix//'/coefddbr2_new.dat'
         WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
         CALL wrf_debug(150, errmess)
         OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
         REWIND iunit
         READ(iunit, ERR=9010) QTN,CCCWMEAN
         CLOSE(iunit)
!            DM_BCAST_MACRO(QTN)
!            DM_BCAST_MACRO(CCCWMEAN)
       ENDIF

       if (graupel_flag) then
            filen = path_prefix//'/coefgd1.dat'  !  This is collision efficiencies with variable density graupel.
       else
            filen = path_prefix//'/coefgd.dat'   !  This is collision efficiencies with constant density graupel.
       endif
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCGW1
       READ(iunit, ERR=9010) CCCGW1
       READ(iunit, ERR=9010) CCCVGW1
       READ(iunit, ERR=9010) C5VGW1
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCGW1)
!         DM_BCAST_MACRO(CCCGW1)
!         DM_BCAST_MACRO(CCCVGW1)
!         DM_BCAST_MACRO(C5VGW1)

       filen = path_prefix//'/coeficd.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCIW
       READ(iunit, ERR=9010) CCCIW
       READ(iunit, ERR=9010) C5IW
       READ(iunit, ERR=9010) CCCVIW
       READ(iunit, ERR=9010) C5VIW
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCIW)
!         DM_BCAST_MACRO(CCCIW)
!         DM_BCAST_MACRO(C5IW)
!         DM_BCAST_MACRO(CCCVIW)
!         DM_BCAST_MACRO(C5VIW)


       FILEN = path_prefix//'/coefsnowd1.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCRIW
       READ(iunit, ERR=9010) CCCRIW
       READ(iunit, ERR=9010) CCCVRIW
       READ(iunit, ERR=9010) C5VRIW
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCRIW)
!         DM_BCAST_MACRO(CCCRIW)
!         DM_BCAST_MACRO(CCCVRIW)
!         DM_BCAST_MACRO(C5VRIW)

       FILEN = path_prefix//'/coefsnowd2.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCRIW2
       READ(iunit, ERR=9010) CCCRIW2       
       READ(iunit, ERR=9010) C5RIW2
       READ(iunit, ERR=9010) CCCVRIW2
       READ(iunit, ERR=9010) C5VRIW2
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCRIW2)
!         DM_BCAST_MACRO(CCCRIW2)
!         DM_BCAST_MACRO(C5RIW2)
!         DM_BCAST_MACRO(CCCVRIW2)
!         DM_BCAST_MACRO(C5VRIW2)

       filen = path_prefix//'/coefsnow1.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCSNOW1
       READ(iunit, ERR=9010) CCCSNOW1
       READ(iunit, ERR=9010) CSNOW15
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCSNOW1)
!         DM_BCAST_MACRO(CCCSNOW1)
!         DM_BCAST_MACRO(CSNOW15)

       filen = path_prefix//'/coefsnow2.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCSNOW2
       READ(iunit, ERR=9010) CCCSNOW2
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCSNOW2)
!         DM_BCAST_MACRO(CCCSNOW2)

       filen = path_prefix//'/coefsnowic.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCCICIR
       READ(iunit, ERR=9010) CCCCICIR
       READ(iunit, ERR=9010) CCCVCICIR
       READ(iunit, ERR=9010) C5VCICIR
       CLOSE(iunit)
!         DM_BCAST_MACRO(CCCICIR)
!         DM_BCAST_MACRO(CCCCICIR)
!         DM_BCAST_MACRO(CCCVCICIR)
!         DM_BCAST_MACRO(C5VCICIR)

       filen = path_prefix//'/termv1.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) VTC,VTCI,VTCIR,VTGRA,VTGRA1
       CLOSE(iunit)
       if (graupel_flag) then
        do k = 1, nbins
          VTGRA(k) = VTGRA1(k)
        enddo
       endif
!         DM_BCAST_MACROB(VTC)
!         DM_BCAST_MACROB(VTCI)
!         DM_BCAST_MACROB(VTCIR)
!         DM_BCAST_MACROB(VTGRA)

       filen = path_prefix//'/icmulp1.dat'
       WRITE(errmess, '(A,A,A,I2)') 'module_mp_detailed: opening ',filen,' on unit ',iunit
       CALL wrf_debug(150, errmess)
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED', ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CICEM
       CLOSE(iunit)
!         DM_BCAST_MACRO(CICEM)

! Kernel function for the aerosol scavenging by water drops (Brownian, phoretic and grav. effects)
       FILEN=path_prefix//'/brownian.dat'
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED',ERR=9009)
       REWIND iunit
       READ(iunit, ERR=9010) CCCBR
       READ(iunit, ERR=9010) CBR5
       CLOSE(iunit)
       FILEN=path_prefix//'/phoresis.dat'
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED',ERR=9009)
       READ(iunit, ERR=9010) CCCPH
       READ(iunit, ERR=9010) CPH5
       CLOSE(iunit)
       FILEN=path_prefix//'/coefda.dat'
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED',ERR=9009)
       READ(iunit, ERR=9010) CCCGRA
       READ(iunit, ERR=9010) CGRA5
       CLOSE(iunit)
       FILEN=path_prefix//'/turbcoag.dat'
       OPEN(iunit,FILE=FILEN,FORM='UNFORMATTED',ERR=9009)
       READ(iunit, ERR=9010) CCCTRB
       READ(iunit, ERR=9010) CTRB5
       CLOSE(iunit)
      
!         DM_BCAST_MACRO(CCCBR)
!         DM_BCAST_MACRO(CBR5)
!         DM_BCAST_MACRO(CCCPH)
!         DM_BCAST_MACRO(CPH5)
!         DM_BCAST_MACRO(CCCGRA)
!         DM_BCAST_MACRO(CGRA5)
!         DM_BCAST_MACRO(CCCTRB)
!         DM_BCAST_MACRO(CTRB5)
     
      open (98,FILE='debug.txt')
      open (94,FILE='debug_qcw.txt')
      open (95,FILE='rain_outmax.txt')
      open (96,FILE='snow_outmax.txt')
      open (97,FILE='graupel_outmax.txt')
      open (101,FILE='sized.txt')

      GOTO 9100	  

 9009 CONTINUE
      WRITE(errmess,'(A,A,A,I2)') 'module_mp_detailed: error opening ',filen,' on unit ',iunit
      CALL wrf_error_fatal(errmess)
 9010 CONTINUE
      WRITE(errmess,'(A,A,A,I2)') 'module_mp_detailed: error reading ',filen,' on unit ',iunit
      CALL wrf_error_fatal(errmess)
 9100 CONTINUE

      CALL wrf_debug(150, ' ... DONE reading Geresdi microphysical lookup tables')
!'

      end SUBROUTINE geresdi_init

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      SUBROUTINE mp_gi_driver (                                         &
     &                         itimestep,th,pii,p,dt,dz8w,rho,          &
     &                         t_old,dx,dy,                             &
     &                         moist_old, moist,                        &
     &                         scalar_old, scalar,                      &
     &                         n_moist, n_scalar,ssw,ssi,               &
     &                         DNW_ACTV,DNW_COAG,DNW_BRUP,DNI_COLL,     &
     &                         DMW_DIFF,DMW_FRML,DMI_DIFF,DMWI_MELT,    &
     &                         DMWI_DIFF,DMW_RIME,DNW_SHED,DMG_RIME,    &
     &                         RAINNC, RAINNCV,                         &
     &                         snownc, snowncv,                         &
     &                         graupelnc, graupelncv,                   &
     &                         sr,refl_10cm,                            &
     &		               diagflag,do_radar_ref,                   &
     &                         ids,ide, jds,jde, kds,kde,               &
     &                         ims,ime, jms,jme, kms,kme,               &
     &                         its,ite, jts,jte, kts,kte)

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: ids,ide, jds,jde, kds,kde ,                &
     &                       ims,ime, jms,jme, kms,kme ,                &
     &                       its,ite, jts,jte, kts,kte
      INTEGER, INTENT(IN) :: itimestep, n_moist, n_scalar
      REAL, INTENT(IN) :: dt,dx,dy

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(IN   ) ::      &
     &                 RHO,PII,P,DZ8W

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) ::      &
     &                DNW_ACTV,DNW_COAG,DNW_BRUP,DNI_COLL,              &
     &                DMW_DIFF,DMW_FRML,DMI_DIFF,DMWI_MELT,             &
     &                DMWI_DIFF,DMW_RIME,DNW_SHED,DMG_RIME

      REAL, DIMENSION(IMS:IME, JMS:JME), INTENT(INOUT) :: RAINNC,RAINNCV,&
     &                snownc, snowncv, graupelnc, graupelncv, SR

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: TH,T_OLD
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: ssw,ssi
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_moist), INTENT(IN) :: moist_old
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_moist), INTENT(INOUT) :: moist
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar_old
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(INOUT) :: scalar
! Radar variables:
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: refl_10cm
      LOGICAL, OPTIONAL, INTENT(IN) :: diagflag  !, diagpiggy
      INTEGER, OPTIONAL, INTENT(IN) :: do_radar_ref  !, do_piggyback 
!
!+---+  LOCAL VARS
!
!.. Local variables to radar calculation
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      ms, msm, msr, mg, mgm, frms, frmg, mc, mi, qsnowt, qgrat
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      nns, nnsr, nng, nnc, nni
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      bin_dBZ
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME):: sdBZ
      INTEGER, PARAMETER :: ncl = 36
      INTEGER  :: icl
      CHARACTER*512 errmess
!.. Old and new tstep values of all bins of mixing ratios and number
!.. concentrations of: water drops, cloud ice, snow, graupel,
!.. frozen rime on snow, snowmelt, and graupelmelt water.  The
!.. melt waters do not have equivalent variables in number conc.
!.. Column oriented variables simplify things for calling primary routine

      REAL, DIMENSION(KTS:KTE, nbins) ::                                &
     &           qcw0, qcw1, qice0, qice1, qsnow0, qsnow1, qgra0, qgra1 &
     &          ,qsnowr0, qsnowr1, qsnowm0, qsnowm1, qgram0, qgram1
      REAL, DIMENSION(KTS:KTE, nbins) ::                                &
     &           ncw0, ncw1, nice0, nice1, nsnow0, nsnow1, ngra0, ngra1 &
     &          ,nsnowr0, nsnowr1
      REAL, DIMENSION(KTS:KTE) :: ccn0, ccn1, nidep0, nidep1

!.. Old and new tstep values of thermo variables

      REAL, DIMENSION(KTS:KTE) :: prez, tz,tz_old, qvz,qvz_old,         &
     &           rhoz, dzz

      INTEGER :: i, j, i_start, i_end, j_start, j_end, k, kk, kk1,      &
     &           kkstart, kkend

      REAL :: pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram, ddx
      REAL :: QWAT,NWAT,QRAIN,NRAIN,QICE,NICE,QSNOW,NSNOW,QGRA,NGRA,    &
     &        SUPSAT,EWS,QWS
      REAL :: QWMAX,NWMAX,QRMAX,NRMAX,QICMAX,NICMAX,QSMAX,NSMAX,QGRMAX, &
     &        NGRMAX,SUPSMAX,TSMAX,QVSMAX
      INTEGER ::IQWMAX,KQWMAX,INWMAX,KNWMAX,IQRMAX,KQRMAX,INRMAX,KNRMAX,&
     &          IQICMAX,KQICMAX,INICMAX,KNICMAX,IQSMAX,KQSMAX,INSMAX,   &
     &         KNSMAX,IQGRMAX,KQGRMAX,INGRMAX,KNGRMAX,ISUPSMAX,KSUPSMAX,&
     &        JQWMAX,JNWMAX,JQRMAX,JNRMAX,JQICMAX,JNICMAX,JQSMAX,JNSMAX,&
     &        JQGRMAX,JNGRMAX,JSUPSMAX

!..Arrays and variables for the bin size calculations.
      REAL, PARAMETER :: MSNOW100 = 3.773e-11
      REAL, PARAMETER :: MSNOW500 = 2.22529e-8
      REAL, PARAMETER :: MSNOWTV = 3.2906e-8
      REAL, PARAMETER :: ROSNOW0 = 900.0
      REAL, PARAMETER :: ROSNOW1 = 340.0
      REAL, PARAMETER :: RSNOW0 = 0.08
      REAL, PARAMETER :: RSNOW1 = 1.0
      DOUBLE PRECISION, PARAMETER :: PK = 2.d0
      DOUBLE PRECISION, PARAMETER :: RDR_1 = 1.56250000d-6
      REAL, PARAMETER :: rhw = 1000.
      REAL, PARAMETER :: rhi = 890.
      REAL, PARAMETER :: RHOGR = 900.
      real :: KM1, A1, B1, A2, B2, RSNOW
      double precision :: PHI
      double precision, dimension(nbins+1) :: &
    &          M, RDR, RHOSNOW,ROSNOW,DDCI, DDGRA, DDSNOW
!+---+

!      write(*,*),CCW

      do i = 1, slend
         mp_debug(i:i) = char(0)
      enddo

!.. Initialize all tendencies to zero
      TDSNTC0=0.0
      TDSNTC1=0.0
      TDSNTC1B=0.0
      TDSNTC2=0.0
      TDSNTC3=0.0
      TDSNTC4=0.0
      TDSNTC5=0.0
      TDSNTC6=0.0
      TDSNTC8=0.0
      TDSNTC8S=0.0
      TDSNTC10=0.0
      TDSMTC0=0.0
      TDSMTC1=0.0
      TDSMTC1B=0.0
      TDSMTC2=0.0
      TDSMTC3=0.0
      TDSMTC4=0.0
      TDSMTC5=0.0
      TDSMTC6=0.0
      TDSMTC8=0.0
      TDSMTC8S=0.0
      TDSMTC9=0.0 
      TDSMTC10=0.0
      TDSNTCI0=0.0
      TDSNTCI1=0.0
      TDSNTCI2=0.0            
      TDSNTCI3=0.0
      TDSNTCI4=0.0
      TDSNTCI5=0.0
      TDSNTCI6=0.0
      TDSNTCI9=0.0
      TDSNTCI10=0.0
      TDSNTCI11=0.0
      TDSMTCI0=0.0
      TDSMTCI1=0.0
      TDSMTCI2=0.0
      TDSMTCI3=0.0
      TDSMTCI4=0.0
      TDSMTCI5=0.0
      TDSMTCI6=0.0
      TDSMTCI9=0.0
      TDSMTCI10=0.0
      TDSMTCI11=0.0
      TDSNTCIR0=0.0
      TDSNTCIR1=0.0
      TDSNTCIR2=0.0
      TDSNTCIR2V=0.0
      TDSNTCIR4=0.0
      TDSNTCIR5=0.0
      TDSNTCIR6=0.0
      TDSNTCIR7=0.0
      TDSNTCIR8=0.0
      TDSNTCIR9=0.0
      TDSMTCIR0=0.0
      TDSMTCIR1=0.0
      TDSMTCIR2=0.0
      TDSMTCIR2V=0.0
      TDSMTCIR4=0.0
      TDSMTCIR5=0.0
      TDSMTCIR6=0.0
      TDSMTCIR7=0.0
      TDSMTCIR8=0.0
      TDSMTCIR9=0.0
      TDSNTGRA0=0.0
      TDSNTGRA2=0.0
      TDSNTGRA3=0.0
      TDSNTGRA3V=0.0
      TDSNTGRA4=0.0
      TDSNTGRA5=0.0
      TDSNTGRA7=0.0
      TDSNTGRA10=0.0
      TDSNTGRA11=0.0
      TDSNTGRA12=0.0
      TDSMTGRA0=0.0
      TDSMTGRA2=0.0
      TDSMTGRA3=0.0
      TDSMTGRA3V=0.0
      TDSMTGRA4=0.0
      TDSMTGRA5=0.0
      TDSMTGRA7=0.0
      TDSMTGRA10=0.0
      TDSMTGRA11=0.0
      TDSMTGRA12=0.0
      TDSNTRIME0=0.0
      TDSNTRIME1=0.0
      TDSNTRIME2=0.0
      TDSNTRIME3=0.0
      TDSNTRIME4=0.0
      TDSNTRIME5=0.0
      TDSMTRIME0=0.0
      TDSMTRIME1=0.0
      TDSMTRIME2=0.0
      TDSMTRIME3=0.0
      TDSMTRIME4=0.0
      TDSMTRIME5=0.0
      TDSMTSNOWM0=0.0
      TDSMTSNOWM1=0.0
      TDSMTSNOWM2=0.0
      TDSMTSNOWM3=0.0
      TDSMTSNOWM4=0.0
      TDSMTGRAM0=0.0
      TDSMTGRAM3=0.0
      TDSMTGRAM4=0.0
      TDSMTGRAM5=0.0
! xue add for shedding
      TDSNTC11=0.0
      TDSMTC11=0.0
      TDSNTC12=0.0
      TDSMTC12=0.0
      TDSNTCIR10=0.0
      TDSMTCIR10=0.0
      TDSNTCIR11=0.0
      TDSMTCIR11=0.0
      TDSNTGRA13=0.0
      TDSMTGRA13=0.0
      TDSNTGRA14=0.0
      TDSMTGRA14=0.0

! initialize all conversion rates

      DO J = JMS, JME
       DO I = IMS, IME
        DO K = KMS, KME
         DNW_ACTV(I,K,J) =0.
         DNW_COAG(I,K,J) =0.
         DNW_BRUP(I,K,J) =0.
         DNI_COLL(I,K,J) =0.
         DMW_DIFF(I,K,J) =0.
         DMW_FRML(I,K,J) =0.
         DMI_DIFF(I,K,J) =0.
         DMWI_MELT(I,K,J)=0.
         DMWI_DIFF(I,K,J)=0.
         DMW_RIME(I,K,J) =0.
         DNW_SHED(I,K,J) =0.
         DMG_RIME(I,K,J) =0.
        ENDDO
       ENDDO
      ENDDO

! initialize the maximum index
      IQWMAX=0
      KQWMAX=0
      INWMAX=0
      KNWMAX=0
      IQRMAX=0
      KQRMAX=0
      INRMAX=0
      KNRMAX=0
      IQICMAX=0
      KQICMAX=0
      INICMAX=0
      KNICMAX=0
      IQSMAX=0
      KQSMAX=0
      INSMAX=0
      KNSMAX=0
      IQGRMAX=0
      KQGRMAX=0
      INGRMAX=0
      KNGRMAX=0
      ISUPSMAX=0
      KSUPSMAX=0
      JQWMAX=0
      JNWMAX=0
      JQRMAX=0
      JNRMAX=0
      JQICMAX=0
      JNICMAX=0
      JQSMAX=0
      JNSMAX=0
      JQGRMAX=0
      JNGRMAX=0
      JSUPSMAX=0

      ddx = SQRT(dx*dy)
      i_start = its
      j_start = jts
      i_end   = min(ite, ide-1)
      j_end   = min(jte, jde-1)
!..For idealized testing by developer.
!-GT  if ( (ide-ids+1).gt.10 .and. (jde-jds+1).lt.10 ) then
!-GT     i_start = its + 2
!-GT     i_end   = min(ite, ide-1)
!-GT     j_start = jts
!-GT     j_end   = min(jte, jde-1)
!-GT  endif
         QWMAX=0.0
         NWMAX=0.0
         QRMAX=0.0
         NRMAX=0.0
         QICMAX=0.0
         NICMAX=0.0
         QSMAX=0.0
         NSMAX=0.0
         QGRMAX=0.0
         NGRMAX=0.0
         SUPSMAX= -10.
      j_loop:  do j = j_start, j_end
      i_loop:  do i = i_start, i_end
         ipt = i
         jpt = j
         debug_flag = .false.
!         if (i.ge.16.and.i.le.20.and. j.ge.21.and.j.le.25) debug_flag = .true.
!         kk = 2
         DO K = KTS, KTE
            dzz(k) = dz8w(i,k,j)
            rhoz(k) = rho(i,k,j)
            prez(k) = p(i,k,j)
            tz(k) = th(i,k,j)*pii(i,k,j)
            tz_old(k) = (300.0+t_old(i,k,j))*pii(i,k,j) !t_old(i,k,j)
            qvz(k) = moist(i,k,j, P_QV)
            qvz_old(k) = moist_old(i,k,j, P_QV)
! xue save saturation ratios for water and ice
            ssw(i,k,j) = qvz_old(k)/(0.622*EXP(53.67957-6743.769/tz_old(k)-4.8451*log(tz_old(k)))*100./prez(k))
            ssi(i,k,j) = qvz_old(k)/(0.622*EXP(23.33086-6111.72784/tz_old(k)+0.15215*log(tz_old(k)))*100./prez(k))
! Radar variables
         sdBZ(i,k,j) = 0.0
         DO ICL = 1, nbins
            bin_dBZ(i,k,j,icl) = 0.0
            mc(i,k,j,icl) = 0.0
            nnc(i,k,j,icl) = 0.0
            mi(i,k,j,icl) = 0.0
            nni(i,k,j,icl) = 0.0
            ms(i,k,j,icl) = 0.0
            msm(i,k,j,icl) = 0.0
            msr(i,k,j,icl) = 0.0
	        nns(i,k,j,icl) = 0.0
            frms(i,k,j,icl) = 0.0
            mg(i,k,j,icl) = 0.0
            mgm(i,k,j,icl) = 0.0
	        nng(i,k,j,icl) = 0.0
            frmg(i,k,j,icl) = 0.0
            qsnowt(i,k,j,icl) = 0.0
            qgrat(i,k,j,icl) = 0.0
         ENDDO
	ENDDO

! >>>>>> New type of read in bin variables starts here
	 	   
DO K = KTS, KTE
	   call read_in_bin(qcw1,qcw0,qice1,qice0, &
  &    qsnow1,qsnow0,qgra1,qgra0,qsnowr1,qsnowr0,    &
  &    qsnowm1,qsnowm0,qgram1,qgram0,ncw1,ncw0,      &
  &    nice1,nice0,nsnow1,nsnow0,ngra1,ngra0,nsnowr1,&
  &	   nsnowr0,scalar,scalar_old,   			     &
  &    n_scalar,ids,ide, jds,jde, kds,kde,           &
  &    ims,ime, jms,jme, kms,kme,  					 &
  &    its,ite, jts,jte, kts,kte,  					 &
  &    i,j,k)
  
DO KK = 1, ncl	 
  if (old_adv) then
   qcw0(K,KK) = MAX(0.,qcw0(K,KK))
   qice0(K,KK) = MAX(0.,qice0(K,KK))
   qsnow0(K,KK) = MAX(0.,qsnow0(K,KK))
   qgra0(K,KK) = MAX(0.,qgra0(K,KK))
   qsnowr0(K,KK) = MAX(0.,qsnowr0(K,KK))
   qsnowm0(K,KK) = MAX(0.,qsnowm0(K,KK))
   qgram0(K,KK) = MAX(0.,qgram0(K,KK))
   ncw0(K,KK) = MAX(0.,ncw0(K,KK))
   nice0(K,KK) = MAX(0.,nice0(K,KK))
   nsnow0(K,KK) = MAX(0.,nsnow0(K,KK))
   ngra0(K,KK) = MAX(0.,ngra0(K,KK))
   nsnowr0(K,KK) = MAX(0.,nsnowr0(K,KK))
 else
   qcw0(K,KK) = MAX(0.,qcw1(K,KK))
   qice0(K,KK) = MAX(0.,qice1(K,KK))
   qsnow0(K,KK) = MAX(0.,qsnow1(K,KK))
   qgra0(K,KK) = MAX(0.,qgra1(K,KK))
   qsnowr0(K,KK) = MAX(0.,qsnowr1(K,KK))
   qsnowm0(K,KK) = MAX(0.,qsnowm1(K,KK))
   qgram0(K,KK) = MAX(0.,qgram1(K,KK))
   ncw0(K,KK) = MAX(0.,ncw1(K,KK))
   nice0(K,KK) = MAX(0.,nice1(K,KK))
   nsnow0(K,KK) = MAX(0.,nsnow1(K,KK))
   ngra0(K,KK) = MAX(0.,ngra1(K,KK))
   nsnowr0(K,KK) = MAX(0.,nsnowr1(K,KK))
 end if		  
 if (ncw1(K,KK).lt.1.E-10) then
   ncw1(K,KK) = 0.0
   qcw1(K,KK) = 0.0
 endif
 if (nice1(K,KK).lt.1.E-10) then
   nice1(K,KK) = 0.0
   qice1(K,KK) = 0.0
 endif
 if (nsnow1(K,KK).lt.1.E-10) then
   nsnow1(K,KK) = 0.0
   qsnow1(K,KK) = 0.0
 endif
 if (ngra1(K,KK).lt.1.E-10) then
   ngra1(K,KK) = 0.0
   qgra1(K,KK) = 0.0
 endif		
 if (nsnowr1(K,KK).lt.1.E-10) then
   nsnowr1(K,KK) = 0.0
   qsnowr1(K,KK) = 0.0
 endif	
 qsnow1(K,KK) = qsnow1(K,KK) + qsnowr1(K,KK) + qsnowm1(K,KK)
 qsnow0(K,KK) = qsnow0(K,KK) + qsnowr0(K,KK) + qsnowm0(K,KK)
 qgra1(K,KK) = qgra1(K,KK) + qgram1(K,KK)
 qgra0(K,KK) = qgra0(K,KK) + qgram0(K,KK)			 
 ENDDO
 ccn1(K) = MAX(0.,scalar(i,k,j,P_CCN))
 ccn0(K) = MAX(0.,scalar_old(i,k,j,P_CCN))
 nidep1(K) = MAX(0.,scalar(i,k,j,P_NIDEP))
 nidep0(K) = MAX(0.,scalar_old(i,k,j,P_NIDEP))
ENDDO
! <<<<<< New type of read in bin variables ends here

         pptrain = 0.
         pptice = 0.
         pptsnow = 0.
         pptsnowm = 0.
         pptgra = 0.
         pptgram = 0.
         RAINNCV(i,j) = 0.
         SNOWNCV(i,j) = 0.
         GRAUPELNCV(i,j) = 0.
         SR(i,j) = 0.

         WRITE (mp_debug,*) 'CALLING mp_detailed for pt ', ipt, jpt
         if (jpt.eq.1) CALL wrf_debug(250, mp_debug)

      if (debug_flag) then
!       DO KK = 1, nbins
        DO K = KTS, KTE
           WRITE (mp_debug,*) ' BEFORE micro, (i,j,k,p,t,t_old,qv,qv_old,ssw,ssi) ', i,j,k,prez(k),tz(k),tz_old(k),qvz(k),qvz_old(k),ssw(i,k,j),ssi(i,k,j)
           CALL wrf_debug(150, mp_debug)
        enddo
!       enddo
      endif

   
!+---+-----------------------------------------------------------------+
      CALL mp_detailed (prez, rhoz, tz, tz_old, qvz, qvz_old, dzz, ddx, &
     &     ncw0,ncw1,qcw0,qcw1,nice0,nice1,qice0,qice1,                 &
     &     nsnow0,nsnow1,qsnow0,qsnow1,nsnowr0,nsnowr1,qsnowr0,qsnowr1, &
     &     qsnowm0,qsnowm1,ngra0,ngra1,qgra0,qgra1,qgram0,qgram1,       &
     &     ccn1,ccn0,nidep1,nidep0,                                     &
     &     pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram,              &
     &     dt, nbins, kte, itimestep, i, j)
!+---+-----------------------------------------------------------------+

! update the 3D bulk conversion rates
      DO K = KTS, KTE
        DNW_ACTV(I,K,J) = DNWZ_ACTV(K)
        DNW_COAG(I,K,J) = DNWZ_COAG(K)
        DNW_BRUP(I,K,J) = DNWZ_BRUP(K)
        DNI_COLL(I,K,J) = DNIZ_COLL(K)
        DMW_DIFF(I,K,J) = DMWZ_DIFF(K)
        DMW_FRML(I,K,J) = DMWZ_FRML(K)
        DMI_DIFF(I,K,J) = DMIZ_DIFF(K)
        DMWI_MELT(I,K,J)= DMWIZ_MELT(K)
        DMWI_DIFF(I,K,J)= DMWIZ_DIFF(K)
        DMW_RIME(I,K,J) = DMWZ_RIME(K)
        DNW_SHED(I,K,J) = DNWZ_SHED(K)
        DMG_RIME(I,K,J) = DMGZ_RIME(K)
      ENDDO

      if (debug_flag) then
!       DO KK = 1, nbins
        DO K = KTS, KTE
           WRITE (mp_debug,*) ' AFTER micro, (i,j,k,p,t,t_old,qv,qv_old,ssw,ssi) ', i,j,k,prez(k),tz(k),tz_old(k),qvz(k),qvz_old(k),ssw(i,k,j),ssi(i,k,j)

!           WRITE (mp_debug,*) ' AFTER micro, (10,k,bin,num,mass,melt) ', k,kk,ngra1(k,kk),qgra1(k,kk),qgram1(k,kk)
           CALL wrf_debug(150, mp_debug)
        enddo
!       enddo
      endif

         DO K = KTS, KTE
            th(i,k,j) = tz(k)/pii(i,k,j)
            t_old(i,k,j) = tz(k)
         ENDDO
!
!   looking for the maximum values of mixing ratios and number concentration of different species
!
         DO K = KTS,KTE 
          QWAT=0.0
          NWAT=0.0
          QRAIN=0.0
          NRAIN=0.0
          QICE=0.0
          NICE=0.0
          QSNOW=0.0
          NSNOW=0.0
          QGRA=0.0
          NGRA=0.0
          DO KK =1,nbins
           QWAT = QWAT + QCW1(K,KK)
           NWAT = NWAT + NCW1(K,KK)
           IF (KK >= N_RAIN) THEN            
             QRAIN = QRAIN + QCW1(K,KK)
             NRAIN = NRAIN + NCW1(K,KK)
           ENDIF
           QICE = QICE + QICE1(K,KK)
           NICE = NICE + NICE1(K,KK)
           QSNOW = QSNOW + QSNOW1(K,KK)
           NSNOW = NSNOW + NSNOW1(K,KK)
           QGRA = QGRA + QGRA1(K,KK)
           NGRA = NGRA + NGRA1(K,KK)
           qsnow1(K,KK) = MAX(0., qsnow1(K,KK) - qsnowr1(K,KK) - qsnowm1(K,KK))
           qgra1(K,KK) = MAX(0., qgra1(K,KK) - qgram1(K,KK))
          ENDDO
          IF (QWAT > QWMAX) THEN
           QWMAX = QWAT
           IQWMAX = I
           JQWMAX = J
           KQWMAX = K
          ENDIF
          IF (NWAT > NWMAX) THEN
           NWMAX = NWAT
           INWMAX = I
           JNWMAX = J
           KNWMAX = K
          ENDIF
          IF (QRAIN > QRMAX) THEN
           QRMAX = QRAIN
           IQRMAX = I
           JQRMAX = J
           KQRMAX = K
          ENDIF
          IF (NRAIN > NRMAX) THEN
           NRMAX = NRAIN
           INRMAX = I
           JNRMAX = J
           KNRMAX = K
          ENDIF
          IF (QICE > QICMAX) THEN
           QICMAX = QICE
           IQICMAX = I
           JQICMAX = J
           KQICMAX = K
          ENDIF
          IF (NICE > NICMAX) THEN
           NICMAX = NICE
           INICMAX = I
           JNICMAX = J
           KNICMAX = K
          ENDIF
          IF (QSNOW > QSMAX) THEN
           QSMAX = QSNOW
           IQSMAX = I
           JQSMAX = J
           KQSMAX = K
          ENDIF
          IF (NSNOW > NSMAX) THEN
           NSMAX = NSNOW
           INSMAX = I
           JNSMAX = J
           KNSMAX = K
          ENDIF
          IF (QGRA > QGRMAX) THEN
           QGRMAX = QGRA
           IQGRMAX = I
           JQGRMAX = J
           KQGRMAX = K
          ENDIF
          IF (NGRA > NGRMAX) THEN
           NGRMAX = NGRA
           INGRMAX = I
           JNGRMAX = J
           KNGRMAX = K
          ENDIF

          EWS=EXP(53.67957-6743.769/tz(k)-4.8451*log(tz(k)))*100.
          QWS=0.622*EWS/PREZ(K)
          SUPSAT = QVZ(K)/QWS -1.0
          IF (SUPSAT > SUPSMAX) THEN
           SUPSMAX = SUPSAT
           TSMAX = TZ(K)
           QVSMAX = QVZ(K)
           ISUPSMAX = I
           JSUPSMAX = J
           KSUPSMAX = K
          ENDIF

!  end of the loop for looking for the max. values
            kk = 2
            moist(i,k,j, kk) = qvz(k)
            kk = kk+1
            moist(i,k,j, kk) = qwat-qrain
            kk = kk+1
            moist(i,k,j, kk) = qrain
            kk = kk+1
            moist(i,k,j, kk) = qice
            kk = kk+1
            moist(i,k,j, kk) = qsnow
            kk = kk+1
            moist(i,k,j, kk) = qgra

            kk = 2
            scalar(i,k,j, kk) = nwat-nrain
            kk = kk+1
            scalar(i,k,j, kk) = nrain
            kk = kk+1
            scalar(i,k,j, kk) = nice
            kk = kk+1
            scalar(i,k,j, kk) = nsnow
            kk = kk+1
            scalar(i,k,j, kk) = ngra
	    ENDDO
 DO K = KTS, KTE
 DO KK = 1 , ncl    
  IF ( PRESENT ( diagflag ) ) THEN
  if ( diagflag .and. do_radar_ref == 1 ) then
	 mc(i,k,j,kk) = qcw1(k,kk)
	 mi(i,k,j,kk) = qice1(k,kk)
	 ms(i,k,j,kk) = qsnow1(k,kk)
	 mg(i,k,j,kk) = qgra1(k,kk)
	 msr(i,k,j,kk) = qsnowr1(k,kk)
	 msm(i,k,j,kk) = qsnowm1(k,kk)
	 mgm(i,k,j,kk) = qgram1(k,kk)
	 nnc(i,k,j,kk) = ncw1(k,kk)
	 nni(i,k,j,kk) = nice1(k,kk)
	 nns(i,k,j,kk) = nsnow1(k,kk)
	 nng(i,k,j,kk) = ngra1(k,kk)
	 nnsr(i,k,j,kk) = nsnowr1(k,kk)
  endif
  ENDIF	
  scalar(i,k,j,P_QNRS) = scalar(i,k,j,P_QNRS) + nsnowr1(K,KK)
  scalar(i,k,j,P_QFWS) = scalar(i,k,j,P_QFWS) + qsnowr1(K,KK)
  scalar(i,k,j,P_QMWS) = scalar(i,k,j,P_QMWS) + qsnowm1(K,KK)
  scalar(i,k,j,P_QMWG) = scalar(i,k,j,P_QMWG) + qgram1(K,KK)    
 ENDDO  		 
! New style
  scalar(i,k,j,P_CCN) = MAX(0.,ccn1(k))
  scalar(i,k,j,P_NIDEP) = MAX(0.,nidep1(k))
   call write_out_bin(qcw1,qice1,qsnow1,qgra1,qsnowr1,  &
   &                  qsnowm1,qgram1,ncw1,nice1,nsnow1, &
   &                  ngra1,nsnowr1,scalar,n_scalar,    &  
   &                  ids,ide, jds,jde, kds,kde,  &
   &                  ims,ime, jms,jme, kms,kme,  &
   &                  its,ite, jts,jte, kts,kte,  &
   &                  i,j,k)	
 ENDDO
         RAINNCV(i,j) = pptrain + pptsnow + pptgra + pptice
         RAINNC(i,j) = RAINNC(i,j) + pptrain + pptsnow + pptgra + pptice
         SNOWNCV(i,j) = pptsnow + pptice
         SNOWNC(i,j) = SNOWNC(i,j) + pptsnow + pptice
         GRAUPELNCV(i,j) = pptgra
         GRAUPELNC(i,j) = GRAUPELNC(i,j) + pptgra
         SR(i,j) = (SNOWNCV(i,j)+GRAUPELNCV(i,j))/(RAINNCV(i,j)+1.e-12)

!!.. Variables for radar calculation
!..Melting of snowflakes
        do k = kts, kte
          frms(i,k,j,1)=0.0
          frms(i,k,j,2)=0.0
          frms(i,k,j,3)=0.0
          frms(i,k,j,4)=0.0
          frms(i,k,j,5)=0.0
          frms(i,k,j,6)=0.0
          frms(i,k,j,7)=0.0
          frms(i,k,j,8)=0.0
          frms(i,k,j,9)=0.0
        enddo
      do icl = 10, ncl
        do k = kts, kte
          qsnowt(i,k,j,icl)=ms(i,k,j,icl)+msm(i,k,j,icl)+msr(i,k,j,icl)
          if (qsnowt(i,k,j,icl).gt.0.0) then
            frms(i,k,j,icl)= msm(i,k,j,icl)/qsnowt(i,k,j,icl)
          else
            frms(i,k,j,icl)=0.0
          endif
        enddo
      enddo
!..Melting of graupel particles
        do k = kts,kte
          frmg(i,k,j,1)=0.0
          frmg(i,k,j,2)=0.0
          frmg(i,k,j,3)=0.0
          frmg(i,k,j,4)=0.0
          frmg(i,k,j,5)=0.0
          frmg(i,k,j,6)=0.0
          frmg(i,k,j,7)=0.0
          frmg(i,k,j,8)=0.0
          frmg(i,k,j,9)=0.0
         enddo
      do icl = 10, ncl
        do k = kts, kte
          qgrat(i,k,j,icl)=mg(i,k,j,icl)+mgm(i,k,j,icl)
          if (qgrat(i,k,j,icl).gt.0.0) then
            frmg(i,k,j,icl)= mgm(i,k,j,icl)/qgrat(i,k,j,icl)
          else
            frmg(i,k,j,icl)=0.0
          endif
        enddo
      enddo


      IF ( PRESENT ( diagflag ) ) THEN
       if ( diagflag .and. do_radar_ref == 1 ) then
      PHI=DASIN(1.d0)*2.d0
      M(1) = (4.d0*PHI*rhw*RDR_1**3.d0)/3.d0
      RDR(1) = RDR_1
      DO icl=2,ncl+1
       KM1=icl-1
       M(icl)=M(1)*PK**KM1
       RDR(icl)=RDR(1)*PK**(KM1/3.d0)
       DDCI(icl)=16.3*DSQRT(M(icl))
       DDGRA(icl)=(6.*M(icl)/PHI/RHOGR)**0.33333333
      ENDDO
!..Bins for the snowflakes
      DO icl=1,ncl+1
       IF (M(icl).LE.MSNOW100) THEN
          RSNOW=RSNOW0
          ROSNOW(icl)=ROSNOW0
          DDSNOW(icl)=16.28*SQRT(M(icl))
       ENDIF
       IF (M(icl).GE.MSNOW500) THEN
          RSNOW=RSNOW1
          ROSNOW(icl)=ROSNOW1
          DDSNOW(icl)=SQRT(6.*M(icl)/PHI/0.17)
       ENDIF
       IF (M(icl).GT.MSNOW100.AND.M(icl).LT.MSNOW500) THEN
          A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B1=RSNOW1-A1*ALOG10(MSNOW500)
          A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B2=ROSNOW1-A2*ALOG10(MSNOW500)
          RSNOW=A1*DLOG10(M(icl))+B1
          ROSNOW(icl)=A2*DLOG10(M(icl))+B2
          DDSNOW(icl)=(6.0*M(icl)/PHI/RSNOW/ROSNOW(icl))**0.33333333
       ENDIF
      ENDDO
         do k = kts,kte
	    do icl = 1, ncl
             call reflbin(nnc(i,k,j,icl),nng(i,k,j,icl),frmg(i,k,j,icl),  &
     &       nns(i,k,j,icl),frms(i,k,j,icl),nni(i,k,j,icl),t_old(i,k,j),  &
     &       bin_dBZ(i,k,j,icl),M(icl),RDR(icl),RHOSNOW(icl))
           enddo
         enddo
         do k = kts, kte
             sdBZ(i,k,j)= sdBZ(i,k,j) + bin_dBZ(i,k,j,1)+ bin_dBZ(i,k,j,2)+&
    &        bin_dBZ(i,k,j,3)+ bin_dBZ(i,k,j,4)+ bin_dBZ(i,k,j,5)+       &
    &        bin_dBZ(i,k,j,6)+ bin_dBZ(i,k,j,7)+ bin_dBZ(i,k,j,8)+       &
    &        bin_dBZ(i,k,j,9)+ bin_dBZ(i,k,j,10)+ bin_dBZ(i,k,j,11)+     &
    &        bin_dBZ(i,k,j,12)+ bin_dBZ(i,k,j,13)+ bin_dBZ(i,k,j,14)+    &
    &        bin_dBZ(i,k,j,15)+ bin_dBZ(i,k,j,16)+ bin_dBZ(i,k,j,17)+    &
    &        bin_dBZ(i,k,j,18)+ bin_dBZ(i,k,j,19)+ bin_dBZ(i,k,j,20)+    &
    &        bin_dBZ(i,k,j,21)+ bin_dBZ(i,k,j,22)+ bin_dBZ(i,k,j,23)+    &
    &        bin_dBZ(i,k,j,24)+ bin_dBZ(i,k,j,25)+ bin_dBZ(i,k,j,26)+    &
    &        bin_dBZ(i,k,j,27)+ bin_dBZ(i,k,j,28)+ bin_dBZ(i,k,j,29)+    &
    &        bin_dBZ(i,k,j,30)+ bin_dBZ(i,k,j,31)+ bin_dBZ(i,k,j,32)+    &
    &        bin_dBZ(i,k,j,33)+ bin_dBZ(i,k,j,34)+ bin_dBZ(i,k,j,35)+    &
    &        bin_dBZ(i,k,j,36)
         
             sdBZ(i,k,j)=10.*log10(sdBZ(i,k,j)*1.d18)
             refl_10cm(i,k,j) = MAX(-35., sdBZ(i,k,j))
         enddo
       endif
      ENDIF		 
	  
      enddo i_loop
      enddo j_loop
!
!    output of the maximum values at every time step
!
         WRITE(95,*) 'time',itimestep*dt
         WRITE(95,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(95,*) 'qv and tk at max. supsat',qvsmax,tsmax
!         WRITE(95,*) 'qv and tk at max. supsat bf micro',moist(isupsmax,ksupsmax,jsupsmax,2),th(isupsmax,ksupsmax,jsupsmax)*pii(isupsmax,ksupsmax,jsupsmax)
!         WRITE(95,*) 'qv and tk at max. supsat old',moist_old(isupsmax,ksupsmax,jsupsmax,2),(300.0+th_old(isupsmax,ksupsmax,jsupsmax))*pii(isupsmax,ksupsmax,jsupsmax)
         WRITE(95,*) 'max conc. of water',nwmax,inwmax,jnwmax,knwmax
         WRITE(95,*) 'max. mixing ratio of water',qwmax,iqwmax,jqwmax,kqwmax
         WRITE(95,*) 'max conc. of rain',nrmax,inrmax,jnrmax,knrmax
         WRITE(95,*) 'max. mixing ratio of rain',qrmax,iqrmax,jqrmax,kqrmax

         WRITE(96,*) 'time',itimestep*dt
         WRITE(96,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(96,*) 'qv and tk at max. supsat',qvsmax,tsmax         
         WRITE(96,*) 'max conc. of pristine ice',nicmax,inicmax,jnicmax,knicmax
         WRITE(96,*) 'max. mixing ratio of pristine ice',qicmax,iqicmax,jqicmax,kqicmax
         WRITE(96,*) 'max conc. of snow',nsmax,insmax,jnsmax,knsmax
         WRITE(96,*) 'max. mixing ratio of snow',qsmax,iqsmax,jqsmax,kqsmax

         WRITE(97,*) 'time',itimestep*dt
         WRITE(97,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(97,*) 'qv and tk at max. supsat',qvsmax,tsmax
         WRITE(97,*) 'max conc. of graupel',ngrmax,ingrmax,jngrmax,kngrmax
         WRITE(97,*) 'max. mixing ratio of graupel',qgrmax,iqgrmax,jqgrmax,kqgrmax

         print*, 'TIME',itimestep*dt
         print*
         print*, 'TDSNTC0', TDSNTC0
         print*, 'TDSNTC1', TDSNTC1
         print*, 'TDSNTC1B', TDSNTC1B
         print*, 'TDSNTC2', TDSNTC2
         print*, 'TDSNTC3', TDSNTC3
         print*, 'TDSNTC4', TDSNTC4
         print*, 'TDSNTC5', TDSNTC5
         print*, 'TDSNTC6', TDSNTC6
         print*, 'TDSNTC8', TDSNTC8
         print*, 'TDSNTC8S', TDSNTC8S
         print*, 'TDSNTC10', TDSNTC10
         print*, 'TDSMTC0', TDSMTC0
         print*, 'TDSMTC1', TDSMTC1
         print*, 'TDSMTC1B', TDSMTC1B
         print*, 'TDSMTC2', TDSMTC2
         print*, 'TDSMTC3', TDSMTC3
         print*, 'TDSMTC4', TDSMTC4
         print*, 'TDSMTC5', TDSMTC5
         print*, 'TDSMTC6', TDSMTC6
         print*, 'TDSMTC8', TDSMTC8
         print*, 'TDSMTC8S', TDSMTC8S
         print*, 'TDSMTC9', TDSMTC9
         print*, 'TDSMTC10', TDSMTC10
         print*, 'TDSNTCI0', TDSNTCI0
         print*, 'TDSNTCI1', TDSNTCI1
         print*, 'TDSNTCI2', TDSNTCI2
         print*, 'TDSNTCI3', TDSNTCI3
         print*, 'TDSNTCI4', TDSNTCI4
         print*, 'TDSNTCI5', TDSNTCI5
         print*, 'TDSNTCI6', TDSNTCI6
         print*, 'TDSNTCI9', TDSNTCI9
         print*, 'TDSNTCI10', TDSNTCI10
         print*, 'TDSNTCI11', TDSNTCI11
         print*, 'TDSMTCI0', TDSMTCI0
         print*, 'TDSMTCI1', TDSMTCI1
         print*, 'TDSMTCI2', TDSMTCI2
         print*, 'TDSMTCI3', TDSMTCI3
         print*, 'TDSMTCI4', TDSMTCI4
         print*, 'TDSMTCI5', TDSMTCI5
         print*, 'TDSMTCI6', TDSMTCI6
         print*, 'TDSMTCI9', TDSMTCI9
         print*, 'TDSMTCI10', TDSMTCI10
         print*, 'TDSMTCI11', TDSMTCI11
         print*, 'TDSNTCIR0', TDSNTCIR0
         print*, 'TDSNTCIR1', TDSNTCIR1
         print*, 'TDSNTCIR2', TDSNTCIR2
         print*, 'TDSNTCIR4', TDSNTCIR4
         print*, 'TDSNTCIR5', TDSNTCIR5
         print*, 'TDSNTCIR6', TDSNTCIR6
         print*, 'TDSNTCIR7', TDSNTCIR7
         print*, 'TDSNTCIR8', TDSNTCIR8
         print*, 'TDSNTCIR9', TDSNTCIR9
         print*, 'TDSMTCIR0', TDSMTCIR0
         print*, 'TDSMTCIR1', TDSMTCIR1
         print*, 'TDSMTCIR2', TDSMTCIR2
         print*, 'TDSMTCIR4', TDSMTCIR4
         print*, 'TDSMTCIR5', TDSMTCIR5
         print*, 'TDSMTCIR6', TDSMTCIR6
         print*, 'TDSMTCIR7', TDSMTCIR7
         print*, 'TDSMTCIR8', TDSMTCIR8
         print*, 'TDSMTCIR9', TDSMTCIR9
         print*, 'TDSNTRIME0 ',  TDSNTRIME0
         print*, 'TDSMTRIME0 ',  TDSMTRIME0
         print*, 'TDSNTRIME1 ',  TDSNTRIME1
         print*, 'TDSNTRIME2 ',  TDSNTRIME2
         print*, 'TDSNTRIME3 ',  TDSNTRIME3
         print*, 'TDSNTRIME4 ',  TDSNTRIME4
         print*, 'TDSNTRIME5 ',  TDSNTRIME5
         print*, 'TDSMTRIME1 ',  TDSMTRIME1
         print*, 'TDSMTRIME2 ',  TDSMTRIME2
         print*, 'TDSMTRIME3 ',  TDSMTRIME3
         print*, 'TDSMTRIME4 ',  TDSMTRIME4
         print*, 'TDSMTRIME5 ',  TDSMTRIME5
         
         print*, 'TDSMTSNOWM0 ',  TDSMTSNOWM0
         print*, 'TDSMTSNOWM1 ',  TDSMTSNOWM1
         print*, 'TDSMTSNOWM2 ',  TDSMTSNOWM2
         print*, 'TDSMTSNOWM3 ',  TDSMTSNOWM3
         print*, 'TDSMTSNOWM4 ',  TDSMTSNOWM4
         print*, 'TDSMTGRAM0 ',  TDSMTGRAM0
         print*, 'TDSMTGRAM3 ',  TDSMTGRAM3
         print*, 'TDSMTGRAM4 ',  TDSMTGRAM4
         print*, 'TDSMTGRAM5 ',  TDSMTGRAM5
         print*, 'TDSNTGRA0', TDSNTGRA0
         print*, 'TDSNTGRA2', TDSNTGRA2
         print*, 'TDSNTGRA3', TDSNTGRA3
         print*, 'TDSNTGRA4', TDSNTGRA4
         print*, 'TDSNTGRA5', TDSNTGRA5
         print*, 'TDSNTGRA7', TDSNTGRA7
         print*, 'TDSNTGRA10', TDSNTGRA10
         print*, 'TDSNTGRA11', TDSNTGRA11
         print*, 'TDSNTGRA12', TDSNTGRA12
         print*, 'TDSMTGRA0', TDSMTGRA0
         print*, 'TDSMTGRA2', TDSMTGRA2
         print*, 'TDSMTGRA3', TDSMTGRA3
         print*, 'TDSMTGRA4', TDSMTGRA4
         print*, 'TDSMTGRA5', TDSMTGRA5
         print*, 'TDSMTGRA7', TDSMTGRA7
         print*, 'TDSMTGRA10', TDSMTGRA10
         print*, 'TDSMTGRA11', TDSMTGRA11
         print*, 'TDSMTGRA12', TDSMTGRA12
! xue add for shedding
         print*, 'TDSNTC11', TDSNTC11
         print*, 'TDSNTC12', TDSNTC12
         print*, 'TDSNTCIR10', TDSNTCIR10
         print*, 'TDSNTCIR11', TDSNTCIR11
         print*, 'TDSNTGRA13', TDSNTGRA13
         print*, 'TDSNTGRA14', TDSNTGRA14
         print*, 'TDSMTC11', TDSMTC11
         print*, 'TDSMTC12', TDSMTC12
         print*, 'TDSMTCIR10', TDSMTCIR10
         print*, 'TDSMTCIR11', TDSMTCIR11
         print*, 'TDSMTGRA13', TDSMTGRA13
         print*, 'TDSMTGRA14', TDSMTGRA14

      end SUBROUTINE mp_gi_driver

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      SUBROUTINE mp_gi_pg_driver (                                         &
     &                         itimestep,th,pii,p,dt,dz8w,rho,          &
     &                         t_old,dx,dy,                             &
     &                         scalar_old, scalar,                      &
     &                         n_scalar,ssw,ssi,                        &
     &                         DNW_ACTV,DNW_COAG,DNW_BRUP,DNI_COLL,     &
     &                         DMW_DIFF,DMW_FRML,DMI_DIFF,DMWI_MELT,    &
     &                         DMWI_DIFF,DMW_RIME,DNW_SHED,DMG_RIME,    &
     &                         RAINNC, RAINNCV,                         &
     &                         snownc, snowncv,                         &
     &                         graupelnc, graupelncv,                   &
     &                         sr,refl_10cm,                            &
     &			               diagflag,do_radar_ref,                   &
     &                         ids,ide, jds,jde, kds,kde,               &
     &                         ims,ime, jms,jme, kms,kme,               &
     &                         its,ite, jts,jte, kts,kte)

      IMPLICIT NONE

      INTEGER, INTENT(IN) :: ids,ide, jds,jde, kds,kde ,                &
     &                       ims,ime, jms,jme, kms,kme ,                &
     &                       its,ite, jts,jte, kts,kte
      INTEGER, INTENT(IN) :: itimestep, n_scalar  !,n_moist
      REAL, INTENT(IN) :: dt,dx,dy

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(IN   ) ::      &
     &                 RHO,PII,P,DZ8W

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) ::      &
     &                DNW_ACTV,DNW_COAG,DNW_BRUP,DNI_COLL,              &
     &                DMW_DIFF,DMW_FRML,DMI_DIFF,DMWI_MELT,             &
     &                DMWI_DIFF,DMW_RIME,DNW_SHED,DMG_RIME

      REAL, DIMENSION(IMS:IME, JMS:JME), INTENT(INOUT) :: RAINNC,RAINNCV,&
     &                snownc, snowncv, graupelnc, graupelncv, SR

      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: TH,T_OLD
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: ssw,ssi
!      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_moist), INTENT(IN) :: moist_old
!      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_moist), INTENT(INOUT) :: moist
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar_old
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(INOUT) :: scalar
! Radar variables:
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME), INTENT(INOUT) :: refl_10cm
      LOGICAL, OPTIONAL, INTENT(IN) :: diagflag  !, diagpiggy
      INTEGER, OPTIONAL, INTENT(IN) :: do_radar_ref  !, do_piggyback 
!
!+---+  LOCAL VARS
!
!.. Local variables to radar calculation
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      ms, msm, msr, mg, mgm, frms, frmg, mc, mi, qsnowt, qgrat
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      nns, nnsr, nng, nnc, nni
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, nbins):: &
     &      bin_dBZ
      REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME):: sdBZ
      INTEGER, PARAMETER :: ncl = 36
      INTEGER  :: icl
      CHARACTER*512 errmess
!.. Old and new tstep values of all bins of mixing ratios and number
!.. concentrations of: water drops, cloud ice, snow, graupel,
!.. frozen rime on snow, snowmelt, and graupelmelt water.  The
!.. melt waters do not have equivalent variables in number conc.
!.. Column oriented variables simplify things for calling primary routine

      REAL, DIMENSION(KTS:KTE, nbins) ::                                &
     &           qcw0, qcw1, qice0, qice1, qsnow0, qsnow1, qgra0, qgra1 &
     &          ,qsnowr0, qsnowr1, qsnowm0, qsnowm1, qgram0, qgram1
      REAL, DIMENSION(KTS:KTE, nbins) ::                                &
     &           ncw0, ncw1, nice0, nice1, nsnow0, nsnow1, ngra0, ngra1 &
     &          ,nsnowr0, nsnowr1
      REAL, DIMENSION(KTS:KTE) :: ccn0, ccn1, nidep0, nidep1

!.. Old and new tstep values of thermo variables

      REAL, DIMENSION(KTS:KTE) :: prez, tz,tz_old, qvz,qvz_old,         &
     &           rhoz, dzz

      INTEGER :: i, j, i_start, i_end, j_start, j_end, k, kk, kk1,      &
     &           kkstart, kkend

      REAL :: pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram, ddx
      REAL :: QWAT,NWAT,QRAIN,NRAIN,QICE,NICE,QSNOW,NSNOW,QGRA,NGRA,    &
     &        SUPSAT,EWS,QWS
      REAL :: QWMAX,NWMAX,QRMAX,NRMAX,QICMAX,NICMAX,QSMAX,NSMAX,QGRMAX, &
     &        NGRMAX,SUPSMAX,TSMAX,QVSMAX
      INTEGER ::IQWMAX,KQWMAX,INWMAX,KNWMAX,IQRMAX,KQRMAX,INRMAX,KNRMAX,&
     &          IQICMAX,KQICMAX,INICMAX,KNICMAX,IQSMAX,KQSMAX,INSMAX,   &
     &         KNSMAX,IQGRMAX,KQGRMAX,INGRMAX,KNGRMAX,ISUPSMAX,KSUPSMAX,&
     &        JQWMAX,JNWMAX,JQRMAX,JNRMAX,JQICMAX,JNICMAX,JQSMAX,JNSMAX,&
     &        JQGRMAX,JNGRMAX,JSUPSMAX

!..Arrays and variables for the bin size calculations.
      REAL, PARAMETER :: MSNOW100 = 3.773e-11
      REAL, PARAMETER :: MSNOW500 = 2.22529e-8
      REAL, PARAMETER :: MSNOWTV = 3.2906e-8
      REAL, PARAMETER :: ROSNOW0 = 900.0
      REAL, PARAMETER :: ROSNOW1 = 340.0
      REAL, PARAMETER :: RSNOW0 = 0.08
      REAL, PARAMETER :: RSNOW1 = 1.0
      DOUBLE PRECISION, PARAMETER :: PK = 2.d0
      DOUBLE PRECISION, PARAMETER :: RDR_1 = 1.56250000d-6
      REAL, PARAMETER :: rhw = 1000.
      REAL, PARAMETER :: rhi = 890.
      REAL, PARAMETER :: RHOGR = 900.
      real :: KM1, A1, B1, A2, B2, RSNOW
      double precision :: PHI
      double precision, dimension(nbins+1) :: &
    &          M, RDR, RHOSNOW,ROSNOW,DDCI, DDGRA, DDSNOW
!+---+

!      write(*,*),CCW

      do i = 1, slend
         mp_debug(i:i) = char(0)
      enddo

!.. Initialize all tendencies to zero
      TDSNTC0=0.0
      TDSNTC1=0.0
      TDSNTC1B=0.0
      TDSNTC2=0.0
      TDSNTC3=0.0
      TDSNTC4=0.0
      TDSNTC5=0.0
      TDSNTC6=0.0
      TDSNTC8=0.0
      TDSNTC8S=0.0
      TDSNTC10=0.0
      TDSMTC0=0.0
      TDSMTC1=0.0
      TDSMTC1B=0.0
      TDSMTC2=0.0
      TDSMTC3=0.0
      TDSMTC4=0.0
      TDSMTC5=0.0
      TDSMTC6=0.0
      TDSMTC8=0.0
      TDSMTC8S=0.0
      TDSMTC9=0.0 
      TDSMTC10=0.0
      TDSNTCI0=0.0
      TDSNTCI1=0.0
      TDSNTCI2=0.0            
      TDSNTCI3=0.0
      TDSNTCI4=0.0
      TDSNTCI5=0.0
      TDSNTCI6=0.0
      TDSNTCI9=0.0
      TDSNTCI10=0.0
      TDSNTCI11=0.0
      TDSMTCI0=0.0
      TDSMTCI1=0.0
      TDSMTCI2=0.0
      TDSMTCI3=0.0
      TDSMTCI4=0.0
      TDSMTCI5=0.0
      TDSMTCI6=0.0
      TDSMTCI9=0.0
      TDSMTCI10=0.0
      TDSMTCI11=0.0
      TDSNTCIR0=0.0
      TDSNTCIR1=0.0
      TDSNTCIR2=0.0
      TDSNTCIR2V=0.0
      TDSNTCIR4=0.0
      TDSNTCIR5=0.0
      TDSNTCIR6=0.0
      TDSNTCIR7=0.0
      TDSNTCIR8=0.0
      TDSNTCIR9=0.0
      TDSMTCIR0=0.0
      TDSMTCIR1=0.0
      TDSMTCIR2=0.0
      TDSMTCIR2V=0.0
      TDSMTCIR4=0.0
      TDSMTCIR5=0.0
      TDSMTCIR6=0.0
      TDSMTCIR7=0.0
      TDSMTCIR8=0.0
      TDSMTCIR9=0.0
      TDSNTGRA0=0.0
      TDSNTGRA2=0.0
      TDSNTGRA3=0.0
      TDSNTGRA3V=0.0
      TDSNTGRA4=0.0
      TDSNTGRA5=0.0
      TDSNTGRA7=0.0
      TDSNTGRA10=0.0
      TDSNTGRA11=0.0
      TDSNTGRA12=0.0
      TDSMTGRA0=0.0
      TDSMTGRA2=0.0
      TDSMTGRA3=0.0
      TDSMTGRA3V=0.0
      TDSMTGRA4=0.0
      TDSMTGRA5=0.0
      TDSMTGRA7=0.0
      TDSMTGRA10=0.0
      TDSMTGRA11=0.0
      TDSMTGRA12=0.0
      TDSNTRIME0=0.0
      TDSNTRIME1=0.0
      TDSNTRIME2=0.0
      TDSNTRIME3=0.0
      TDSNTRIME4=0.0
      TDSNTRIME5=0.0
      TDSMTRIME0=0.0
      TDSMTRIME1=0.0
      TDSMTRIME2=0.0
      TDSMTRIME3=0.0
      TDSMTRIME4=0.0
      TDSMTRIME5=0.0
      TDSMTSNOWM0=0.0
      TDSMTSNOWM1=0.0
      TDSMTSNOWM2=0.0
      TDSMTSNOWM3=0.0
      TDSMTSNOWM4=0.0
      TDSMTGRAM0=0.0
      TDSMTGRAM3=0.0
      TDSMTGRAM4=0.0
      TDSMTGRAM5=0.0
! xue add for shedding
      TDSNTC11=0.0
      TDSMTC11=0.0
      TDSNTC12=0.0
      TDSMTC12=0.0
      TDSNTCIR10=0.0
      TDSMTCIR10=0.0
      TDSNTCIR11=0.0
      TDSMTCIR11=0.0
      TDSNTGRA13=0.0
      TDSMTGRA13=0.0
      TDSNTGRA14=0.0
      TDSMTGRA14=0.0

! initialize all conversion rates

      DO J = JMS, JME
       DO I = IMS, IME
        DO K = KMS, KME
         DNW_ACTV(I,K,J) =0.
         DNW_COAG(I,K,J) =0.
         DNW_BRUP(I,K,J) =0.
         DNI_COLL(I,K,J) =0.
         DMW_DIFF(I,K,J) =0.
         DMW_FRML(I,K,J) =0.
         DMI_DIFF(I,K,J) =0.
         DMWI_MELT(I,K,J)=0.
         DMWI_DIFF(I,K,J)=0.
         DMW_RIME(I,K,J) =0.
         DNW_SHED(I,K,J) =0.
         DMG_RIME(I,K,J) =0.
        ENDDO
       ENDDO
      ENDDO

! initialize the maximum index
      IQWMAX=0
      KQWMAX=0
      INWMAX=0
      KNWMAX=0
      IQRMAX=0
      KQRMAX=0
      INRMAX=0
      KNRMAX=0
      IQICMAX=0
      KQICMAX=0
      INICMAX=0
      KNICMAX=0
      IQSMAX=0
      KQSMAX=0
      INSMAX=0
      KNSMAX=0
      IQGRMAX=0
      KQGRMAX=0
      INGRMAX=0
      KNGRMAX=0
      ISUPSMAX=0
      KSUPSMAX=0
      JQWMAX=0
      JNWMAX=0
      JQRMAX=0
      JNRMAX=0
      JQICMAX=0
      JNICMAX=0
      JQSMAX=0
      JNSMAX=0
      JQGRMAX=0
      JNGRMAX=0
      JSUPSMAX=0

      ddx = SQRT(dx*dy)
      i_start = its
      j_start = jts
      i_end   = min(ite, ide-1)
      j_end   = min(jte, jde-1)
!..For idealized testing by developer.
!-GT  if ( (ide-ids+1).gt.10 .and. (jde-jds+1).lt.10 ) then
!-GT     i_start = its + 2
!-GT     i_end   = min(ite, ide-1)
!-GT     j_start = jts
!-GT     j_end   = min(jte, jde-1)
!-GT  endif
         QWMAX=0.0
         NWMAX=0.0
         QRMAX=0.0
         NRMAX=0.0
         QICMAX=0.0
         NICMAX=0.0
         QSMAX=0.0
         NSMAX=0.0
         QGRMAX=0.0
         NGRMAX=0.0
         SUPSMAX= -10.
      j_loop:  do j = j_start, j_end
      i_loop:  do i = i_start, i_end
         ipt = i
         jpt = j
         debug_flag = .false.
!         if (i.eq.10 .and. j.eq.j_start) debug_flag = .true.
!         kk = 2
         DO K = KTS, KTE
            dzz(k) = dz8w(i,k,j)
            rhoz(k) = rho(i,k,j)
            prez(k) = p(i,k,j)
            tz(k) = th(i,k,j)*pii(i,k,j)
            tz_old(k) = (300.0+t_old(i,k,j))*pii(i,k,j) !t_old(i,k,j)
            qvz(k) = scalar(i,k,j, P_QV_PG)
            qvz_old(k) = scalar_old(i,k,j, P_QV_PG)
! xue save saturation ratios for water and ice
            ssw(i,k,j) = qvz_old(k)/(0.622*EXP(53.67957-6743.769/tz_old(k)-4.8451*log(tz_old(k)))*100./prez(k))
            ssi(i,k,j) = qvz_old(k)/(0.622*EXP(23.33086-6111.72784/tz_old(k)+0.15215*log(tz_old(k)))*100./prez(k))
! Radar variables
         sdBZ(i,k,j) = 0.0
         DO ICL = 1, nbins
            bin_dBZ(i,k,j,icl) = 0.0
            mc(i,k,j,icl) = 0.0
            nnc(i,k,j,icl) = 0.0
            mi(i,k,j,icl) = 0.0
            nni(i,k,j,icl) = 0.0
            ms(i,k,j,icl) = 0.0
            msm(i,k,j,icl) = 0.0
            msr(i,k,j,icl) = 0.0
	        nns(i,k,j,icl) = 0.0
            frms(i,k,j,icl) = 0.0
            mg(i,k,j,icl) = 0.0
            mgm(i,k,j,icl) = 0.0
	        nng(i,k,j,icl) = 0.0
            frmg(i,k,j,icl) = 0.0
            qsnowt(i,k,j,icl) = 0.0
            qgrat(i,k,j,icl) = 0.0
         ENDDO
	ENDDO

! >>>>>> New type of read in bin variables starts here
	 	   
DO K = KTS, KTE
	   call read_in_bin_pg(qcw1,qcw0,qice1,qice0, &
  &    qsnow1,qsnow0,qgra1,qgra0,qsnowr1,qsnowr0,    &
  &    qsnowm1,qsnowm0,qgram1,qgram0,ncw1,ncw0,      &
  &    nice1,nice0,nsnow1,nsnow0,ngra1,ngra0,nsnowr1,&
  &	   nsnowr0,scalar,scalar_old,   			     &
  &    n_scalar,ids,ide, jds,jde, kds,kde,           &
  &    ims,ime, jms,jme, kms,kme,  					 &
  &    its,ite, jts,jte, kts,kte,  					 &
  &    i,j,k)
  
DO KK = 1, ncl	 
  if (old_adv) then
   qcw0(K,KK) = MAX(0.,qcw0(K,KK))
   qice0(K,KK) = MAX(0.,qice0(K,KK))
   qsnow0(K,KK) = MAX(0.,qsnow0(K,KK))
   qgra0(K,KK) = MAX(0.,qgra0(K,KK))
   qsnowr0(K,KK) = MAX(0.,qsnowr0(K,KK))
   qsnowm0(K,KK) = MAX(0.,qsnowm0(K,KK))
   qgram0(K,KK) = MAX(0.,qgram0(K,KK))
   ncw0(K,KK) = MAX(0.,ncw0(K,KK))
   nice0(K,KK) = MAX(0.,nice0(K,KK))
   nsnow0(K,KK) = MAX(0.,nsnow0(K,KK))
   ngra0(K,KK) = MAX(0.,ngra0(K,KK))
   nsnowr0(K,KK) = MAX(0.,nsnowr0(K,KK))
 else
   qcw0(K,KK) = MAX(0.,qcw1(K,KK))
   qice0(K,KK) = MAX(0.,qice1(K,KK))
   qsnow0(K,KK) = MAX(0.,qsnow1(K,KK))
   qgra0(K,KK) = MAX(0.,qgra1(K,KK))
   qsnowr0(K,KK) = MAX(0.,qsnowr1(K,KK))
   qsnowm0(K,KK) = MAX(0.,qsnowm1(K,KK))
   qgram0(K,KK) = MAX(0.,qgram1(K,KK))
   ncw0(K,KK) = MAX(0.,ncw1(K,KK))
   nice0(K,KK) = MAX(0.,nice1(K,KK))
   nsnow0(K,KK) = MAX(0.,nsnow1(K,KK))
   ngra0(K,KK) = MAX(0.,ngra1(K,KK))
   nsnowr0(K,KK) = MAX(0.,nsnowr1(K,KK))
 end if		  
 if (ncw1(K,KK).lt.1.E-10) then
   ncw1(K,KK) = 0.0
   qcw1(K,KK) = 0.0
 endif
 if (nice1(K,KK).lt.1.E-10) then
   nice1(K,KK) = 0.0
   qice1(K,KK) = 0.0
 endif
 if (nsnow1(K,KK).lt.1.E-10) then
   nsnow1(K,KK) = 0.0
   qsnow1(K,KK) = 0.0
 endif
 if (ngra1(K,KK).lt.1.E-10) then
   ngra1(K,KK) = 0.0
   qgra1(K,KK) = 0.0
 endif		
 if (nsnowr1(K,KK).lt.1.E-10) then
   nsnowr1(K,KK) = 0.0
   qsnowr1(K,KK) = 0.0
 endif	
 qsnow1(K,KK) = qsnow1(K,KK) + qsnowr1(K,KK) + qsnowm1(K,KK)
 qsnow0(K,KK) = qsnow0(K,KK) + qsnowr0(K,KK) + qsnowm0(K,KK)
 qgra1(K,KK) = qgra1(K,KK) + qgram1(K,KK)
 qgra0(K,KK) = qgra0(K,KK) + qgram0(K,KK)			 
 ENDDO
 ccn1(K) = MAX(0.,scalar(i,k,j,P_CCN_PG))
 ccn0(K) = MAX(0.,scalar_old(i,k,j,P_CCN_PG))
 nidep1(K) = MAX(0.,scalar(i,k,j,P_NIDEP_PG))
 nidep0(K) = MAX(0.,scalar_old(i,k,j,P_NIDEP_PG))
ENDDO
! <<<<<< New type of read in bin variables ends here

         pptrain = 0.
         pptice = 0.
         pptsnow = 0.
         pptsnowm = 0.
         pptgra = 0.
         pptgram = 0.
         RAINNCV(i,j) = 0.
         SNOWNCV(i,j) = 0.
         GRAUPELNCV(i,j) = 0.
         SR(i,j) = 0.

         WRITE (mp_debug,*) 'CALLING mp_detailed for pt ', ipt, jpt
         if (jpt.eq.1) CALL wrf_debug(250, mp_debug)

      if (debug_flag) then
       DO KK = 1, nbins
        DO K = KTS, KTE
           WRITE (mp_debug,*) ' BEFORE micro piggybacking, (10,k,bin,num,mass,melt) ', k,kk,ngra0(k,kk),qgra0(k,kk),qgram0(k,kk)
           CALL wrf_debug(150, mp_debug)
        enddo
       enddo
      endif


   
!+---+-----------------------------------------------------------------+
      CALL mp_detailed_pg (prez, rhoz, tz, tz_old, qvz, qvz_old, dzz, ddx, &
     &     ncw0,ncw1,qcw0,qcw1,nice0,nice1,qice0,qice1,                 &
     &     nsnow0,nsnow1,qsnow0,qsnow1,nsnowr0,nsnowr1,qsnowr0,qsnowr1, &
     &     qsnowm0,qsnowm1,ngra0,ngra1,qgra0,qgra1,qgram0,qgram1,       &
     &     ccn1,ccn0,nidep1,nidep0,                                     &
     &     pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram,              &
     &     dt, nbins, kte, itimestep, i, j)
!+---+-----------------------------------------------------------------+

! update the 3D bulk conversion rates
      DO K = KTS, KTE
        DNW_ACTV(I,K,J) = DNWZ_ACTV(K)
        DNW_COAG(I,K,J) = DNWZ_COAG(K)
        DNW_BRUP(I,K,J) = DNWZ_BRUP(K)
        DNI_COLL(I,K,J) = DNIZ_COLL(K)
        DMW_DIFF(I,K,J) = DMWZ_DIFF(K)
        DMW_FRML(I,K,J) = DMWZ_FRML(K)
        DMI_DIFF(I,K,J) = DMIZ_DIFF(K)
        DMWI_MELT(I,K,J)= DMWIZ_MELT(K)
        DMWI_DIFF(I,K,J)= DMWIZ_DIFF(K)
        DMW_RIME(I,K,J) = DMWZ_RIME(K)
        DNW_SHED(I,K,J) = DNWZ_SHED(K)
        DMG_RIME(I,K,J) = DMGZ_RIME(K)
      ENDDO

      if (debug_flag) then
       DO KK = 1, nbins
        DO K = KTS, KTE
           WRITE (mp_debug,*) ' AFTER micro piggybacking, (10,k,bin,num,mass,melt) ', k,kk,ngra1(k,kk),qgra1(k,kk),qgram1(k,kk)
           CALL wrf_debug(150, mp_debug)
        enddo
       enddo
      endif

         DO K = KTS, KTE
            th(i,k,j) = tz(k)/pii(i,k,j)
            t_old(i,k,j) = tz(k)
         ENDDO
!
!   looking for the maximum values of mixing ratios and number concentration of different species
!
         DO K = KTS,KTE 
          QWAT=0.0
          NWAT=0.0
          QRAIN=0.0
          NRAIN=0.0
          QICE=0.0
          NICE=0.0
          QSNOW=0.0
          NSNOW=0.0
          QGRA=0.0
          NGRA=0.0
          DO KK =1,nbins
           QWAT = QWAT + QCW1(K,KK)
           NWAT = NWAT + NCW1(K,KK)
           IF (KK >= N_RAIN) THEN            
             QRAIN = QRAIN + QCW1(K,KK)
             NRAIN = NRAIN + NCW1(K,KK)
           ENDIF
           QICE = QICE + QICE1(K,KK)
           NICE = NICE + NICE1(K,KK)
           QSNOW = QSNOW + QSNOW1(K,KK)
           NSNOW = NSNOW + NSNOW1(K,KK)
           QGRA = QGRA + QGRA1(K,KK)
           NGRA = NGRA + NGRA1(K,KK)
           qsnow1(K,KK) = MAX(0., qsnow1(K,KK) - qsnowr1(K,KK) - qsnowm1(K,KK))
           qgra1(K,KK) = MAX(0., qgra1(K,KK) - qgram1(K,KK))
          ENDDO
          IF (QWAT > QWMAX) THEN
           QWMAX = QWAT
           IQWMAX = I
           JQWMAX = J
           KQWMAX = K
          ENDIF
          IF (NWAT > NWMAX) THEN
           NWMAX = NWAT
           INWMAX = I
           JNWMAX = J
           KNWMAX = K
          ENDIF
          IF (QRAIN > QRMAX) THEN
           QRMAX = QRAIN
           IQRMAX = I
           JQRMAX = J
           KQRMAX = K
          ENDIF
          IF (NRAIN > NRMAX) THEN
           NRMAX = NRAIN
           INRMAX = I
           JNRMAX = J
           KNRMAX = K
          ENDIF
          IF (QICE > QICMAX) THEN
           QICMAX = QICE
           IQICMAX = I
           JQICMAX = J
           KQICMAX = K
          ENDIF
          IF (NICE > NICMAX) THEN
           NICMAX = NICE
           INICMAX = I
           JNICMAX = J
           KNICMAX = K
          ENDIF
          IF (QSNOW > QSMAX) THEN
           QSMAX = QSNOW
           IQSMAX = I
           JQSMAX = J
           KQSMAX = K
          ENDIF
          IF (NSNOW > NSMAX) THEN
           NSMAX = NSNOW
           INSMAX = I
           JNSMAX = J
           KNSMAX = K
          ENDIF
          IF (QGRA > QGRMAX) THEN
           QGRMAX = QGRA
           IQGRMAX = I
           JQGRMAX = J
           KQGRMAX = K
          ENDIF
          IF (NGRA > NGRMAX) THEN
           NGRMAX = NGRA
           INGRMAX = I
           JNGRMAX = J
           KNGRMAX = K
          ENDIF

          EWS=EXP(53.67957-6743.769/tz(k)-4.8451*log(tz(k)))*100.
          QWS=0.622*EWS/PREZ(K)
          SUPSAT = QVZ(K)/QWS -1.0
          IF (SUPSAT > SUPSMAX) THEN
           SUPSMAX = SUPSAT
           TSMAX = TZ(K)
           QVSMAX = QVZ(K)
           ISUPSMAX = I
           JSUPSMAX = J
           KSUPSMAX = K
          ENDIF

!  end of the loop for looking for the max. values
            scalar(i,k,j, P_QV_PG) = qvz(k)
            scalar(i,k,j, P_QC_PG) = qwat-qrain
            scalar(i,k,j, P_QR_PG) = qrain
            scalar(i,k,j, P_QI_PG) = qice
            scalar(i,k,j, P_QS_PG) = qsnow
            scalar(i,k,j, P_QG_PG) = qgra
            scalar(i,k,j, P_QNC_PG) = nwat-nrain
            scalar(i,k,j, P_QNR_PG) = nrain
            scalar(i,k,j, P_QNI_PG) = nice
            scalar(i,k,j, P_QNS_PG) = nsnow
            scalar(i,k,j, P_QNG_PG) = ngra		
	 ENDDO

 DO K = KTS, KTE
 DO KK = 1 , ncl    
  IF ( PRESENT ( diagflag ) ) THEN
  if ( diagflag .and. do_radar_ref == 1 ) then
	 mc(i,k,j,kk) = qcw1(k,kk)
	 mi(i,k,j,kk) = qice1(k,kk)
	 ms(i,k,j,kk) = qsnow1(k,kk)
	 mg(i,k,j,kk) = qgra1(k,kk)
	 msr(i,k,j,kk) = qsnowr1(k,kk)
	 msm(i,k,j,kk) = qsnowm1(k,kk)
	 mgm(i,k,j,kk) = qgram1(k,kk)
	 nnc(i,k,j,kk) = ncw1(k,kk)
	 nni(i,k,j,kk) = nice1(k,kk)
	 nns(i,k,j,kk) = nsnow1(k,kk)
	 nng(i,k,j,kk) = ngra1(k,kk)
	 nnsr(i,k,j,kk) = nsnowr1(k,kk)
  endif
  ENDIF
  scalar(i,k,j,P_QNRS_PG) = scalar(i,k,j,P_QNRS_PG) + nsnowr1(K,KK)
  scalar(i,k,j,P_QFWS_PG) = scalar(i,k,j,P_QFWS_PG) + qsnowr1(K,KK)
  scalar(i,k,j,P_QMWS_PG) = scalar(i,k,j,P_QMWS_PG) + qsnowm1(K,KK)
  scalar(i,k,j,P_QMWG_PG) = scalar(i,k,j,P_QMWG_PG) + qgram1(K,KK)   
 ENDDO  		 
! New style
 
  scalar(i,k,j,P_CCN_PG) = MAX(0.,ccn1(k))
  scalar(i,k,j,P_NIDEP_PG) = MAX(0.,nidep1(k))
   call write_out_bin_pg(qcw1,qice1,qsnow1,qgra1,qsnowr1,&
   &                  qsnowm1,qgram1,ncw1,nice1,nsnow1,  &
   &                  ngra1,nsnowr1,scalar,n_scalar,     &  
   &                  ids,ide, jds,jde, kds,kde,  &
   &                  ims,ime, jms,jme, kms,kme,  &
   &                  its,ite, jts,jte, kts,kte,  &
   &                  i,j,k)	
 ENDDO
         RAINNCV(i,j) = pptrain + pptsnow + pptgra + pptice
         RAINNC(i,j) = RAINNC(i,j) + pptrain + pptsnow + pptgra + pptice
         SNOWNCV(i,j) = pptsnow + pptice
         SNOWNC(i,j) = SNOWNC(i,j) + pptsnow + pptice
         GRAUPELNCV(i,j) = pptgra
         GRAUPELNC(i,j) = GRAUPELNC(i,j) + pptgra
         SR(i,j) = (SNOWNCV(i,j)+GRAUPELNCV(i,j))/(RAINNCV(i,j)+1.e-12)

!!.. Variables for radar calculation
!..Melting of snowflakes
        do k = kts, kte
          frms(i,k,j,1)=0.0
          frms(i,k,j,2)=0.0
          frms(i,k,j,3)=0.0
          frms(i,k,j,4)=0.0
          frms(i,k,j,5)=0.0
          frms(i,k,j,6)=0.0
          frms(i,k,j,7)=0.0
          frms(i,k,j,8)=0.0
          frms(i,k,j,9)=0.0
        enddo
      do icl = 10, ncl
        do k = kts, kte
          qsnowt(i,k,j,icl)=ms(i,k,j,icl)+msm(i,k,j,icl)+msr(i,k,j,icl)
          if (qsnowt(i,k,j,icl).gt.0.0) then
            frms(i,k,j,icl)= msm(i,k,j,icl)/qsnowt(i,k,j,icl)
          else
            frms(i,k,j,icl)=0.0
          endif
        enddo
      enddo
!..Melting of graupel particles
        do k = kts,kte
          frmg(i,k,j,1)=0.0
          frmg(i,k,j,2)=0.0
          frmg(i,k,j,3)=0.0
          frmg(i,k,j,4)=0.0
          frmg(i,k,j,5)=0.0
          frmg(i,k,j,6)=0.0
          frmg(i,k,j,7)=0.0
          frmg(i,k,j,8)=0.0
          frmg(i,k,j,9)=0.0
         enddo
      do icl = 10, ncl
        do k = kts, kte
          qgrat(i,k,j,icl)=mg(i,k,j,icl)+mgm(i,k,j,icl)
          if (qgrat(i,k,j,icl).gt.0.0) then
            frmg(i,k,j,icl)= mgm(i,k,j,icl)/qgrat(i,k,j,icl)
          else
            frmg(i,k,j,icl)=0.0
          endif
        enddo
      enddo


      IF ( PRESENT ( diagflag ) ) THEN
       if ( diagflag .and. do_radar_ref == 1 ) then
      PHI=DASIN(1.d0)*2.d0
      M(1) = (4.d0*PHI*rhw*RDR_1**3.d0)/3.d0
      RDR(1) = RDR_1
      DO icl=2,ncl+1
       KM1=icl-1
       M(icl)=M(1)*PK**KM1
       RDR(icl)=RDR(1)*PK**(KM1/3.d0)
       DDCI(icl)=16.3*DSQRT(M(icl))
       DDGRA(icl)=(6.*M(icl)/PHI/RHOGR)**0.33333333
      ENDDO
!..Bins for the snowflakes
      DO icl=1,ncl+1
       IF (M(icl).LE.MSNOW100) THEN
          RSNOW=RSNOW0
          ROSNOW(icl)=ROSNOW0
          DDSNOW(icl)=16.28*SQRT(M(icl))
       ENDIF
       IF (M(icl).GE.MSNOW500) THEN
          RSNOW=RSNOW1
          ROSNOW(icl)=ROSNOW1
          DDSNOW(icl)=SQRT(6.*M(icl)/PHI/0.17)
       ENDIF
       IF (M(icl).GT.MSNOW100.AND.M(icl).LT.MSNOW500) THEN
          A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B1=RSNOW1-A1*ALOG10(MSNOW500)
          A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B2=ROSNOW1-A2*ALOG10(MSNOW500)
          RSNOW=A1*DLOG10(M(icl))+B1
          ROSNOW(icl)=A2*DLOG10(M(icl))+B2
          DDSNOW(icl)=(6.0*M(icl)/PHI/RSNOW/ROSNOW(icl))**0.33333333
       ENDIF
      ENDDO
         do k = kts,kte
	    do icl = 1, ncl
             call reflbin(nnc(i,k,j,icl),nng(i,k,j,icl),frmg(i,k,j,icl),  &
     &       nns(i,k,j,icl),frms(i,k,j,icl),nni(i,k,j,icl),t_old(i,k,j),  &
     &       bin_dBZ(i,k,j,icl),M(icl),RDR(icl),RHOSNOW(icl))
           enddo
         enddo
         do k = kts, kte
             sdBZ(i,k,j)= sdBZ(i,k,j) + bin_dBZ(i,k,j,1)+ bin_dBZ(i,k,j,2)+&
    &        bin_dBZ(i,k,j,3)+ bin_dBZ(i,k,j,4)+ bin_dBZ(i,k,j,5)+       &
    &        bin_dBZ(i,k,j,6)+ bin_dBZ(i,k,j,7)+ bin_dBZ(i,k,j,8)+       &
    &        bin_dBZ(i,k,j,9)+ bin_dBZ(i,k,j,10)+ bin_dBZ(i,k,j,11)+     &
    &        bin_dBZ(i,k,j,12)+ bin_dBZ(i,k,j,13)+ bin_dBZ(i,k,j,14)+    &
    &        bin_dBZ(i,k,j,15)+ bin_dBZ(i,k,j,16)+ bin_dBZ(i,k,j,17)+    &
    &        bin_dBZ(i,k,j,18)+ bin_dBZ(i,k,j,19)+ bin_dBZ(i,k,j,20)+    &
    &        bin_dBZ(i,k,j,21)+ bin_dBZ(i,k,j,22)+ bin_dBZ(i,k,j,23)+    &
    &        bin_dBZ(i,k,j,24)+ bin_dBZ(i,k,j,25)+ bin_dBZ(i,k,j,26)+    &
    &        bin_dBZ(i,k,j,27)+ bin_dBZ(i,k,j,28)+ bin_dBZ(i,k,j,29)+    &
    &        bin_dBZ(i,k,j,30)+ bin_dBZ(i,k,j,31)+ bin_dBZ(i,k,j,32)+    &
    &        bin_dBZ(i,k,j,33)+ bin_dBZ(i,k,j,34)+ bin_dBZ(i,k,j,35)+    &
    &        bin_dBZ(i,k,j,36)
         
             sdBZ(i,k,j)=10.*log10(sdBZ(i,k,j)*1.d18)
             refl_10cm(i,k,j) = MAX(-35., sdBZ(i,k,j))
         enddo
       endif
      ENDIF		 
	  
      enddo i_loop
      enddo j_loop
!
!    output of the maximum values at every time step
!
         WRITE(95,*) 'time',itimestep*dt
         WRITE(95,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(95,*) 'qv and tk at max. supsat',qvsmax,tsmax
!         WRITE(95,*) 'qv and tk at max. supsat bf micro',moist(isupsmax,ksupsmax,jsupsmax,2),th(isupsmax,ksupsmax,jsupsmax)*pii(isupsmax,ksupsmax,jsupsmax)
!         WRITE(95,*) 'qv and tk at max. supsat old',moist_old(isupsmax,ksupsmax,jsupsmax,2),(300.0+th_old(isupsmax,ksupsmax,jsupsmax))*pii(isupsmax,ksupsmax,jsupsmax)
         WRITE(95,*) 'max conc. of water',nwmax,inwmax,jnwmax,knwmax
         WRITE(95,*) 'max. mixing ratio of water',qwmax,iqwmax,jqwmax,kqwmax
         WRITE(95,*) 'max conc. of rain',nrmax,inrmax,jnrmax,knrmax
         WRITE(95,*) 'max. mixing ratio of rain',qrmax,iqrmax,jqrmax,kqrmax

         WRITE(96,*) 'time',itimestep*dt
         WRITE(96,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(96,*) 'qv and tk at max. supsat',qvsmax,tsmax         
         WRITE(96,*) 'max conc. of pristine ice',nicmax,inicmax,jnicmax,knicmax
         WRITE(96,*) 'max. mixing ratio of pristine ice',qicmax,iqicmax,jqicmax,kqicmax
         WRITE(96,*) 'max conc. of snow',nsmax,insmax,jnsmax,knsmax
         WRITE(96,*) 'max. mixing ratio of snow',qsmax,iqsmax,jqsmax,kqsmax

         WRITE(97,*) 'time',itimestep*dt
         WRITE(97,*) 'max. supsat at i,j,k',supsmax,isupsmax,jsupsmax,ksupsmax
         WRITE(97,*) 'qv and tk at max. supsat',qvsmax,tsmax
         WRITE(97,*) 'max conc. of graupel',ngrmax,ingrmax,jngrmax,kngrmax
         WRITE(97,*) 'max. mixing ratio of graupel',qgrmax,iqgrmax,jqgrmax,kqgrmax

         print*, 'TIME',itimestep*dt
         print*
         print*, 'TDSNTC0', TDSNTC0
         print*, 'TDSNTC1', TDSNTC1
         print*, 'TDSNTC1B', TDSNTC1B
         print*, 'TDSNTC2', TDSNTC2
         print*, 'TDSNTC3', TDSNTC3
         print*, 'TDSNTC4', TDSNTC4
         print*, 'TDSNTC5', TDSNTC5
         print*, 'TDSNTC6', TDSNTC6
         print*, 'TDSNTC8', TDSNTC8
         print*, 'TDSNTC8S', TDSNTC8S
         print*, 'TDSNTC10', TDSNTC10
         print*, 'TDSMTC0', TDSMTC0
         print*, 'TDSMTC1', TDSMTC1
         print*, 'TDSMTC1B', TDSMTC1B
         print*, 'TDSMTC2', TDSMTC2
         print*, 'TDSMTC3', TDSMTC3
         print*, 'TDSMTC4', TDSMTC4
         print*, 'TDSMTC5', TDSMTC5
         print*, 'TDSMTC6', TDSMTC6
         print*, 'TDSMTC8', TDSMTC8
         print*, 'TDSMTC8S', TDSMTC8S
         print*, 'TDSMTC9', TDSMTC9
         print*, 'TDSMTC10', TDSMTC10
         print*, 'TDSNTCI0', TDSNTCI0
         print*, 'TDSNTCI1', TDSNTCI1
         print*, 'TDSNTCI2', TDSNTCI2
         print*, 'TDSNTCI3', TDSNTCI3
         print*, 'TDSNTCI4', TDSNTCI4
         print*, 'TDSNTCI5', TDSNTCI5
         print*, 'TDSNTCI6', TDSNTCI6
         print*, 'TDSNTCI9', TDSNTCI9
         print*, 'TDSNTCI10', TDSNTCI10
         print*, 'TDSNTCI11', TDSNTCI11
         print*, 'TDSMTCI0', TDSMTCI0
         print*, 'TDSMTCI1', TDSMTCI1
         print*, 'TDSMTCI2', TDSMTCI2
         print*, 'TDSMTCI3', TDSMTCI3
         print*, 'TDSMTCI4', TDSMTCI4
         print*, 'TDSMTCI5', TDSMTCI5
         print*, 'TDSMTCI6', TDSMTCI6
         print*, 'TDSMTCI9', TDSMTCI9
         print*, 'TDSMTCI10', TDSMTCI10
         print*, 'TDSMTCI11', TDSMTCI11
         print*, 'TDSNTCIR0', TDSNTCIR0
         print*, 'TDSNTCIR1', TDSNTCIR1
         print*, 'TDSNTCIR2', TDSNTCIR2
         print*, 'TDSNTCIR4', TDSNTCIR4
         print*, 'TDSNTCIR5', TDSNTCIR5
         print*, 'TDSNTCIR6', TDSNTCIR6
         print*, 'TDSNTCIR7', TDSNTCIR7
         print*, 'TDSNTCIR8', TDSNTCIR8
         print*, 'TDSNTCIR9', TDSNTCIR9
         print*, 'TDSMTCIR0', TDSMTCIR0
         print*, 'TDSMTCIR1', TDSMTCIR1
         print*, 'TDSMTCIR2', TDSMTCIR2
         print*, 'TDSMTCIR4', TDSMTCIR4
         print*, 'TDSMTCIR5', TDSMTCIR5
         print*, 'TDSMTCIR6', TDSMTCIR6
         print*, 'TDSMTCIR7', TDSMTCIR7
         print*, 'TDSMTCIR8', TDSMTCIR8
         print*, 'TDSMTCIR9', TDSMTCIR9
         print*, 'TDSNTRIME0 ',  TDSNTRIME0
         print*, 'TDSMTRIME0 ',  TDSMTRIME0
         print*, 'TDSNTRIME1 ',  TDSNTRIME1
         print*, 'TDSNTRIME2 ',  TDSNTRIME2
         print*, 'TDSNTRIME3 ',  TDSNTRIME3
         print*, 'TDSNTRIME4 ',  TDSNTRIME4
         print*, 'TDSNTRIME5 ',  TDSNTRIME5
         print*, 'TDSMTRIME1 ',  TDSMTRIME1
         print*, 'TDSMTRIME2 ',  TDSMTRIME2
         print*, 'TDSMTRIME3 ',  TDSMTRIME3
         print*, 'TDSMTRIME4 ',  TDSMTRIME4
         print*, 'TDSMTRIME5 ',  TDSMTRIME5
         
         print*, 'TDSMTSNOWM0 ',  TDSMTSNOWM0
         print*, 'TDSMTSNOWM1 ',  TDSMTSNOWM1
         print*, 'TDSMTSNOWM2 ',  TDSMTSNOWM2
         print*, 'TDSMTSNOWM3 ',  TDSMTSNOWM3
         print*, 'TDSMTSNOWM4 ',  TDSMTSNOWM4
         print*, 'TDSMTGRAM0 ',  TDSMTGRAM0
         print*, 'TDSMTGRAM3 ',  TDSMTGRAM3
         print*, 'TDSMTGRAM4 ',  TDSMTGRAM4
         print*, 'TDSMTGRAM5 ',  TDSMTGRAM5
         print*, 'TDSNTGRA0', TDSNTGRA0
         print*, 'TDSNTGRA2', TDSNTGRA2
         print*, 'TDSNTGRA3', TDSNTGRA3
         print*, 'TDSNTGRA4', TDSNTGRA4
         print*, 'TDSNTGRA5', TDSNTGRA5
         print*, 'TDSNTGRA7', TDSNTGRA7
         print*, 'TDSNTGRA10', TDSNTGRA10
         print*, 'TDSNTGRA11', TDSNTGRA11
         print*, 'TDSNTGRA12', TDSNTGRA12
         print*, 'TDSMTGRA0', TDSMTGRA0
         print*, 'TDSMTGRA2', TDSMTGRA2
         print*, 'TDSMTGRA3', TDSMTGRA3
         print*, 'TDSMTGRA4', TDSMTGRA4
         print*, 'TDSMTGRA5', TDSMTGRA5
         print*, 'TDSMTGRA7', TDSMTGRA7
         print*, 'TDSMTGRA10', TDSMTGRA10
         print*, 'TDSMTGRA11', TDSMTGRA11
         print*, 'TDSMTGRA12', TDSMTGRA12
! xue add for shedding
         print*, 'TDSNTC11', TDSNTC11
         print*, 'TDSNTC12', TDSNTC12
         print*, 'TDSNTCIR10', TDSNTCIR10
         print*, 'TDSNTCIR11', TDSNTCIR11
         print*, 'TDSNTGRA13', TDSNTGRA13
         print*, 'TDSNTGRA14', TDSNTGRA14
         print*, 'TDSMTC11', TDSMTC11
         print*, 'TDSMTC12', TDSMTC12
         print*, 'TDSMTCIR10', TDSMTCIR10
         print*, 'TDSMTCIR11', TDSMTCIR11
         print*, 'TDSMTGRA13', TDSMTGRA13
         print*, 'TDSMTGRA14', TDSMTGRA14

      end SUBROUTINE mp_gi_pg_driver

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      SUBROUTINE mp_detailed (pz, rhoa, tz, tz_old, qv, qv_old, dz, dx, &
     &     ncw0,ncw1,qcw0,qcw1,nice0,nice1,qice0,qice1,                 &
     &     nsnow0,nsnow1,qsnow0,qsnow1,nsnowr0,nsnowr1,qsnowr0,qsnowr1, &
     &     qsnowm0,qsnowm1,ngra0,ngra1,qgra0,qgra1,qgram0,qgram1,       &
     &     ccn1,ccn0,nidep1,nidep0,                                     &
     &     pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram,              &
     &     dt, K4, nz, ist, ii, jj)

      IMPLICIT NONE   

      INTEGER, INTENT(IN) :: K4, nz, ist, ii, jj
      REAL, INTENT(IN) :: DT, DX
      REAL, INTENT(INOUT) :: pptrain,pptice,pptsnow,pptgra,pptsnowm,    &
     &           pptgram

      REAL, INTENT(IN), DIMENSION(NZ) :: pz, rhoa, tz_old, qv_old, dz
      REAL, INTENT(INOUT), DIMENSION(NZ) :: tz, qv
      REAL, INTENT(INOUT), DIMENSION(NZ, K4) ::                         &
     &           qcw0, qcw1, qice0, qice1, qsnow0, qsnow1, qgra0, qgra1 &
     &          ,qsnowr0, qsnowr1, qsnowm0, qsnowm1, qgram0, qgram1     &
     &          ,ncw0, ncw1, nice0, nice1, nsnow0, nsnow1, ngra0, ngra1 &
     &          ,nsnowr0, nsnowr1
      REAL, INTENT(INOUT), DIMENSION(NZ) :: ccn0, ccn1, nidep0, nidep1

!
!+---+  LOCAL VARS
!

      REAL, DIMENSION(NZ) :: QL,NL, QICE,NICE, QSNOW,NSNOW, QGRA,NGRA
      REAL*8, DIMENSION(NZ,K4) :: FN_OLD, FQ_OLD, FQSNOWM, FQGRAM
      REAL*8, DIMENSION(K4) :: FN, FQ, FQSM, FQGM

      REAL, DIMENSION(K4,NZ) :: SCR4N, SCR4Q
      REAL, DIMENSION(NZ,K4) :: fo_nw,fo_qw,fo_ni,fo_qi,fo_ns,fo_qs,    &
     &                          fo_ng,fo_qg,fo_nsr,fo_qsr,fo_qsm,fo_qgm
      REAL, DIMENSION(K4,NZ) :: vt_c, vt_i, vt_s, vt_g
      REAL, DIMENSION(NZ) :: sed_n, sed_q

      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     AC,BC,CC,DC, ACI,BCI,CCI,DCI, ACIR,BCIR,CCIR,DCIR,           &
     &     AGRA,BGRA,CGRA,DGRA, MTCIR1,NTCIR1,MTGRA1,NTGRA1,NTC1,MTC1  ! NTC1 and MTC1 were added by IG to avoid the overestimation of drop collection

      INTEGER K, KZ, IPRT, ITC, KSEG, IDELTA1, JUMP, ISTEP, NSTEP, n,   &
     &        nzstep,ksed1,KMIN,KMAX,KMIN1,KMAX1,KMINAE1,KMAXAE1,KTOP,  &
     &        KMINGRA,KMAXGRA,KMINCI,KMAXCI,KMINCIR,KMAXCIR,KS,         &
     &        IBUG0,IBUG01,IBUG1,IBUG2,IBUG3,IBUG4,IBUG5,ISMAX,         &
     &        KSMAX, KK ! xue add KK for shedding

! these variables are used because of the small time step for the graupel - water drop coag.
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,       &
     &     MTGRAMT,NTCT,MTCT
      DOUBLE PRECISION, DIMENSION (K4) :: DNTC8T,DMTC8T,DNTC8ST,DMTC8ST,&
     &    DNTGRA3T,DMTGRA3T,DNTGRA3VT,DMTGRA3VT,DMTGRAM3T
      REAL*8 CONST1T
      REAL*8, DIMENSION(K4) :: FQGMT
      REAL NLT,NGRAT,DTGRWAT,DSNTCI6T

! these variables are added because of the small time step for water drop coag.
      DOUBLE PRECISION, DIMENSION (K4) :: DNTC1T,DMTC1T,DNTC1BT,DMTC1BT
      REAL DTDRP

!.. dummies
      integer ierr1,ierr2,kzerr1,kzerr2

!.. bin production terms
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     DNTC0,DMTC0,DNTC1,DMTC1,DNTC1B,                              &
     &     DMTC1B,DNTC3,DMTC3,DNTC4,DMTC4,                              &
     &     DNTC5,DMTC5,DNTC6,DMTC6,                                     &
     &     DNTC8,DMTC8,DNTC10,DMTC10,                                   &
     &     DNTC8S,DMTC8S,                                               & ! added for collision shedding
     &     DNTCI0,DMTCI0,DNTCI1,DMTCI1,DNTCI3,                          &
     &     DMTCI3,DNTCI4,DMTCI4,DNTCI5,DMTCI5,                          &
     &     DNTCI9,DMTCI9,DNTCI10,DMTCI10,                               &
     &     DNTCI11,DMTCI11,                                             &
     &     DNTCIR1,DMTCIR1,DNTCIR2,DMTCIR2,                             &
     &     DNTCIR2V,DMTCIR2V,DNTCIR4,DMTCIR4,                           &
     &     DNTCIR5,DMTCIR5,DNTCIR6,DMTCIR6,                             &
     &     DNTCIR7,DMTCIR7,DNTCIR8,DMTCIR8,                             &
     &     DNTCIR9,DMTCIR9,                                             &
     &     DNTGRA0,DMTGRA0,DNTGRA2,DMTGRA2,                             &
     &     DNTGRA3,DMTGRA3,DNTGRA3V,DMTGRA3V,                           &
     &     DNTGRA4,DMTGRA4,DNTGRA5,DMTGRA5,                             &
     &     DNTGRA7,DMTGRA7,                                             &
     &     DNTGRA11,DMTGRA11,DNTGRA12,DMTGRA12,                         &
     &     DMTRIME0,DNTRIME0,DMTRIME1,DNTRIME1,                         &
     &     DMTRIME2,DNTRIME2,DMTRIME3,DNTRIME3,                         &
     &     DMTRIME4,DNTRIME4,DMTRIME5,DNTRIME5,                         &
     &     DMTSNOWM0,DMTSNOWM1,DMTSNOWM2,DMTSNOWM3,                     &
     &     DMTSNOWM4,DMTGRAM0,DMTGRAM3,DMTGRAM4,                        &
     &     DMTGRAM5

! xue add for shedding
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     DNTC11,DMTC11,DNTC12,DMTC12,                                 &
     &     DNTCIR10,DMTCIR10,DNTCIR11,DMTCIR11,                         &
     &     DNTGRA13,DMTGRA13,DNTGRA14,DMTGRA14

!.. sum of bin production terms (column in vertical)
      REAL, DIMENSION (NZ) ::                                           &
     &     DSNTC0,DSMTC0,DSNTC1,DSMTC1,DSNTC1B,                         &
     &     DSMTC1B,DSNTC2,DSMTC2,DSNTC3,DSMTC3,DSNTC4,DSMTC4,           & ! N,M2 added
     &     DSNTC5,DSMTC5,DSNTC6,DSMTC6,                                 &
     &     DSNTC8,DSMTC8,DSNTC8S,DSMTC8S,DSMTC9,DSNTC10,DSMTC10,        & ! M9 added
     &     DSNTCI0,DSMTCI0,DSNTCI1,DSMTCI1,DSNTCI2,DSMTCI2,DSNTCI3,     & ! N,M2 added
     &     DSMTCI3,DSNTCI4,DSMTCI4,DSNTCI5,DSMTCI5,DSNTCI6,DSMTCI6,     & ! N,M6 added
     &     DSNTCI9,DSMTCI9,DSNTCI10,DSMTCI10,                           &
     &     DSNTCI11,DSMTCI11,                                           &
     &     DSNTCIR0,DSMTCIR0,DSNTCIR1,DSMTCIR1,DSNTCIR2,DSMTCIR2,       & ! N,M0 added
     &     DSNTCIR2V,DSMTCIR2V,DSNTCIR4,DSMTCIR4,                       &
     &     DSNTCIR5,DSMTCIR5,DSNTCIR6,DSMTCIR6,                         &
     &     DSNTCIR7,DSMTCIR7,DSNTCIR8,DSMTCIR8,                         &
     &     DSNTCIR9,DSMTCIR9,                                           &
     &     DSNTGRA0,DSMTGRA0,DSNTGRA2,DSMTGRA2,                         &
     &     DSNTGRA3,DSMTGRA3,DSNTGRA3V,DSMTGRA3V,                       &
     &     DSNTGRA4,DSMTGRA4,DSNTGRA5,DSMTGRA5,                         &
     &     DSNTGRA7,DSMTGRA7,DSNTGRA10,DSMTGRA10,                       & ! N,M10 added ! diffusional growth
     &     DSNTGRA11,DSMTGRA11,DSNTGRA12,DSMTGRA12,                     &
     &     DSMTRIME0,DSNTRIME0,DSMTRIME1,DSNTRIME1,                     &
     &     DSMTRIME2,DSNTRIME2,DSMTRIME3,DSNTRIME3,                     &
     &     DSMTRIME4,DSNTRIME4,DSMTRIME5,DSNTRIME5,                     &
     &     DSMTSNOWM0,DSMTSNOWM1,DSMTSNOWM2,DSMTSNOWM3,                 &
     &     DSMTSNOWM4,DSMTGRAM0,DSMTGRAM3,DSMTGRAM4,                    &
     &     DSMTGRAM5

! xue add for shedding
      REAL, DIMENSION (NZ) ::                                           &
     &     DSNTC11,DSMTC11,DSNTC12,DSMTC12,                             &
     &     DSNTCIR10,DSMTCIR10,DSNTCIR11,DSMTCIR11,                     &
     &     DSNTGRA13,DSMTGRA13,DSNTGRA14,DSMTGRA14

      REAL RIMPDIFF1(NZ)

!     ntc(i) = concentration of the clear drops in i-th interval     (1/kg)
!     mtc(i) = mixing ratio of the clear drops in i-th interval      (kg/kg)
!     ntci(i) = concentration of the ice crystals in i-th interval     (1/kg)
!     mtci(i) = mixing ratio of the ice crystals in i-th interval      (kg/kg)
!     ntcir(i) = concentration of the snow flake crystals in i-th interval     (1/kg)
!     mtcir(i) = mixing ratio of the snow flake crystals in i-th interval      (kg/kg)
!     mtsnowr(i)= mixing ratio of the rimed water on the surface of the pure ice in i-th interval
!     mtsnown(i)= number concentration of the snow flakes have been collected at least one super cooled drops
!     mtsnowm(i)= mixing ratio of the melted water on surface of the snow flakes
!     mtsnowi(i)= mixing ratio of the solid ice in the melted snow flakes
!     ntgra(i)= number concentration of the graupel particles in the k-th bin
!     mtgra(i)= mixing ratio of the graupel particles in the  k-th bin
!     mtgram(i)= mixing ratio of the melted water on the graupel particles in the k-th bin
!     mtgrai(i)= mixing ratio of the solid ice in the melted graupel in the k-th bin  
!     nicont= concentration of active contact nuclei
!     nidep= concentration of active condensation-freezing and deposition nuclei
!     ccn= concentration of the active condensation nuclei

!     dntc0(i),dmtc0(i)= change of the conc.and mixing r. due to wapor diff. on CCN (aerosol activation)
!     dntc1(i)= change of the concentration due to the self coag.
!     dmtc1(i)= change of the mixing ratio due to the self coag.
!     dntc1b(i)= change of the concentration due to the collision induced break up
!     dmtc1b(i)= change of the mixing ratio due to the collision induced break up
!!!!!     there should be number and mass change due to freezing of droplets.
!     dntc3(i)= change of the concentration due to the collection of aerosol part.(Brownian +phoretic)
!     dmtc3(i)= change of the mixing ratio due to the collection of aerosol part. (Brownian +phoretic)
!     dntc4(i)= change of the concentration due to the collection of aerosol part.(gravitational) contact freezing
!     dmtc4(i)= change of the mixing ratio due to the collection of aerosol part. (gravitational) contact freezing
!     dntc5(i)= decrease of the drop concentration due to the collision with pristine ice
!     dmtc5(i)= decrease of the mixing ratio due to the collision with pristiner ice
!     dntc6(i)= decrease of the drop concentration due to the collision with snow flake
!     dmtc6(i)= decrease of the mixing ratio due to the collision with snow flake 
!     dntc8(i)= change of concentration of drops due to the caogulation of drop and high density graupel p
!     dmtc8(i)=  change of mixing ratio of drops due to the caogulation of drop and high density graupel p.
!     dntc8s(i)= change of concentration of drops  due to collision induced shedding 
!     dmtc8s(i)=  change of mixing ratio of drops due to collision induced shedding 
!     dntc10(i)=change of concentration of drops due to the melting of the ice particles (pristine and rimed ice , aggregates and graupel
!     dmtc10(i)=change of mixing ratio of drops due to the melting of the ice particles
!     dntci0(i)= increase of ice crystal concentration by nucleation of dep. nuclei
!     dmtci0(i)= increase of ice crystal mixing ratio by nucleation of dep. nuclei
!     dntci1(i)= increase of ice crystal concentration by immersional freezing of small drops
!     dmtci1(i)= increase of ice crystal mixing ratio by immersional freezing of small drops
!     dntci3(i)= decrease of ice crystal concentration due to the riming by  drops; snow flakes form
!     dmtci3(i)= decrease of the mixing ratio due to the riming; snow flakes form
!     dntci4(i)= increase of ice crystal concentration due to the contact nucleation of small drops
!     dmtci4(i)= increase of the mixing ratio due to to the contact nucleation of small drops
!     dntci5(i)= decrease of ice crystal concentration due to self collision; snow flake  form
!     dmtci5(i)= change of ice crystal mixing ratio due to self collision;  snow flake form
!     dntci8(i)= decrease of ice crystal concentration due to collision of graupel and pr. ice
!     dmtci8(i)= decrease of the mixing ratio due to collision of graupel and pr. ice
!     dntci9(i)= decrease of ice crystal concentration due to collision snow flake and pr. ice
!     dmtci9(i)= decrease of ice crystal mixing ratio due to collision snow flake and pr. ice
!     dntci10(i)=decrease of ice crystal concentration due to melting
!     dmtci10(i)=decrease of ice crystal  mixing ratio due to melting
!     dntci11(i)= transfer of the small snow flakes and graupel particles to the pristine ice category
!     dmtci11(i)=
!     dntcir1(i)= increase of concentration due to riming of pristine ice
!     dmtcir1(i)= increase of mixing ratio of snow flake crystals due to the riming of pristine ice
!     dntcir2(i)= change of snow flake concentration due to coll.  drops and snow flake cryst.
!     dmtcir2(i)= increase of the mixing ratio of snow flake crystals due to the riming
!     dntcir2v(i)= num. conc. of snow collect one drop and get in to the ith bin
!     dmtcir2v(i)= amount of water collected by snow flakes get into the ith bin
!     dntcir4(i)= decrease of snow flake crystal concentration due to the self coagulation of the snow flake particles
!     dmtcir4(i)= change of the mixing ratio of snow flake crystal due to the self coagulation of the snow flake particles
!     dntcir5(i)= increase of snow flake crystal concentration due to the self coagulation of the pristine ice particles
!     dmtcir5(i)= increase of the mixing ratio of snow flake crystal due to the self coagulation of pristine ice particle
!     dntcir6(i)= decrease of rimed ice crystal concentration due to transfer to graupel (the riming ratio is larger then a given threshold)
!     dmtcir6(i)= decrease of the mixing ratio due to transfer to graupel
!     dntcir7(i)= change of snow flake crystal concentration due to collision snow flake particles and pristine ice
!     dmtcir7(i)= increase of  snow flake mixing ratio due to collision snow flakes and pristine ice
!     dntcir8(i)= complet melting of snow flake crystals
!     dmtcir8(i)= complet melting of snow flake crystals
!     dntcir9(i)= small snow flakes are transfered to the pristine ice category
!     dmtcir9(i)= 
!     dntrime0(i) = change of the number conc. of rimed snow particles due to the diffusional growth
!     dmtrime0(i) = change of the mass of the rimed water due to the diffusional growth
!     dmtsnowm0(i) = change of the mass of the water on the melted snow flakes due to the diffusional growth
!     dmtsnowm1(i) = change of the mass of the water on the melted snow flakes due to the aggregation of the snow flakes
!     dmtsnowm2(i) = change of the mass of the water on the melted snow flakes due to the collision with water drops
!     dmtsnowm3(i) = change of the mass of the water on the melted snow flakes due to the melting
!     dmtsnowm4(i) = transfer of the melted  water due to the complet melting of the snow flakes         
!     dntgra0(i)=immersional freezing of the supercooled drops
!     dmtgra0(i)
!     dntgra1(i)=increase of graupel concentration due to the coagulation of snow flakes and water drops (qw >qwthres)
!     dmtgra1(i)=increase of graupel mixing ratio due to the coagulation of snow flakes and water drops
!     dntgra2(i)=collision of smaller snow flake cryst. and larger drop result in graupel    (if qw is low)
!     dmtgra2(i)= collision of smaller snow flake cryst. and larger drop result in graupel   (if qw is low)
!     dntgra3(i)= graupel - water drop coagulation
!     dmtgra3(i)= graupel - water drop coagulation
!     dntgra3v(i)= number of graupel collected one drop and get into the i-th bin
!     dmtgra3v(i)= amount of water drop collected by the graupel particle and get into the i-th bin
!     dntgra4(i)=increase of frozen drop concentration due to the contact nucleation
!     dmtgra4(i)=increase of frozen drop mixing ratio due to the contact nucleation
!     dntgra5(i)=collision of smaller ice cryst. and larger water drop
!     dmtgra5(i)= collision of smaller ice cryst. and larger water drop
!     dntgra6(i)= collision of smaller snow flakes and larger water drop ( if qw is high)
!     dmtgra6(i)= collision of smaller snow flakes and larger water drop ( if qw is high)
!     dntgra7(i)=increase of graupel concentration due to the transfer from snow flake (riming ratio is larger then a given thershold value (rimthres)
!     dmtgra7(i)=increase of graupel mixing ratio due to the transfer from snow flake
!     dntgra8(i)=increase of graupel concentration due to the coagulation of graupel and pristine ice
!     dmtgra8(i)=increase of graupel mixing ratio due to the coagulation of graupel  and pristine ice
!     dntgra9(i)=increase of graupel concentration due to the coagulation of graupel and snow flake
!     dmtgra9(i)=increase of graupel mixing ratio due to the coagulation of graupel  and snow flake
!     dntgra11(i)= change of the concentration of graupel particles due to the complet melting
!     dmtgra11(i)= change of the mixing ratio of graupel particles due to the complet melting
!     dntgra12(i)= transfer of the small graupel particles in to the pristine ice category
!     dmtgra12(i)= 
!     dmtgram0(i)=change of the mass of the water on the melted graupel due to the diffusional growth
!     dmtgram3(i)=change of the mass of the water on the surface of the graupel particles due to the collison with water drops
!     dmtgram4(i)=change of the mass of the water on the surface of graupel particles due to melting

!.. misc production calculation terms
      DOUBLE PRECISION DN0,DM0,DSNT,DSMT,DSNT2,DSMT2,DSNT0,DSMT0,TK1,   &
     &     QV1,QV11,TK11,DSEGN,DSEGM,DSEGN1,DSEGN2,DSSM1,DSSM2,DSSN1,   &
     &     CORRN,CORRM,VTSNDM,DSNDM,VTWATM,DWATM,VTSNWM,DSNWM,FQMSVT,   &
     &     VTSNOWFQ,CORR
      REAL DHIBAN,CCN,CCN11,CCNM,NIDEPM,MDROPM,MSNOWM,DNID1,FP,RIMCN,   &
     &     SHED,GRAN,MEANMSWM,MEANMSM,MEANMGWM,MEANMGM ! xue add for shedding
      real fqs_melt, fsvt, prcp

!.. VARIABLES USED TO CHECK OF THE MASS CONSERVATION DURING THE DIFFUSIONAL GROWTH
      REAL ERRCOND,SCOND,ERRDEP,SDEP,ERRDEP1,SDEP1

!.. COALLESCENCE EFFICIENCIES 
      REAL ERICIC,EICIC,ERICRIC,EWRIC
!.. dummies
      real*8 errseg0,errseggr,errseggr1,errseggr2,errseggr3,            &
     &     errseggr4,errseggr5,errseggr6,errseggr7,errseggr8,           &
     &     errseggr9,errseggr10,errseggr11,errseggr12

!.. Various thermodynamic variables
      REAL, DIMENSION (NZ) :: LV2, LF2, KG2, VISC2, DIFF2, SATW

      REAL DMEAN,MMEAN,TK,TKE1,P,QVE1,TKM,QVM,VISC,LV,LF,LD,KG,DIFF,    &
     &     TCC,GAMMA,EWS,QWS,EWS1,QWS1,SAT1,ROA,ROA1,TK2,QV2,EWS2,QWS2, &
     &     SAT2,TENTEMP,TENQV,TTEN1,QVTEN1,TENCCN,TENDEP,               &
     &     TOTALN,TOTALN1,SATWMEAN,SATWMAX,SUPSATMIN,SUPSATMAX,TIMES,   &
     &     QWSMAX,EWSMAX,PSMAX,EPSC1,EPSC2,SATS2,QMELT1,QMELT2,QFREEZ,  &
     &     FQ1,FN1,DSMTC6MAX,RIMPDIFF1MAX,RIMPDIFF2MAX,                 &
     &     DELTAV0,DELTAV,DELTAV1
      REAL EIS, SATS3 !,SATS
      real*8 CONST1,CONST11
      real*8 DQSHC, DQGRHC, DQHLHC

      INTEGER KZRDF1,KZRDF2
!+---+

! xue add for shedding
      MEANMSWM=M(1)
      MEANMSM=M(1)
      MEANMGWM=M(1)
      MEANMGM=M(1)

      kpt = 0
      ERICIC = 0.0
      EICIC = 0.0
      ERICRIC = 0.0
      EWRIC = 1. !0.5 !increase for snow water collection efficiency
      DNID1 = 0.0

      SATWMAX =0.0
      QWSMAX=0.0
      EWSMAX =0.0
      PSMAX =0.0
      KSMAX =0
      DO 10 KZ=1,NZ
!        EWS=EXP((23.684*tz_old(KZ)-4947.34)/(tz_old(KZ)-35.86))
        EWS=EXP(53.67957-6743.769/tz_old(kz)-4.8451*log(tz_old(kz)))*100.
        QWS=0.622*EWS/pz(KZ)
        SATW(KZ)=QV_old(KZ)/QWS
        IF (SATW(KZ).GT.SATWMAX) THEN
         SATWMAX = SATW(KZ)
         KSMAX = KZ
         EWSMAX = EWS
         QWSMAX = QWS
         PSMAX = pz(KZ)
        ENDIF
        TK=tz_old(KZ)
        TCC=TK-T00
        GAMMA=.167+3.67e-4*TK
        LV2(KZ)=4186.*597.3*(T00/TK)**GAMMA                              ! latent heat of condensation
        IF(TK.LT.T00) THEN
         LF2(KZ)=4186.*(79.7 + 0.488*TCC - 2.5e-3*TCC*TCC)               ! latent heat of fusion
        ELSE
         LF2(KZ)= LF0
        ENDIF
        KG2(KZ)=418.6*(5.69+0.017*TCC)*1e-5                              ! heat conductivity of the air
        DIFF2(KZ)=2.11e-5*(TK/T00)**1.94*(P00/pz(KZ))                    ! diffusion coef
        IF (TK.GT.T00) THEN
          VISC2(KZ)=(1.718+4.9e-3*TCC)*1e-5                              ! viscosity of the air
        ELSE
          VISC2(KZ)=(1.718+4.9e-3*TCC-1.2e-5*TCC*TCC)*1e-5
        ENDIF
 10   CONTINUE

!      if (ksmax.gt.0) then
!      WRITE (mp_debug,*) ' sat max, P(mb), T(C), and Qv(g/kg) at ',     &
!             ipt,jpt,ksmax,satwmax,pz(ksmax)*0.01,tz(ksmax)-T00,qv(ksmax)*1000
!      CALL wrf_debug(150, mp_debug)
!      endif

!.. Initialize diagnostic fractions
      DO 40 KZ=1,NZ
        DSMTC9(KZ)=0.0
        QL(KZ)=0.0
        NL(KZ)=0.0
        QICE(KZ)=0.0
        NICE(KZ)=0.0
        QSNOW(KZ)=0.0
        NSNOW(KZ)=0.0
        QGRA(KZ) = 0.0
        NGRA(KZ) = 0.0
        DO 60 K =1,K4
          QL(KZ) = QL(KZ)+QCW0(KZ,K)
          NL(KZ) = NL(KZ)+NCW0(KZ,K)
          QICE(KZ) = QICE(KZ)+QICE0(KZ,K)
          NICE(KZ) = NICE(KZ)+NICE0(KZ,K)
          QSNOW(KZ) = QSNOW(KZ)+QSNOW0(KZ,K)
          NSNOW(KZ) = NSNOW(KZ)+NSNOW0(KZ,K)
          QGRA(KZ) = QGRA(KZ)+QGRA0(KZ,K)
          NGRA(KZ) = NGRA(KZ)+NGRA0(KZ,K)
          FN_OLD(KZ,K) = 0.0
          FQ_OLD(KZ,K) = 0.0
          FQSNOWM(KZ,K) = 0.0
          FQGRAM(KZ,K) = 0.0
          IF (tz_old(KZ).LE.T00) THEN
            IF (NSNOWR0(KZ,K) .GT. NSNOW0(KZ,K)) THEN
              NSNOWR0(KZ,K) = NSNOW0(KZ,K)
            ENDIF
            IF (NSNOW0(KZ,K).GT.0.0) THEN
              FN_OLD(KZ,K) = NSNOWR0(KZ,K)/NSNOW0(KZ,K)
            ENDIF
            IF (QSNOWR0(KZ,K) .GT. QSNOW0(KZ,K)) THEN
              QSNOWR0(KZ,K) = QSNOW0(KZ,K)
            ENDIF
            IF (QSNOW0(KZ,K).GT.0.0) THEN
              FQ_OLD(KZ,K) = QSNOWR0(KZ,K)/QSNOW0(KZ,K)
            ENDIF
            DSMTC9(KZ)=DSMTC9(KZ) + (QSNOWM0(KZ,K) + QGRAM0(KZ,K))/DT
            QSNOWM0(KZ,K) = 0.0
            QGRAM0(KZ,K) = 0.0
          ELSE
            NSNOWR0(KZ,K)=0.0
            QSNOWR0(KZ,K)=0.0
            IF (QSNOWM0(KZ,K) .GT. QSNOW0(KZ,K)) THEN
              QSNOWM0(KZ,K) = QSNOW0(KZ,K)
            ENDIF
            IF (QSNOW0(KZ,K).GT.0.0) THEN
              FQSNOWM(KZ,K)=MAX(0.0, MIN(QSNOWM0(KZ,K)/QSNOW0(KZ,K), 1.0))
            ENDIF
            IF (QGRAM0(KZ,K) .GT. QGRA0(KZ,K)) THEN
              QGRAM0(KZ,K) = QGRA0(KZ,K)
            ENDIF
            IF (QGRA0(KZ,K).GT.0.0) THEN
              FQGRAM(KZ,K)=MAX(0.0, MIN(QGRAM0(KZ,K)/QGRA0(KZ,K), 1.0))
            ENDIF
          ENDIF
 60     CONTINUE
 40   CONTINUE

!.. Initialize all tendencies to zero
      DO 70 K=1,NZ
        DSNTC0(K)=0.0
        DSNTC1(K)=0.0
        DSNTC1B(K)=0.0
        DSNTC2(K)=0.0
        DSNTC3(K)=0.0
        DSNTC4(K)=0.0
        DSNTC5(K)=0.0
        DSNTC6(K)=0.0
        DSNTC8(K)=0.0
        DSNTC8S(K)=0.0
        DSNTC10(K)=0.0
        DSMTC0(K)=0.0
        DSMTC1(K)=0.0
        DSMTC1B(K)=0.0
        DSMTC2(K)=0.0
        DSMTC3(K)=0.0
        DSMTC4(K)=0.0
        DSMTC5(K)=0.0
        DSMTC6(K)=0.0
        DSMTC8(K)=0.0
        DSMTC8S(K)=0.0
        DSMTC10(K)=0.0
        DSNTCI0(K)=0.0
        DSNTCI1(K)=0.0
        DSNTCI2(K)=0.0            
        DSNTCI3(K)=0.0
        DSNTCI4(K)=0.0
        DSNTCI5(K)=0.0
        DSNTCI6(K)=0.0
        DSNTCI9(K)=0.0
        DSNTCI10(K)=0.0
        DSNTCI11(K)=0.0
        DSMTCI0(K)=0.0
        DSMTCI1(K)=0.0
        DSMTCI2(K)=0.0
        DSMTCI3(K)=0.0
        DSMTCI4(K)=0.0
        DSMTCI5(K)=0.0
        DSMTCI6(K)=0.0
        DSMTCI9(K)=0.0
        DSMTCI10(K)=0.0
        DSMTCI11(K)=0.0
        DSNTCIR0(K)=0.0
        DSNTCIR1(K)=0.0
        DSNTCIR2(K)=0.0
        DSNTCIR2V(K)=0.0
        DSNTCIR4(K)=0.0
        DSNTCIR5(K)=0.0
        DSNTCIR6(K)=0.0
        DSNTCIR7(K)=0.0
        DSNTCIR8(K)=0.0
        DSNTCIR9(K)=0.0
        DSMTCIR0(K)=0.0
        DSMTCIR1(K)=0.0
        DSMTCIR2(K)=0.0
        DSMTCIR2V(K)=0.0
        DSMTCIR4(K)=0.0
        DSMTCIR5(K)=0.0
        DSMTCIR6(K)=0.0
        DSMTCIR7(K)=0.0
        DSMTCIR8(K)=0.0
        DSMTCIR9(K)=0.0
        DSNTGRA0(K)=0.0
        DSNTGRA2(K)=0.0
        DSNTGRA3(K)=0.0
        DSNTGRA3V(K)=0.0
        DSNTGRA4(K)=0.0
        DSNTGRA5(K)=0.0
        DSNTGRA7(K)=0.0
        DSNTGRA10(K)=0.0
        DSNTGRA11(K)=0.0
        DSNTGRA12(K)=0.0
        DSMTGRA0(K)=0.0
        DSMTGRA2(K)=0.0
        DSMTGRA3(K)=0.0
        DSMTGRA3V(K)=0.0
        DSMTGRA4(K)=0.0
        DSMTGRA5(K)=0.0
        DSMTGRA7(K)=0.0
        DSMTGRA10(K)=0.0
        DSMTGRA11(K)=0.0
        DSMTGRA12(K)=0.0
        DSNTRIME0(K)=0.0
        DSNTRIME1(K)=0.0
        DSNTRIME2(K)=0.0
        DSNTRIME3(K)=0.0
        DSNTRIME4(K)=0.0
        DSNTRIME5(K)=0.0
        DSMTRIME0(K)=0.0
        DSMTRIME1(K)=0.0
        DSMTRIME2(K)=0.0
        DSMTRIME3(K)=0.0
        DSMTRIME4(K)=0.0
        DSMTRIME5(K)=0.0
        DSMTSNOWM0(K)=0.0
        DSMTSNOWM1(K)=0.0
        DSMTSNOWM2(K)=0.0
        DSMTSNOWM3(K)=0.0
        DSMTSNOWM4(K)=0.0
        DSMTGRAM0(K)=0.0
        DSMTGRAM3(K)=0.0
        DSMTGRAM4(K)=0.0
        DSMTGRAM5(K)=0.0
        RIMPDIFF1(K)=0.0
! xue add for shedding
        DSNTC11(K)=0.0
        DSMTC11(K)=0.0
        DSNTC12(K)=0.0
        DSMTC12(K)=0.0
        DSNTCIR10(K)=0.0
        DSMTCIR10(K)=0.0
        DSNTCIR11(K)=0.0
        DSMTCIR11(K)=0.0
        DSNTGRA13(K)=0.0
        DSMTGRA13(K)=0.0
        DSNTGRA14(K)=0.0
        DSMTGRA14(K)=0.0
 70   CONTINUE

! initialize conversion rates in vertical
      DO KZ=1,NZ
        DNWZ_ACTV(KZ) =0.
        DNWZ_COAG(KZ) =0.
        DNWZ_BRUP(KZ) =0.
        DNIZ_COLL(KZ) =0.
        DMWZ_DIFF(KZ) =0.
        DMWZ_FRML(KZ) =0.
        DMIZ_DIFF(KZ) =0.
        DMWIZ_MELT(KZ)=0.
        DMWIZ_DIFF(KZ)=0.
        DMWZ_RIME(KZ) =0.
        DNWZ_SHED(KZ) =0.
        DMGZ_RIME(KZ) =0.
      ENDDO


!+---+-----------------------------------------------------------------+

!.. Sedimentation.  First find highest level with any mixing ratio and
!.. do not bother to perform calculations above this level. Start with
!.. liquid droplets, then remaining hydrometeors.  Using scratch arrays
!.. for minor efficiency improvements.

      WRITE (mp_debug,*) ' DEBUG:  sedim of water drops'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, ncw0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qcw0(KZ,K))
         vt_c(k,kz) = vtc(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_c, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptrain = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_nw(KZ,K) = SCR4N(K,KZ) - ncw0(KZ,K)
         fo_qw(KZ,K) = SCR4Q(K,KZ) - qcw0(KZ,K)
        ENDDO
      ENDDO

      
!+---+-----------------------------------------------------------------+

!.. Next is cloud ice

      WRITE (mp_debug,*) ' DEBUG:  sedim of cloud ice'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nice0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qice0(KZ,K))
         vt_i(k,kz) = vtci(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_i, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptice = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ni(KZ,K) = SCR4N(K,KZ) - nice0(KZ,K)
         fo_qi(KZ,K) = SCR4Q(K,KZ) - qice0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is snow.  Special terminal velocity of melting snow.

      WRITE (mp_debug,*) ' DEBUG:  sedim of snow'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nsnow0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qsnow0(KZ,K))
         if (qsnow0(kz,k).gt.0.0 .and. qsnowm0(kz,k).gt.0.0) then
            fqs_melt = max(0., min(qsnowm0(kz,k)/qsnow0(kz,k), 1.))
            fsvt = 0.01195*EXP(4.411*fqs_melt)
            vt_s(k,kz) = fsvt*VTC(k)+(1.0 - FSVT)*VTCIR(k)
         else
            vt_s(k,kz) = vtcir(k)
         endif
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptsnow = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ns(KZ,K) = SCR4N(K,KZ) - nsnow0(KZ,K)
         fo_qs(KZ,K) = SCR4Q(K,KZ) - qsnow0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is rime on snow amount

      WRITE (mp_debug,*) ' DEBUG:  sedim of rimed snow'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nsnowr0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qsnowr0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
!.. We do not add prcp to snow because the qsnow1 variable already
!.. includes both masses.  However, we need proper accouting for rime
!.. amount to pass back into the WRF moist array.
!     pptsnow = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_nsr(KZ,K) = SCR4N(K,KZ) - nsnowr0(KZ,K)
         fo_qsr(KZ,K) = SCR4Q(K,KZ) - qsnowr0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is graupel

      WRITE (mp_debug,*) ' DEBUG:  sedim of graupel'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, ngra0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qgra0(KZ,K))
         vt_g(k,kz) = vtgra(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_g, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptgra = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ng(KZ,K) = SCR4N(K,KZ) - ngra0(KZ,K)
         fo_qg(KZ,K) = SCR4Q(K,KZ) - qgra0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is meltwater on snow; mass var only, number will be ignored.

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = 0.0
         SCR4Q(K,KZ) = AMAX1(0.0, qsnowm0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptsnowm = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_qsm(KZ,K) = SCR4Q(K,KZ) - qsnowm0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is meltwater on graupel; mass var only, number will be ignored.

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = 0.0
         SCR4Q(K,KZ) = AMAX1(0.0, qgram0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_g, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptgram = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_qgm(KZ,K) = SCR4Q(K,KZ) - qgram0(KZ,K)
        ENDDO
      ENDDO


!..END SEDIMENTATION
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

!.. Start of calculations for microphysics
      IDELTA1=1 
      TIMES = IST*DT
      supsatmin=10.0
      supsatmax=0.0
      DO 100 KZ=1,NZ
        TENTEMP = (tz(kz) - tz_old(kz))/DT
        TENQV = (qv(kz) - qv_old(kz))/DT
        DQSHC = 0.0
        DQGRHC = 0.0
        DQHLHC = 0.0
        ERICIC = 0.0
        EICIC = 0.0
        ERICRIC = 0.0
        EWRIC = 1. !0.5
        DNID1 = 0.0
        FP = 0.0
!        IF (TK > T00) THEN 
        IF (TZ_OLD(KZ) > T00) THEN
          IDELTA1=0
        ELSE
          IDELTA1=1
        ENDIF

        DO K=1,K4  
! use combination of pre and after advection values
!         NCW0(KZ,K)=NCW0(KZ,K)*0.5+NCW1(KZ,K)*0.5
!         QCW0(KZ,K)=QCW0(KZ,K)*0.5+QCW1(KZ,K)*0.5
!         NICE0(KZ,K)=NICE0(KZ,K)*0.5+NICE1(KZ,K)*0.5
!         QICE0(KZ,K)=QICE0(KZ,K)*0.5+QICE1(KZ,K)*0.5
!         NSNOW0(KZ,K)=NSNOW0(KZ,K)*0.5+NSNOW1(KZ,K)*0.5
!         QSNOW0(KZ,K)=QSNOW0(KZ,K)*0.5+QSNOW1(KZ,K)*0.5
!         NSNOWR0(KZ,K)=NSNOWR0(KZ,K)*0.5+NSNOWR1(KZ,K)*0.5
!         QSNOWR0(KZ,K)=QSNOWR0(KZ,K)*0.5+QSNOWR1(KZ,K)*0.5
!         QSNOWM0(KZ,K)=QSNOWM0(KZ,K)*0.5+QSNOWM1(KZ,K)*0.5
!         NGRA0(KZ,K)=NGRA0(KZ,K)*0.5+NGRA1(KZ,K)*0.5
!         QGRA0(KZ,K)=QGRA0(KZ,K)*0.5+QGRA1(KZ,K)*0.5
!         QGRAM0(KZ,K)=QGRAM0(KZ,K)*0.5+QGRAM1(KZ,K)*0.5
!         NCW0(KZ,K)=NCW0(KZ,K)*0.+NCW1(KZ,K)*1.
!         QCW0(KZ,K)=QCW0(KZ,K)*0.+QCW1(KZ,K)*1.
!         NICE0(KZ,K)=NICE0(KZ,K)*0.+NICE1(KZ,K)*1.
!         QICE0(KZ,K)=QICE0(KZ,K)*0.+QICE1(KZ,K)*1.
!         NSNOW0(KZ,K)=NSNOW0(KZ,K)*0.+NSNOW1(KZ,K)*1.
!         QSNOW0(KZ,K)=QSNOW0(KZ,K)*0.+QSNOW1(KZ,K)*1.
!         NSNOWR0(KZ,K)=NSNOWR0(KZ,K)*0.+NSNOWR1(KZ,K)*1.
!         QSNOWR0(KZ,K)=QSNOWR0(KZ,K)*0.+QSNOWR1(KZ,K)*1.
!         QSNOWM0(KZ,K)=QSNOWM0(KZ,K)*0.+QSNOWM1(KZ,K)*1.
!         NGRA0(KZ,K)=NGRA0(KZ,K)*0.+NGRA1(KZ,K)*1.
!         QGRA0(KZ,K)=QGRA0(KZ,K)*0.+QGRA1(KZ,K)*1.
!         QGRAM0(KZ,K)=QGRAM0(KZ,K)*0.+QGRAM1(KZ,K)*1.
         NTC(K) = DBLE(NCW0(KZ,K))
         MTC(K) = DBLE(QCW0(KZ,K))
         NTCI(K) = DBLE(NICE0(KZ,K))
         MTCI(K) = DBLE(QICE0(KZ,K))
         NTCIR(K) = DBLE(NSNOW0(KZ,K))
         MTCIR(K) = DBLE(QSNOW0(KZ,K))
! these variables bellow are used to controll the diff. growth in subroutine cond. 
!         NTC1(K) = DBLE(NCW1(KZ,K))
!         MTC1(K) = DBLE(QCW1(KZ,K))
!         NTCI1(K) = DBLE(NICE1(KZ,K))
!         MTCI1(K) = DBLE(QICE1(KZ,K))
!         NTCIR1(K) = DBLE(NSNOW1(KZ,K))
!         MTCIR1(K) = DBLE(QSNOW1(KZ,K))

         NTSNOWR(K) =DBLE(NSNOWR0(KZ,K))
         MTSNOWR(K) =DBLE(QSNOWR0(KZ,K))
         MTSNOWM(K) = DBLE(QSNOWM0(KZ,K))
         NTGRA(K) = DBLE(NGRA0(KZ,K))
         MTGRA(K) = DBLE(QGRA0(KZ,K))
         MTGRAM(K) = DBLE(QGRAM0(KZ,K))
! update the fraction after mean advection values are calculated
!         IF (NTCIR(K).GT.0.0) THEN
!           FN(K) = MAX(0.0,MIN(NTSNOWR(K)/NTCIR(K),1.0))
!         ELSE
!           FN(K)=0.0
!         ENDIF
!         IF (MTCIR(K).GT.0.0) THEN
!           FQ(K) = MAX(0.0,MIN(MTSNOWR(K)/MTCIR(K),1.0))
!         ELSE
!           FQ(K)=0.0
!         ENDIF
!         IF (MTCIR(K).GT.0.0) THEN
!           FQSM(K)=MAX(0.0, MIN(MTSNOWM(K)/MTCIR(K), 1.0))
!         ELSE
!           FQSM(K)=0.0
!         ENDIF
!         IF (MTGRA(K).GT.0.0) THEN
!           FQGM(K)=MAX(0.0, MIN(MTGRAM(K)/MTGRA(K),1.0))
!         ELSE
!           FQGM(K)=0.0
!         ENDIF
         FN(K) = FN_OLD(KZ,K)
         FQ(K) = FQ_OLD(KZ,K)
         FQSM(K) = FQSNOWM(KZ,K)
         FQGM(K) = FQGRAM(KZ,K)

         DNTC0(K)=0.0
         DMTC0(K)=0.0
         DNTC1(K)=0.0
         DMTC1(K)=0.0
         DNTC1B(K)=0.0
         DMTC1B(K)=0.0
         DNTC3(K)=0.0
         DMTC3(K)=0.0
         DNTC4(K)=0.0
         DMTC4(K)=0.0
         DNTC5(K)=0.0
         DMTC5(K)=0.0
         DNTC6(K)=0.0
         DMTC6(K)=0.0
         DNTC8(K)=0.0
         DMTC8(K)=0.0
         DNTC8S(K)=0.0   ! collision shedding
         DMTC8S(K)=0.0   ! collision shedding
         DNTC10(K)=0.0
         DMTC10(K)=0.0
         DNTCI0(K)=0.0
         DMTCI0(K)=0.0
         DNTCI1(K)=0.0
         DMTCI1(K)=0.0
         DNTCI3(K)=0.0
         DMTCI3(K)=0.0
         DNTCI4(K)=0.0
         DMTCI4(K)=0.0
         DNTCI5(K)=0.0
         DMTCI5(K)=0.0
         DNTCI9(K)=0.0
         DMTCI9(K)=0.0
         DNTCI10(K)=0.0
         DMTCI10(K)=0.0
         DNTCI11(K)=0.0
         DMTCI11(K)=0.0
         DNTCIR1(K)=0.0
         DMTCIR1(K)=0.0
         DNTCIR2(K)=0.0
         DMTCIR2(K)=0.0
         DNTCIR2V(K)=0.0
         DMTCIR2V(K)=0.0
         DNTCIR4(K)=0.0
         DMTCIR4(K)=0.0
         DNTCIR5(K)=0.0
         DMTCIR5(K)=0.0
         DNTCIR6(K)=0.0
         DMTCIR6(K)=0.0
         DNTCIR7(K)=0.0
         DMTCIR7(K)=0.0
         DNTCIR8(K)=0.0
         DMTCIR8(K)=0.0
         DNTCIR9(K)=0.0
         DMTCIR9(K)=0.0
         DNTGRA0(K)=0.0
         DMTGRA0(K)=0.0
         DNTGRA2(K)=0.0
         DMTGRA2(K)=0.0
         DNTGRA3(K)=0.0
         DMTGRA3(K)=0.0
         DNTGRA3V(K)=0.0
         DMTGRA3V(K)=0.0
         DNTGRA4(K)=0.0
         DMTGRA4(K)=0.0
         DNTGRA5(K)=0.0
         DMTGRA5(K)=0.0
         DNTGRA7(K)=0.0
         DMTGRA7(K)=0.0
         DNTGRA11(K)=0.0
         DMTGRA11(K)=0.0
         DNTGRA12(K)=0.0
         DMTGRA12(K)=0.0
         DMTRIME0(K)=0.0
         DNTRIME0(K)=0.0
         DMTRIME1(K)=0.0
         DNTRIME1(K)=0.0
         DMTRIME2(K)=0.0
         DNTRIME2(K)=0.0
         DMTRIME3(K)=0.0
         DNTRIME3(K)=0.0
         DMTRIME4(K)=0.0
         DNTRIME4(K)=0.0
         DMTRIME5(K)=0.0
         DNTRIME5(K)=0.0
         DMTSNOWM0(K)=0.0
         DMTSNOWM1(K)=0.0
         DMTSNOWM2(K)=0.0
         DMTSNOWM3(K)=0.0
         DMTSNOWM4(K)=0.0
         DMTGRAM0(K)=0.0
         DMTGRAM3(K)=0.0
         DMTGRAM4(K)=0.0
         DMTGRAM5(K)=0.0
! xue add for shedding
         DNTC11(K)=0.0
         DMTC11(K)=0.0
         DNTC12(K)=0.0
         DMTC12(K)=0.0
         DNTCIR10(K)=0.0
         DMTCIR10(K)=0.0
         DNTCIR11(K)=0.0
         DMTCIR11(K)=0.0
         DNTGRA13(K)=0.0
         DMTGRA13(K)=0.0
         DNTGRA14(K)=0.0
         DMTGRA14(K)=0.0
        ENDDO

        ibug0=0
        ibug01=0
        ibug1=0
        ibug2=0
        ibug3=0
        ibug4=0
        ibug5=0
        
        if (TIMES.ge.815.and.TIMES.le.818) then
          if (ii.eq.302.and.kz.eq.14) then
!             ibug5=1
          endif
        endif

        kpt = KZ
        if (ibug5.eq.1) then
        write(95,*) 'mixing ratios and conc. before micro time',times
        write(95,*) 'at x: ',ii
        write(95,*) 'kz,k,ntc,mtc'
        do k = 1,k4
         write(95,*) kz,k,ntc(k),mtc(k)
        enddo
        write(95,*) 'qv,qvold,tz,tz_old',qv(kz),qv_old(kz),tz(kz),tz_old(kz)
        write(95,*) 'dt',dt
        write(95,*) 'tenqv,tentemp',tenqv,TENTEMP
        endif
 
        ROA = RHOA(KZ)
        ROA1 = SQRT(ROA0/ROA)
        CONST1 = DBLE (ROA1*DT)
        TK1 = DBLE(tz_old(KZ))
        QV1 = DBLE(qv_old(KZ))
        TKE1 = TK1
        QVE1 = QV1
        TK11 = TK1
        QV11 = QV1
        CCN = CCN0(KZ)
        P = pz(KZ)
        VISC = VISC2(KZ)
        LV = LV2(KZ)
        LF = LF2(KZ)
        IF (tz_old(KZ).LT.T00) THEN
         LD = LF + LV
        ELSE
         LD = LV
        ENDIF
        KG = KG2(KZ)
        DIFF = DIFF2(KZ)
        VISC = VISC2(KZ)
        TK2 = tz(kz)
        QV2 = qv(kz)
!        EWS2 = EXP((23.684*TK2-4947.34)/(TK2-35.86))
        EWS2=EXP(53.67957-6743.769/tk2-4.8451*log(tk2))*100.
        QWS2 = 0.622*EWS2/P
        SATS2 = QV2/QWS2
!        EIS = EXP((28.2890*TK2-6024.330)/(TK2-7.660))
        EIS = EXP(23.33086-6111.72784/tk2+0.15215*log(tk2))*100.
!        SATS3 = QV2*P/(0.622+QV2) / EIS
        SATS3 = QV2*P/0.622/EIS

       if (ibug0.eq.1) then
         write(98,*) 'before call coef1 ist,kz,ii,jj',ist,kz,ii,jj
         write(98,*) 'temp,qv,sats2,sats3',tz_old(KZ),qv_old(KZ),sats2,sats3
         write(98,*) 'tk1,tk2,qv1,qv2',tk1,tk2,qv1,qv2
         write(98,*) 'water size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntc(k),mtc(k)
         enddo
         write(98,*) 'snow size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntcir(k),mtcir(k),fqsm(k),fn(k),fq(k)
         enddo
         write(98,*) 'graupel size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntgra(k),mtgra(k),fqgm(k)
         enddo
       endif

        TTEN1=TENTEMP
        QVTEN1=TENQV
        TENCCN = (CCN1(KZ) - CCN0(KZ))/DT
        TENDEP = (NIDEP1(KZ)- NIDEP0(KZ))/DT
        TOTALN1 = AMAX1(NL(KZ),0.0) + AMAX1(NICE(KZ),0.0) +             &
     &           AMAX1(NSNOW(KZ),0.0)
        TOTALN = TOTALN1+ AMAX1(NGRA(KZ),0.0)
!..Original code checked for water saturation.  In this case, no ice would form
!.. unless it was also water saturated.  Now, we check for ice supersaturation,
!.. so that subroutine DEPACT can decide if ice forms in less than water saturated.
! xue add SATS2 < 1 to make sure water will be generated in warm region
        IF (TOTALN < EPS .AND. SATS3 < 1.0 .AND. SATS2 < 1.0) THEN ! no particles and they will not form at at this point
          CCN1(KZ) = CCN0(KZ) + TENCCN*DT
          NIDEP1(KZ) = NIDEP0(KZ) + TENDEP*DT
!          write(*,*)'no microphysics is called: sat2,sats3 at i,j,k',sats2,sats3,ii,jj,kz
          GOTO 121
        ENDIF

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for water drops'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,AC,BC,CC,DC,MTC,NTC,KMIN,KMAX,NL(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for graupel'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,AGRA,BGRA,CGRA,DGRA,MTGRA,NTGRA,KMINGRA,KMAXGRA,  &
     &           NGRA(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for cloud ice'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,ACI,BCI,CCI,DCI,MTCI,NTCI,KMINCI,KMAXCI,          &
     &           NICE(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for snow'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,ACIR,BCIR,CCIR,DCIR,MTCIR,NTCIR,KMINCIR,KMAXCIR,  &
     &           NSNOW(KZ))

        KTOP=0
        IF (tz_old(KZ) .GT. T00) THEN
!     calculation of the mass weighted mean terminal velocity and mass weighted mean diameter of the
!     water drops, dry snow flakes and wet snow flakes
!     these paramers are used for the correction of  wet snow - water drop collison because the kernels are calculated 
!     for  dry snow - water drop the collison 
         DSSM1=0.0
         DSSM2=0.0
!     mean values for dry snow
         DO 130 K = 1, K4 
           MMEAN=0.0
           IF (NTCIR(K) .LE. 0.0) GOTO 130
           MMEAN=MTCIR(K)/NTCIR(K)
           IF (MMEAN > M(K+1)) MMEAN = M(K+1)
           IF (MMEAN < M(K)) MMEAN = M(K)
           IF (MMEAN.LE.MSNOW100) THEN
            RSNOW=RSNOW0
            ROSNOW=ROSNOW0
            DMEAN=16.28*SQRT(MMEAN)
           ENDIF
           IF (MMEAN.GE.MSNOW500) THEN
             RSNOW=RSNOW1
             DMEAN=SQRT(6.*MMEAN/PI/0.17)
             rosnow = 0.17/DMEAN
             if (rosnow .lt. 20.0) then
                rosnow=20.0
                DMEAN = (6.0*MMEAN/3.14159/rsnow/rosnow)**0.33333333
             endif
           ENDIF
           IF (MMEAN.GT.MSNOW100.AND.MMEAN.LT.MSNOW500) THEN
             A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
             B1=RSNOW1-A1*ALOG10(MSNOW500)
             A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
             B2=ROSNOW1-A2*ALOG10(MSNOW500)
             RSNOW=A1*ALOG10(MMEAN)+B1
             ROSNOW=A2*ALOG10(MMEAN)+B2
             DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333
           ENDIF
           DSSM1=DSSM1+MTCIR(K)*DMEAN
           DSSM2=DSSM2+MTCIR(K)*VTCIR(K)
 130     CONTINUE
         IF (QSNOW(KZ) .GT. 0.0) THEN
           DSNDM=DSSM1/QSNOW(KZ)
           VTSNDM=DSSM2/QSNOW(KZ)
         ENDIF   
         DSSM1=0.0
         DSSM2=0.0
!     mean values for wet snow
         DO 135 K = 1, K4  
          MMEAN=0.0
          IF (NTCIR(K) <= 0.0) GOTO 135
          MMEAN=MTCIR(K)/NTCIR(K)
          IF (MMEAN > M(K+1)) MMEAN = M(K+1)
          IF (MMEAN < M(K)) MMEAN = M(K)
          IF (MMEAN.LE.MSNOW100) THEN
           RSNOW=RSNOW0
           ROSNOW=ROSNOW0
           DMEAN=16.28*SQRT(MMEAN)
          ENDIF
          IF (MMEAN.GE.MSNOW500) THEN
            RSNOW=RSNOW1
            ROSNOW=0.17/SQRT(6*MMEAN/Pi/0.17)
            if (rosnow .lt. 20.0) rosnow=20.0
          ENDIF
          IF (M(K).GT.MSNOW100.AND.M(K).LT.MSNOW500) THEN
            A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
            B1=RSNOW1-A1*ALOG10(MSNOW500)
            A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
            B2=ROSNOW1-A2*ALOG10(MSNOW500)
            RSNOW=A1*ALOG10(MMEAN)+B1
            ROSNOW=A2*ALOG10(MMEAN)+B2        
          ENDIF
          RSNOW=FQSM(K) + (1-FQSM(K))*RSNOW
          ROSNOW = FQSM(K)*1000 + (1-FQSM(K))*ROSNOW 
          DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333 
          DSSM1=DSSM1+MTCIR(K)*DMEAN
          FQMSVT=0.01195*exp(4.411*FQSM(K))  
          VTSNOWFQ=FQMSVT*VTC(K)+(1 - FQMSVT)*VTCIR(K)       
          DSSM2=DSSM2+MTCIR(K)*VTSNOWFQ
 135     CONTINUE
         IF (QSNOW(KZ) .GT. 0.0) THEN
           DSNWM=DSSM1/QSNOW(KZ)
           VTSNWM=DSSM2/QSNOW(KZ)
         ENDIF
!     mean values for water drops
         DSSM1=0.0
         DSSM2=0.0
         DO 140 K = 1, K4 
           MMEAN=0.0
           IF (NTC(K).LE.0.0) GOTO 140
           MMEAN=MTC(K)/NTC(K)
           IF (MMEAN > M(K+1)) MMEAN = M(K+1)
           IF (MMEAN < M(K)) MMEAN = M(K)
           DSSM1=DSSM1+MTC(K)*(6*MMEAN/PI/1000.)**0.3333 
           DSSM2=DSSM2+MTC(K)*VTC(K)
 140     CONTINUE
         IF (QL(KZ) .GT. 0.0) THEN
           DWATM=DSSM1/QL(KZ)
           VTWATM=DSSM2/QL(KZ)
         ENDIF      
        ENDIF               ! endif for calculation of the correction terms for melting snow - water collison

!.. loop for diffusional growth of water drops

        NSTEP = MAX(1, INT(DT/DTCOND+0.5))

!+---+----------------- DEBUG IF NEEDED -------------------------------+
         if (ibug5.eq.1) then
          write(95,*) 'times',times
          write(95,*) 'nstep,dt,dtcond',nstep,dt,dtcond
          write(95,*) 'temp,qv',tk1,qv1
          write(95,*) 'tentemp,tenqv',tentemp,tenqv
          write(95,*) 'ql,nl,qice,nice,qsnow,nsnow,qgra,ngra'
          write(95,*) ql(kz),nl(kz),qice(kz),nice(kz),                  &
     &               qsnow(kz),nsnow(kz),qgra(kz),                      &
     &               ngra(kz) 
         endif
!+---+----------------- END DEBUG -------------------------------------+

        DO 200 ISTEP=1,NSTEP
          DSNT = 0.0
          DSMT = 0.0
          DSNT2 = 0.0
          DSMT2 = 0.0
          DSNT0 = 0.0
          DSMT0 = 0.0
          CCN11 = CCN
          IF (CCN11 < 0.0) CCN11 = 0.0
          QV11=QV1
          TK11=TK1
!          EWS=EXP((23.684*TK1-4947.34)/(TK1-35.86))
          EWS=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
          QWS=0.622*EWS/P
          SAT1=QV1/QWS-1.0         
          CCN=CCN+TENCCN*DTCOND
          IF (CCN < 0.0) CCN=0.0
!          QV1=QV1+TENQV*DTCOND
!          TK1=TK1+TENTEMP*DTCOND
!          EWS=EXP((23.684*TK1-4947.34)/(TK1-35.86))
          EWS=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
          QWS2=0.622*EWS/P
          SAT2=QV1/QWS2-1.0
         

!+---+----------------- DEBUG IF NEEDED -------------------------------+
          if (ibug5.eq.1) then       
            write(95,*) 'istep,dtcond,qv1,tk1,sat1,sat2'
            write(95,*) istep,dtcond,qv1,tk1,sat1,sat2
          dsegm=0.0
          dsegn=0.0
           do k=1,k4
           dsegn=dsegn+ntc(k)
           dsegm=dsegm+mtc(k)
          enddo
          write(95,*)'water before cond, mass and conc.',dsegm, dsegn
          endif
       
!+---+----------------- END DEBUG -------------------------------------+

!.. EFFECT OF RADIATION COOLING IS ALSO CALCULATED AT THE CLOUD TOP WHERE KTOP=1



          CALL COND(K4,DSNT,DSMT,DSNT2,DSMT2,DSNT0,DSMT0,               &
     &         DTCOND,ERRCOND,SCOND,ERRDEP,SDEP,                        &
!     &         NTC1,MTC1,NTCI1,MTCI1,NTCIR1,MTCIR1,                     &
!     &         TK1,QV1,TK11,QV11,CCN,DNID1,TENQV,TENTEMP,KTOP,ibug5,    &
     &         TK1,QV1,CCN,DNID1,TENQV,TENTEMP,KTOP,ibug5,              &
     &         TIMES,KZ,errseg0,P,TKE1,QVE1,ROA,LV,LD,LF,KG,VISC,DIFF)

!         if (times.eq.780.or.times.eq.781) then
!         write(98,*)'BEF. COND,times:',times,'ii:',ii,'kz,dsmtc2,dsntc2'
!         write(98,*) kz,DSMTC2(KZ),DSNTC2(KZ)
!         endif


          DSNTC2(KZ) = DSNTC2(KZ) + DSNT
          DSMTC2(KZ) = DSMTC2(KZ) + DSMT
          DSNTCI2(KZ) = DSNTCI2(KZ) + DSNT2
          DSMTCI2(KZ) = DSMTCI2(KZ) + DSMT2
          DSNTCIR0(KZ) = DSNTCIR0(KZ) + DSNT0
          DSMTCIR0(KZ) = DSMTCIR0(KZ) + DSMT0
!     CCNM = 0.5*(CCN11+CCN1)
!     TKM = 0.5*(TK11+TK1)
!     QVM = 0.5*(QV11+QV1)
          CCNM = (CCN11 + 0.5*TENCCN*DTCOND) ! fontos modositas 2007. 10. 31.
          IF (CCNM < 0.0) CCNM = 0.0
          TKM = (TK11 + 0.5*TENTEMP*DTCOND)
          QVM = (QV11 + 0.5*TENQV*DTCOND)

        WRITE (mp_debug,*) ' DEBUG: calling COND0 driver'
        if (kz.eq.1) CALL wrf_debug(150, mp_debug)

!      EWS = EXP((23.684*TKM-4947.34)/(TKM-35.86))
!      QWS = 0.622*EWS/P
!      SATS = QVM/QWS

!      if(sats.gt.1.) write(*,*)'bf cond0, sats at i,j,k',SATS,ii,jj,kz

! xue limit the surface activation within cold pool
!          if(kz.gt.1) then
          CALL COND0(CCN,CCNM,DN0,DM0,TK1,QV1,TKM,QVM,P,LV,ibug1,1)
!          end if
          
          NTC(1) = NTC(1) + DN0
          MTC(1) = MTC(1) + DM0
          DNTC0(1) = DNTC0(1) + DN0
          DMTC0(1) = DMTC0(1) + DM0
 200    CONTINUE

        TTEN1 = (TK1 - tz_old(kz))/DT
        QVTEN1 = (QV1 - qv_old(kz))/DT

! xue add this to make sure the LD is correct after cond is called
!        IF (tz_old(KZ).LT.T00) THEN
!         LD = LF + LV
!        ELSE
!         LD = LV
!        ENDIF
! xue 

!+---+----------------- DEBUG IF NEEDED -------------------------------+
        if (ibug5.eq.1) then
         write(95,*) 'after cond,tk,qv,tk1,qv1',tk11,qv11,tk1,qv1
        endif
!+---+----------------- END DEBUG -------------------------------------+

        DO K =1,K4
         DNTRIME0(K) = NTSNOWR(K) - NSNOWR0(KZ,K) !FN(K)*NSNOW1(KZ,K)
         DMTRIME0(K) = MTSNOWR(K) - QSNOWR0(Kz,K) !FQ(K)*QSNOW1(KZ,K)
         DMTSNOWM0(K) = MTSNOWM(K) - QSNOWM0(KZ,K)
         DSMTSNOWM0(KZ) = DSMTSNOWM0(KZ) + DMTSNOWM0(K) 
        ENDDO
        DSNTC0(KZ) = DSNTC0(KZ)/DT
        DSMTC0(KZ) = DSMTC0(KZ)/DT
        DSMTC2(KZ) = DSMTC2(KZ)/DT
        DSNTC2(KZ) = DSNTC2(KZ)/DT
        DSNTCI2(KZ) = DSNTCI2(KZ)/DT
        DSMTCI2(KZ) = DSMTCI2(KZ)/DT
        DSNTCIR0(KZ) = DSNTCIR0(KZ)/DT
        DSMTCIR0(KZ) = DSMTCIR0(KZ)/DT
        DSMTSNOWM0(KZ) = DSMTSNOWM0(KZ)/DT
! bulk diffusion rate
        DMWZ_DIFF(KZ) = DMWZ_DIFF(KZ)+DSMTC2(KZ)
        DMIZ_DIFF(KZ) = DSMTCI2(KZ)+DSMTCIR0(KZ)
        DMWIZ_DIFF(KZ)= DMWIZ_DIFF(KZ)+DSMTSNOWM0(KZ)
! bulk diffusion rate end

!+---+----------------- DEBUG IF NEEDED -------------------------------+
        if (ibug5.eq.1) then   
!         write(95,*) 'after cond,times,ii',times,ii
         dsegn=0.0
         dsegm=0.0
         do k=1,k4
           dsegn=dsegn+ntc(k)
           dsegm=dsegm+mtc(k)
         enddo
         write(95,*)'water after cond, mass and conc.',dsegm, dsegn
         write(95,*) 'times,kz,dsmtc2,dsntc2,dsmtc0,dsntc0',times
         write(95,*) kz,dsmtc2(kz),dsntc2(kz),dsmtc0(kz),dsntc0(kz)
        endif
        if (times.eq.781.) then
        write(98,*)'AFTER COND,times:',times,'ii:',ii,'kz,dsmtc2,dsntc2'
        write(98,*) kz,DSMTC2(KZ),DSNTC2(KZ)
        endif

!+---+----------------- END DEBUG -------------------------------------+

!     ttend(kz)=(tk1-tk)/DT
!     dqv(kz)=(qv1-qve)/DT
        tz(kz) = TK1
        QV(KZ)=QV1
        TK = 0.5*(TK11 + TK1)
        QVM = 0.5*(QV11 + QV1)
!        EWS = EXP((23.684*TK-4947.34)/(TK-35.86))
        EWS=EXP(53.67957-6743.769/tk-4.8451*log(tk))*100.
        QWS = 0.622*EWS/P
        SATWMEAN = QVM/QWS
!        EWS2 = EXP((23.684*TK1-4947.34)/(TK1-35.86))
        EWS2=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
        QWS2 = 0.622*EWS2/P 
        SAT2=QV1/QWS2

!  NTC1 and MTC1 variables are used to avoid the overestimation the collection of water drops 
        DO K =1,K4
          NTC1(K)=NTC(K)
          MTC1(K)=MTC(K)
        ENDDO

!     formation of the pristine ice by deposition or condensational freezing 
        NIDEPM = (NIDEP0(KZ) +  0.5*TENDEP*DT)
        IF(DNID1 + NIDEPM < 0.0) DNID1 = -NIDEPM
!..GT        IF (TK <  T00-5 .AND. SATWMEAN >  1.000) THEN    ! This means it must be water saturated.
        IF (TK <  T00-5) THEN
!     uncomment these two rows for no ice depletion
!     NIDEP1(KZ)=NICE1(KZ)
!     TENDEP=0.0

        WRITE (mp_debug,*) ' DEBUG: calling DEPACT'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

         CALL DEPACT(K4,DNTCI0,DMTCI0,NIDEPM,TENDEP,DT, P,TK,QVM,ROA)
         DO K=1,K4
          NTCI(K)=NTCI(K)+DNTCI0(K)*DT
          MTCI(K)=MTCI(K)+DMTCI0(K)*DT
         ENDDO
        ENDIF
        TENDEP=TENDEP+DNID1/DT
!     uncomment this row for no ice depletion
!     TENDEP=0.0
            
!      goto 2222     ! collison - colescence is neglected
 125  IF (NL(KZ) > EPS) THEN
!     collection of IN by drops with Brownian and phoretic
!     CALL phoresis(ntc,mtc,dntc3,dmtc3,m,ac,bc,cc,dc, &
!     rada,pk,k4,ibug)
!     self coagulation of the water drops

!     self coagulation of the water drops
       DTDRP=DT/10. !0.1
       NSTEP=DT/DTDRP
       CONST1T = CONST1/DT*DTDRP
       NLT=0.0
       DO K=1,K4
        MTCT(K)=MTC(K)
        NTCT(K)=NTC(K)
        NLT=NLT+NTC(K)
       ENDDO

!        WRITE (mp_debug,*) ' DEBUG: calling COAGS'
!        if (kz.eq.1) CALL wrf_debug(250, mp_debug)
    
!         CALL COAGS(K4,AC,BC,CC,DC,DNTC1,DMTC1,CCW,CCCW)

!
!     coag. of graupel particles and  drops  + H-M ice multiplication
!
       DO ISTEP =1,NSTEP
        CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
        DO K=1,K4
         DMTC1T(K)=0.d0
         DNTC1T(K)=0.d0
         DNTC1BT(K)=0.d0
         DMTC1BT(K)=0.d0
        ENDDO
        CALL COAGS(K4,ACT,BCT,CCT,DCT,DNTC1T,DMTC1T,CCW,CCCW)
        IF (IBREAKUP == 1) THEN
!     collison induced breakup
!         CALL BREAKUP(K4,DNTC1B,DMTC1B,CCCWMEAN,DT)    !modofied 04.27. by SN.
         CALL BREAKUP(K4,MTCT,NTCT,DNTC1BT,DMTC1BT,CCCWMEAN,DTDRP,ibug0)
        ENDIF
        NLT=0.0
        DO K = 1, K4
         NTCT(K)=NTCT(K)+CONST1T*(DNTC1T(K)+DNTC1B(K))
         MTCT(K)=MTCT(K)+CONST1T*(DMTC1T(K)+DMTC1B(K))
         IF (NTCT(K).LT.0.d0.OR.MTCT(K).LT.0.d0) THEN
          NTCT(K)=0.d0
          MTCT(K)=0.d0
         ENDIF
         NLT=NLT+NTCT(K)
         DNTC1(K)=DNTC1(K)+DTDRP*DNTC1T(K)
         DMTC1(K)=DMTC1(K)+DTDRP*DMTC1T(K)
         DNTC1B(K)=DNTC1B(K)+DTDRP*DNTC1BT(K)
         DMTC1B(K)=DMTC1B(K)+DTDRP*DMTC1BT(K)
        ENDDO
       ENDDO
       DO K=1,K4
        NTC1(K)=NTCT(K)
        MTC1(K)=MTCT(K)
        DNTC1(K)=DNTC1(K)/DT
        DMTC1(K)=DMTC1(K)/DT
        DNTC1B(K)=DNTC1B(K)/DT
        DMTC1B(K)=DMTC1B(K)/DT
       ENDDO

      ENDIF

!+---+-----------------------------------------------------------------+
        IF (NICE(KZ) > EPS.AND.NL(KZ) > EPS) THEN
         IF (tz_old(KZ) < T00) THEN
!     coag. of pristine ice crystals and drops
   
          CALL COAG40(K4,ACI,BCI,CCI,DCI,AC,BC,CC,DC,DMTCI3,DNTCI3,     &
     &     DMTC5,DNTC5,DMTCIR1,DNTCIR1,DMTGRA5,DNTGRA5,CCIW,CCCIW,C5IW, &
     &     CCCVIW,C5VIW,DMTRIME1,DNTRIME1)
     
!     if  dmtci3 is greater than the mixing ratio of the pristine ice cryst. the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTCI3(K)
           DSSN1=DSSN1+CONST1*DNTCI3(K)
           IF ((CONST1*DNTCI3(K)+NTCI(K).LT.0.d0) .OR.                  &
     &                       (CONST1*DMTCI3(K)+MTCI(K).LT.0.d0)) THEN     
            DNTCI3(K)=-NTCI(K)/CONST1
            DMTCI3(K)=-MTCI(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTCI3(K)
           DSEGN=DSEGN+CONST1*DNTCI3(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 145
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTC5(K)=CORRM*DMTC5(K)
            DNTC5(K)=CORRN*DNTC5(K)
            DNTCIR1(K)=CORRN*DNTCIR1(K)
            DMTCIR1(K)=CORRM*DMTCIR1(K)
            DNTGRA5(K)=CORRN*DNTGRA5(K)
            DMTGRA5(K)=CORRM*DMTGRA5(K)
            DNTRIME1(K)=CORRN*DNTRIME1(K)
            DMTRIME1(K)=CORRM*DMTRIME1(K)
           ENDDO
          ENDIF
 145      CONTINUE
          DO K =1,K4
           NTC1(K)= NTC1(K) + CONST1*DNTC5(K)
           MTC1(K)= MTC1(K) + CONST1*DMTC5(K)
           NTC1(K)= DMAX1(0.d0,NTC1(K))
           MTC1(K)= DMAX1(0.d0,MTC1(K))
          ENDDO
         ENDIF            ! endif for tk< 273.15
        ENDIF               !  nic > eps and nw > eps

        IF (NICE(KZ) > EPS) THEN
!     aggregatin of pristine ice crystals
         IF (TK < T00) THEN ! coalesence efficiency of ice cr. - ice cr. collision
          EICIC=EXP(0.38*(TK-T00))
         ELSE
          EICIC=1.00
         ENDIF
         EICIC=0.10       ! Paul's suggestion
        WRITE (mp_debug,*) ' DEBUG: calling COAG6'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)
         CALL COAG6(K4,ACI,BCI,CCI,DCI,DMTCI5,DNTCI5,                   &
     &              DMTCIR5,DNTCIR5,CCSNOW1,CCCSNOW1,CSNOW15)
        ENDIF
        IF (NSNOW(KZ) > EPS) THEN
!     aggregation of snow flakes
         IF (TK < T00) THEN ! coalesence efficiency of rimed ice cr. - rimed ice cr. collision
!-GT           ERICRIC=EXP(0.09*(TK-T00))
           ERICRIC=0.1
         ELSE
           ERICRIC=1.00
         ENDIF
!        ERICRIC=0.1    ! Paul's suggestion, modified:2013.04.15.
         WRITE (mp_debug,*) ' DEBUG: calling COAGS1, ERICRIC=',ERICRIC
         if (kz.eq.1) CALL wrf_debug(250, mp_debug)
         IF (tz_old(KZ) < T00) THEN
           CALL COAGS1(K4,ACIR,BCIR,CCIR,DCIR,DNTCIR4,DMTCIR4,          &
     &                 CCSNOW2,CCCSNOW2,FQ,DMTRIME3,FN,DNTRIME3)
         ELSE
           CALL COAGS1M(K4,ACIR,BCIR,CCIR,DCIR,DNTCIR4,DMTCIR4,         &
     &                 CCSNOW2,CCCSNOW2,FQSM,DMTSNOWM1)

!..New addition to adjust snow self-collection due to changed diameter of melted snow compared to dry snow used in the kernels.  I.G. 2013Aug20
           CORR = (DSNWM/DSNDM)*(DSNWM/DSNDM)
           CORR = MIN(CORR, 1.0)
           DO K = 1,K4
              DNTCIR4(K) = CORR*DNTCIR4(K)
              DMTCIR4(K) = CORR*DMTCIR4(K)
              DMTSNOWM1(K) = CORR*DMTSNOWM1(K)
           ENDDO
         ENDIF
        if (ibug3.eq.1) then
         write(98,*) 'after aggregation tk',tk1,tz_old(KZ)
         write(98,*) ntcir(34),mtcir(34)
        endif

        ENDIF
        IF (NSNOW(KZ) > EPS.AND.NL(KZ) > EPS) THEN
!     coag. of snow flake crystals and  drops

         IF (tz_old(KZ).LT.T00) THEN
         
          CALL COAG5 (K4,AC,BC,CC,DC,ACIR,BCIR,CCIR,DCIR,DMTC6,DNTC6,   &
     &          DMTCIR2,DNTCIR2,DMTGRA2,DNTGRA2,CCRIW,CCCRIW,CCCVRIW,   &
     &          C5VRIW,FQ,DMTRIME2,FN,DNTRIME2)
          DO K=1,K4
             DMTC6(K)=EWRIC*DMTC6(K)
             DNTC6(K)=EWRIC*DNTC6(K)
             DMTCIR2(K)=EWRIC*DMTCIR2(K)
             DNTCIR2(K)=EWRIC*DNTCIR2(K)
             DMTGRA2(K)=EWRIC*DMTGRA2(K)
             DNTGRA2(K)=EWRIC*DNTGRA2(K)
             DMTRIME2(K)=EWRIC*DMTRIME2(K)
             DNTRIME2(K)=EWRIC*DNTRIME2(K)
          ENDDO
!     if  dmtc6 is greater than the mixing ratio of the water drops the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTC6(K)
           DSSN1=DSSN1+CONST1*DNTC6(K)
!           IF ((CONST1*DNTC6(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC6(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC6(K)=-NTC1(K)/CONST1
!            DMTC6(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1*DNTC6(K)+NTC1(K).LT.0.d0) THEN                   !  IG 15May2014
            DNTC6(K)=-NTC1(K)/CONST1
           ENDIF
           IF (CONST1*DMTC6(K)+MTC1(K).LT.0.d0) THEN
            DMTC6(K)=-MTC1(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTC6(K)
           DSEGN=DSEGN+CONST1*DNTC6(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 143
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTCIR2(K)=CORRM*DMTCIR2(K)
            DNTCIR2(K)=CORRN*DNTCIR2(K)
            DMTGRA2(K)=CORRM*DMTGRA2(K) 
            DNTGRA2(K)=CORRN*DNTGRA2(K)
            DMTRIME2(K)= CORRM*DMTRIME2(K)
            DNTRIME2(K)=CORRN*DNTRIME2(K)
           ENDDO
          ENDIF
 143      CONTINUE
           if (ibug3.eq.1) then
            write(98,*)'corrm,corrn after drop - snow coll'
            write(98,*) corrm,corrn
           endif
         ELSE
          if (ibug3.eq.1) then
           write(98,*) 'before coag5m snow'
          endif
        WRITE (mp_debug,*) ' DEBUG: calling COAG5M'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

          CALL COAG5M (K4,AC,BC,CC,DC,ACIR,BCIR,CCIR,DCIR,DMTC6,DNTC6,  &
     &               DMTCIR2,DNTCIR2,CCRIW,CCCRIW,CCCVRIW,C5VRIW,FQSM,  &
     &               DMTSNOWM2,DMTCIR2V,DNTCIR2V,ibug3)

!     correction of  modified kernel
!     correction was made on 08. 20. 2013 to avoid the division by zero
          if (abs(VTSNDM-VTWATM) .gt. 1.E-5) then
             CORR = abs(VTSNWM-VTWATM)/abs(VTSNDM-VTWATM)*                 &
     &                              (DSNWM+DWATM)**2/(DSNDM+DWATM)**2
             CORR = MIN(1.0, CORR)
           else
             CORR = 1.0
           endif
!          CORR = 1.0
!2013.04.15.
          CORR = CORR*EWRIC
          DO K = 1,K4
           DNTC6(K)=CORR*DNTC6(K)
           DMTC6(K)=CORR*DMTC6(K)
           DMTCIR2(K)=CORR*DMTCIR2(K)
           DNTCIR2(K)=CORR*DNTCIR2(K)
           DMTCIR2V(K)=CORR*DMTCIR2V(K)
           DNTCIR2V(K)=CORR*DNTCIR2V(K)
           DMTSNOWM2(K)=CORR*DMTSNOWM2(K)
          ENDDO
!
!     if  dmtc6 is greater than the mixing ratio of the water drops the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTC6(K)
           DSSN1=DSSN1+CONST1*DNTC6(K)
!           IF ((CONST1*DNTC6(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC6(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC6(K)=-NTC1(K)/CONST1
!            DMTC6(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1*DNTC6(K)+NTC1(K).LT.0.d0) THEN                   !  IG 15May2014
            DNTC6(K)=-NTC1(K)/CONST1
           ENDIF
           IF (CONST1*DMTC6(K)+MTC1(K).LT.0.d0) THEN
            DMTC6(K)=-MTC1(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTC6(K)
           DSEGN=DSEGN+CONST1*DNTC6(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 146
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTCIR2(K)=CORRM*DMTCIR2(K)
            DNTCIR2(K)=CORRN*DNTCIR2(K)            
            DMTSNOWM2(K)=CORRM*DMTSNOWM2(K)
            DMTCIR2V(K)=CORRM*DMTCIR2V(K)
            DNTCIR2V(K)=CORRN*DNTCIR2V(K)
           ENDDO
          ENDIF
 146     CONTINUE

         ENDIF

         DO K = 1, K4
          NTC1(K) = NTC1(K) + CONST1*DNTC6(K)
          MTC1(K) = MTC1(K) + CONST1*DMTC6(K)
          NTC1(K) = DMAX1(0.d0,NTC1(K))
          MTC1(K) = DMAX1(0.d0,MTC1(K))
         ENDDO
        ENDIF                ! endif for snow  - drop collision 
!     
!     a different subroutine has to be used in the melting region, because in this case
!     no graupel form even if the size of the drops is larger than that of the collector snow. The kernel should also depends on the melted fraction 
!     
        IF (NSNOW(KZ)> EPS.AND.NICE(KZ) > EPS) THEN
         IF (tz_old(KZ) < T00) THEN
!     coag. of  pristine ice crystals and snow flake
           IF (TK < T00) THEN ! coalesence efficiency of snow flake - pristine ice cr.collision
             ERICIC=EXP(0.09*(TK-T00))
           ELSE
             ERICIC=1.00
           ENDIF
           ERICIC=0.10   ! Paul's suggestion
        WRITE (mp_debug,*) ' DEBUG: calling COAG3  k=',kz
        CALL wrf_debug(250, mp_debug)
           CALL COAG3(K4,ACI,BCI,CCI,DCI,ACIR,BCIR,CCIR,DCIR,DMTCI9,    &
     &          DNTCI9,DMTCIR7,DNTCIR7,CCCICIR,CCCCICIR,CCCVCICIR,      &
     &          C5VCICIR,FQ,DMTRIME4,FN,DNTRIME4)

!     
!     if  roa1*dmtcir7(k)+mtcir(k) is less than 0 values are renormalized
!     
           DSEGN1=0.d0
           DSEGN2=0.d0
           CONST11=DBLE(CONST1*ERICIC)
           DSSM1=0.d0
           DSSN1=0.d0
           DSSM2=0.d0
           DO K=1,K4
            dssm1=dssm1+CONST11*DMTCI9(K)
            dssn1=dssn1+CONST11*DNTCI9(K)
            IF (CONST11*DNTCIR7(K)+NTCIR(K).LT.0.d0) THEN
              DSEGN1=DSEGN1+CONST11*DNTCIR7(K)
              DNTCIR7(K)=-NTCIR(K)/CONST11
              DSEGN2=DSEGN2-NTCIR(K)
            ENDIF
            IF (CONST11*DMTCIR7(K)+MTCIR(K).LT.0.d0) THEN
              DMTCIR7(K)=-MTCIR(K)/CONST11
            ENDIF
            DSSM2=DSSM2+CONST11*DMTCIR7(K)
           ENDDO
           dhiban=ABS(DSEGN1-DSEGN2)
           corrn=1.0
           corrm=1.0
           IF (DSSN1.LT.0.0) THEN
             corrn=1.0+dhiban/DSSN1
           ENDIF
           IF (DSSM1.LT.0.0) THEN
                     corrm=dabs(DSSM2/DSSM1)
           ENDIF
           IF (corrm.gt.1.d0) corrm=1.d0
           IF (corrn.gt.1.d0) corrn=1.d0
           IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
             DO K=1,K4
               dmtci9(K)=corrm*dmtci9(K)
               dntci9(K)=corrn*dntci9(K)
             ENDDO
           ENDIF
         ENDIF            ! endif for tk < t00
        ENDIF               ! endif for ncir > eps and nic > eps
        IF (NGRA(KZ) > EPS  .AND. NL(KZ) > EPS) THEN
         DTGRWAT=0.1 !DT/10. !0.1
         NSTEP=DT/DTGRWAT
         CONST1T = CONST1/DT*DTGRWAT
         if (ibug1.eq.1) then
          write(98,*) 'start graupel - water'
          write(98,*) 'dtgrwat,nstep,const1t',dtgrwat,nstep,const1t
         endif
         NLT=0.0
         NGRAT=0.0
         DO K=1,K4
          MTCT(K)=MTC1(K)
          NTCT(K)=NTC1(K)
          MTGRAT(K)=MTGRA(K)
          NTGRAT(K)=NTGRA(K)
          MTGRAMT(K)=MTGRAM(K)
          NLT=NLT+NTC1(K)
          NGRAT=NGRAT+NTGRA(K)
         ENDDO
!     
!     coag. of graupel particles and  drops  + H-M ice multiplication
!     
         IF (tz_old(KZ)  < T00) THEN
          DO ISTEP =1,NSTEP
           CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
           CALL COEF1(K4,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,KMINGRA,   &
     &                KMAXGRA,NGRAT)
           DSNTCI6T=0.0
           DO K=1,K4
            DMTC8T(K)=0.d0
            DNTC8T(K)=0.d0
            DMTGRA3T(K)=0.d0
            DNTGRA3T(K)=0.d0
           ENDDO
           CALL COAG31 (K4,ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,       &
     &      DMTC8T,DNTC8T,DMTGRA3T,DNTGRA3T,CCGW1,CCCGW1,CCCVGW1,C5VGW1,  &
     &      CICEM,DSNTCI6T,tz_old(kz))
!           CALL COAG31 (K4,AC,BC,CC,DC,agra,bgra,cgra,dgra,dmtc8,dntc8,  &
!     &     dmtgra3,dntgra3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,CICEM,            &
!     &     DSNTCI6(KZ),tz_old(kz))

          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1T*DMTC8T(K)
           DSSN1=DSSN1+CONST1T*DNTC8T(K)
!           IF ((CONST1*DNTC8(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC8(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC8(K)=-NTC1(K)/CONST1
!            DMTC8(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1T*DNTC8T(K)+NTCT(K).LT.0.d0) THEN                   !  IG 15May2014
             DNTC8T(K)=-NTCT(K)/CONST1T
           ENDIF
           IF (CONST1T*DMTC8T(K)+MTCT(K).LT.0.d0) THEN
             DMTC8T(K)=-MTCT(K)/CONST1T
           ENDIF
           DSEGM=DSEGM+CONST1T*DMTC8T(K)
           DSEGN=DSEGN+CONST1T*DNTC8T(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 247
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTGRA3T(K)=CORRM*DMTGRA3T(K)
            DNTGRA3T(K)=CORRN*DNTGRA3T(K)
           ENDDO
          ENDIF
247      CONTINUE

!     calculation of the Hallett - Mossop ice multiplication rate
!     DSNTCI6(KZ)=0.0
!     no ice multiplication if dsntci6z(kz) = 0.0
!           IF (TK < 265.16 .OR. tk > 270.16) GOTO 110
!           IF (TK  > 268.15) THEN
!             FP = (270.16-TK)/2.d0
!           ELSE
!             FP  = (TK-265.15)/3.d0
!           ENDIF
           FP=0.0
           IF (TZ_OLD(KZ) < 265.16 .OR. TZ_OLD(KZ) > 270.16) GOTO 110
           IF (TZ_OLD(KZ)  > 268.15) THEN
             FP = (270.16-TZ_OLD(KZ))/2.d0
           ELSE
             FP  = (TZ_OLD(KZ)-265.16)/3.d0
           ENDIF
 110       DSNTCI6T=DSNTCI6T*FP*0.16
           DSMTCI6(KZ)=DSNTCI6(KZ)+DSNTCI6T*DTGRWAT !*1.5*M(2)
            NLT=0.0
            NGRAT=0.0
            DO K = 1,K4
             NTCT(K)=NTCT(K)+CONST1T*DNTC8T(K)
             MTCT(K)=MTCT(K)+CONST1T*DMTC8T(K)
             NTGRAT(K)=NTGRAT(K)+CONST1T*DNTGRA3T(K)
             MTGRAT(K)=MTGRAT(K)+CONST1T*DMTGRA3T(K)
             NLT=NLT+NTCT(K)
             NGRAT=NGRAT+NTGRAT(K)
             DNTC8(K)=DNTC8(K)+DTGRWAT*DNTC8T(K)
             DMTC8(K)=DMTC8(K)+DTGRWAT*DMTC8T(K)
             DNTGRA3(K)=DNTGRA3(K)+DTGRWAT*DNTGRA3T(K)
             DMTGRA3(K)=DMTGRA3(K)+DTGRWAT*DMTGRA3T(K)
            ENDDO
          ENDDO         !  enddo for the loop of small time step
          DO K=1,K4
           NTC1(K)=NTCT(K)
           MTC1(K)=MTCT(K)
           DNTC8(K)=DNTC8(K)/DT
           DMTC8(K)=DMTC8(K)/DT
           DNTGRA3(K)=DNTGRA3(K)/DT
           DMTGRA3(K)=DMTGRA3(K)/DT
          ENDDO
          DSNTCI6(KZ)=DSNTCI6(KZ)/DT
          DSMTCI6(KZ)=DSNTCI6(KZ)*1.5*M(2)
         ELSE             !   else  for tk < t00
!     if the temperature is over the melting temperature no ice multiplications occures,
!     it is supposed that the melting of the graupel particles does not affect the drop - graupel collison kernels
           if (ibug3.eq.1) then
            write(98,*) 'befor graupel coag5m'
           endif
!!           CALL COAG5M(K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,DMTC8,DNTC8,  &
!!     &                 DMTGRA3,DNTGRA3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,FQGM,&    
!!     &                 DMTGRAM3,DMTGRA3V,DNTGRA3V,ibug3)

!          CALL COAG5M1(K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,DMTC8,DNTC8,DMTC8S,  &
!     &                 DNTC8S,DMTGRA3,DNTGRA3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,FQGM,&
!     &                 DMTGRAM3,DMTGRA3V,DNTGRA3V,DT,ibug3,ii,kz,times)
          DO ISTEP =1,NSTEP
           CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
           CALL COEF1(K4,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,KMINGRA,   &
     &                KMAXGRA,NGRAT)

           DO K=1,K4
            DMTC8T(K)=0.d0
            DNTC8T(K)=0.d0
            DMTC8ST(K)=0.d0
            DNTC8ST(K)=0.d0
            DMTGRA3T(K)=0.d0
            DNTGRA3T(K)=0.d0
            DMTGRAM3T(K)=0.d0
            DMTGRA3VT(K)=0.d0
            DNTGRA3VT(K)=0.d0
            FQGMT(K)=0.0
            IF (MTGRAT(K).GT.0.0) THEN
             FQGMT(K)=MTGRAMT(K)/MTGRAT(K)
            ENDIF
            FQGMT(K)=MIN(1.0,MAX(0.0,FQGMT(K)))
           ENDDO
           CALL COAG5M1(K4,ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,                 &
     &                NTGRAT,MTGRAT,MTGRAMT,                                        &  
     &                DMTC8T,DNTC8T,DMTC8ST,DNTC8ST,DMTGRA3T,DNTGRA3T,CCGW1,CCCGW1, &
     &                CCCVGW1,C5VGW1,FQGMT,DMTGRAM3T,DMTGRA3VT,DNTGRA3VT,DT,CONST1T,&
     &                 ibug1,ii,kz,times)
     
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1T*DMTC8T(K)
           DSSN1=DSSN1+CONST1T*DNTC8T(K)
!           IF ((CONST1*DNTC8(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC8(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC8(K)=-NTC1(K)/CONST1
!            DMTC8(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1T*DNTC8T(K)+NTCT(K).LT.0.d0) THEN                   !  IG 15May2014
             DNTC8T(K)=-NTCT(K)/CONST1T
           ENDIF
           IF (CONST1T*DMTC8T(K)+MTCT(K).LT.0.d0) THEN
             DMTC8T(K)=-MTCT(K)/CONST1T
           ENDIF
           DSEGM=DSEGM+CONST1T*DMTC8T(K)
           DSEGN=DSEGN+CONST1T*DNTC8T(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 147
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTGRA3T(K)=CORRM*DMTGRA3T(K)
            DNTGRA3T(K)=CORRN*DNTGRA3T(K)
            DMTGRA3VT(K)=CORRM*DMTGRA3VT(K)
            DNTGRA3VT(K)=CORRN*DNTGRA3VT(K)
            DMTGRAM3T(K)=CORRM*DMTGRAM3T(K)
            DNTC8ST(K)=CORRN*DNTC8ST(K)
            DMTC8ST(K)=CORRM*DMTC8ST(K)
           ENDDO
          ENDIF
 147      CONTINUE
!   
!    calculation of the constrain for the graupel particles
!
           dsegn1=0.d0
           dsegn2=0.d0
           dssm1=0.d0
           dssn1=0.d0
           dssm2=0.d0
           DO K=1,K4
            dssm1=dssm1+const1t*dmtgra3t(K)
            dssn1=dssn1+const1t*DNTC8T(K)
            IF (const1t*dntgra3t(K)+ntgrat(K) < 0.d0) THEN
             dsegn1=dsegn1+const1t*dntgra3t(K)
             dntgra3t(K)=-ntgrat(K)/const1t
             dsegn2=dsegn2-ntgrat(K)
            ENDIF
            IF (const1t*dmtgra3t(K)+mtgrat(K) < 0.d0) THEN
             dmtgra3t(K)=-mtgrat(K)/const1t
            ENDIF
            dssm2=dssm2+const1t*dmtgra3t(K)
           ENDDO
           dhiban=dabs(dsegn1-dsegn2)
           corrn=1.d0
           corrm=1.d0
           IF (dssn1 < 0.d0) THEN
            corrn=1.d0+dhiban/dssn1
           ENDIF
           IF (dssm1 < 0.d0) THEN
            corrm=dabs(dssm2/dssm1)
           ENDIF
           IF (CORRM > 1.d0) CORRM=1.d0
           IF (CORRN > 1.d0) CORRN=1.d0
           IF (CORRN < 1.d0 .OR. CORRM < 1.d0) THEN
            DO K=1,K4
             DMTC8T(K)=corrm*DMTC8T(K)
             DNTC8T(K)=corrn*DNTC8T(K)
             DMTGRA3VT(K)=CORRM*DMTGRA3VT(K)
             DNTGRA3VT(K)=CORRN*DNTGRA3VT(K)
             DMTGRAM3T(K)=CORRM*DMTGRAM3T(K)
             DNTC8ST(K)=CORRN*DNTC8ST(K)
             DMTC8ST(K)=CORRM*DMTC8ST(K)
            ENDDO
           ENDIF
           NLT=0.0
           NGRAT=0.0
           DO K = 1,K4
             NTCT(K)=NTCT(K)+CONST1T*DNTC8T(K)      !!     +DNTC8ST(K))
             MTCT(K)=MTCT(K)+CONST1T*DMTC8T(K)      !!     +DMTC8ST(K))
             NTGRAT(K)=NTGRAT(K)+CONST1T*DNTGRA3T(K)
             MTGRAT(K)=MTGRAT(K)+CONST1T*DMTGRA3T(K)
             MTGRAMT(K)=MTGRAMT(K)+CONST1T*DMTGRAM3T(K)
             NTCT(K)=DMAX1(0.d0,NTCT(K))
             MTCT(K)=DMAX1(0.d0,MTCT(K))
             NTGRAT(K)=DMAX1(0.d0,NTGRAT(K))
             MTGRAT(K)=DMAX1(0.d0,MTGRAT(K))
             MTGRAMT(K)=DMAX1(0.d0,MTGRAMT(K))
             NLT=NLT+NTCT(K)
             NGRAT=NGRAT+NTGRAT(K)
             DNTC8(K)=DNTC8(K)+DTGRWAT*DNTC8T(K)
             DMTC8(K)=DMTC8(K)+DTGRWAT*DMTC8T(K)
             DNTC8S(K)=DNTC8S(K)+DTGRWAT*DNTC8ST(K)
             DMTC8S(K)=DMTC8S(K)+DTGRWAT*DMTC8ST(K)
             DNTGRA3(K)=DNTGRA3(K)+DTGRWAT*DNTGRA3T(K)
             DMTGRA3(K)=DMTGRA3(K)+DTGRWAT*DMTGRA3T(K)
             DNTGRA3V(K)=DNTGRA3V(K)+DTGRWAT*DNTGRA3VT(K)
             DMTGRA3V(K)=DMTGRA3V(K)+DTGRWAT*DMTGRA3VT(K)
             DMTGRAM3(K)=DMTGRAM3(K)+DTGRWAT*DMTGRAM3T(K)
           ENDDO
          ENDDO         !  enddo for the loop of small time step
          if (ibug1.eq.1) then
           write(98,*) 'after loop for the small timestep'
          endif
          DO K=1,K4
           NTC1(K)=NTCT(K)
           MTC1(K)=MTCT(K)
           if (ibug1.eq.1) then
             write(98,*) 'k,ntc1,dntc8,dntc8s',k,ntc1(k),dntc8(k),dntc8s(k)
             write(98,*) 'k,mtc1,dmtc8,dmtc8s',k,mtc1(k),dmtc8(k),dmtc8s(k)
           endif
           DNTC8(K)=DNTC8(K)/DT
           DMTC8(K)=DMTC8(K)/DT
           DNTGRA3(K)=DNTGRA3(K)/DT
           DMTGRA3(K)=DMTGRA3(K)/DT
           DNTC8S(K)=DNTC8S(K)/DT
           DMTC8S(K)=DMTC8S(K)/DT
           DNTGRA3V(K)=DNTGRA3V(K)/DT
           DMTGRA3V(K)=DMTGRA3V(K)/DT
           DMTGRAM3(K)=DMTGRAM3(K)/DT
          ENDDO
         ENDIF 
         DO K = 1,K4
          NTC1(K)=NTC1(K) + CONST1*DNTC8(K)
          MTC1(K)=MTC1(K) + CONST1*DMTC8(K)
          NTC1(K)=DMAX1(0.d0,NTC1(K))
          MTC1(K)=DMAX1(0.d0,MTC1(K))
         ENDDO
        ENDIF               ! endif for ngr > eps and nw > eps
        IF (NGRA(KZ) > EPS) THEN
      
!     diffusional growth of graupel particles
! xue if the water mass on graupel is reduced after depos, where the heat is accounted for in meltgra?
          CALL DEPOS(k4,kmingra,kmaxgra,QGRA(KZ),NGRA(KZ),              &
     &        agra,bgra,cgra,dgra,DSNTGRA10(KZ),DSMTGRA10(KZ),FQGM,     &
     &        p,TKE1,QVE1,ROA,ld,kg,diff,visc,         &
     &        errdep1,sdep1,dt,ibug0)
         DSNTGRA10(KZ) = DSNTGRA10(KZ)/DT
         DSMTGRA10(KZ) = DSMTGRA10(KZ)/DT
         DO K = 1, K4
           DSMTGRAM0(KZ)=DSMTGRAM0(KZ)+(MTGRAM(K)-QGRAM0(KZ,K))/DT ! xue add /DT
         ENDDO
! bulk ice diffusion rate  
         DMIZ_DIFF(KZ) = DMIZ_DIFF(KZ) + DSMTGRA10(KZ)
         DMWIZ_DIFF(KZ)= DMWIZ_DIFF(KZ)+ DSMTGRAM0(KZ) !/DT
! bulk ice diffusion rate  
        ENDIF

!        IF (RADA  >= 1.0e-6) THEN
!          CALL GRAVCOAG(K4,AC,BC,CC,DC,DNTC4,DMTC4,CA6,ROA)          ! collection of IN by drops due to grav. coag.
!        ENDIF

        IF (NL(KZ) > EPS) THEN
!         IF (TK < 268.0) THEN
         IF (TZ_OLD(KZ) < 268.0) THEN
          CALL FREEZINGI(K4,NTC1,MTC1,DNTCI1,DMTCI1,DNTGRA0,DMTGRA0,DT, &
     &                   p,TKE1,QVE1)
         ENDIF
        ENDIF
        NTCI(2) = NTCI(2) + DSNTCI6(KZ)*DT
        MTCI(2) = MTCI(2) + DSNTCI6(KZ)*1.5*M(2)*DT
! 2222   continue
!+---+-----------------------------------------------------------------+

        WRITE (mp_debug,*) ' DEBUG:  done primary microphys steps'
        CALL wrf_debug(250, mp_debug)

        DO K=1,K4-1
!         NTC(K)=NTC(K)+DT*(ROA1*(dntc1(K)+DNTC1B(K)+dntc5(K)+dntc6(K)+  &
!     &           dntc8(K))-dntgra0(K)-dntci1(K)-dntgra4(K)-             &
!     &          dntci4(K))
         NTC(K)=NTC(K)+DT*(ROA1*(dntc1(K)+DNTC1B(K)+dntc5(K)+dntc6(K)+  &
     &           dntc8(K)+dntc8S(K))-dntgra0(K)-dntci1(K)-dntgra4(K)-   &
     &          dntci4(K))
!         MTC(K)=MTC(K)+DT*(ROA1*(dmtc1(K)+DMTC1B(K)+dmtc5(K)+dmtc6(K)+  &
!     &               dmtc8(K))-dmtgra0(K)-dmtci1(K)-dmtgra4(K)-         &
!     &              dmtci4(K))
         MTC(K)=MTC(K)+DT*(ROA1*(dmtc1(K)+DMTC1B(K)+dmtc5(K)+dmtc6(K)+  &
     &           dmtc8(K)+dmtc8S(K))-dmtgra0(K)-dmtci1(K)-dmtgra4(K)-   &
     &              dmtci4(K))
         NTCIR(K)=NTCIR(K)+CONST1*(DNTCIR1(K)+DNTCIR2(K)+               &
     &             ERICRIC*DNTCIR4(K)+EICIC*DNTCIR5(K)+                 & 
     &            ERICIC*DNTCIR7(K))
         MTCIR(K)=MTCIR(K)+CONST1*(DMTCIR1(K)+DMTCIR2(K)+               &
     &             ERICRIC*DMTCIR4(K)+EICIC*DMTCIR5(K)+                 &
     &            ERICIC*DMTCIR7(K))
         NTCI(K)=NTCI(K)+DT*(DNTCI1(K)+DNTCI4(K)+ROA1*(DNTCI3(K)+       &
     &           EICIC*DNTCI5(K)+ERICIC*DNTCI9(K)))
         MTCI(K)=MTCI(K)+DT*(DMTCI1(K)+DMTCI4(K)+ROA1*(DMTCI3(K)+       &
     &           EICIC*DMTCI5(K)+ERICIC*DMTCI9(K)))
         NTGRA(K)=NTGRA(K)+DT*(ROA1*((DNTGRA2(K)+                       &
     &            DNTGRA3(K)+DNTGRA5(K)))+DNTGRA0(K)+DNTGRA4(K))
         MTGRA(K)=MTGRA(K)+DT*(ROA1*((DMTGRA2(K)+                       &
     &              DMTGRA3(K)+DMTGRA5(K)))+DMTGRA0(K)+DMTGRA4(K))   

         
!     
!     transfer of the small ice particles (k<10) into the pristine ice category
!     
         IF (K < 10) THEN
          DSSN1 = NTCIR(K) + NTGRA(K)
          DSSM1 = MTCIR(K) + MTGRA(K)
          NTCI(K) = NTCI(K) + DSSN1
          MTCI(K) = MTCI(K) + DSSM1
          DSNTCI11(KZ) = DSNTCI11(KZ) + DSSN1/DT   ! xue add /DT for the following terms
          DSMTCI11(KZ) = DSMTCI11(KZ) + DSSM1/DT
          DSNTCIR9(KZ) = DSNTCIR9(KZ) - NTCIR(K)/DT
          DSMTCIR9(KZ) = DSMTCIR9(KZ) - MTCIR(K)/DT
          DSNTGRA12(KZ) = DSNTGRA12(KZ) - NTGRA(K)/DT
          DSMTGRA12(KZ) = DSMTGRA12(KZ) - MTGRA(K)/DT
          NTCIR(K)=0.d0
          MTCIR(K)=0.d0
          NTGRA(K)=0.d0
          MTGRA(K)=0.d0
         ENDIF
!     corrections for negativ values
         IF (NTC(K).LT.0.d0.OR.MTC(K).LT.0.d0) THEN
           NTC(K)=0.d0
           MTC(K)=0.d0
         ENDIF
         IF (NTCI(K).LT.0.d0.OR.MTCI(K).LT.0.d0) THEN
           NTCI(K)=0.d0
           MTCI(K)=0.d0
         ENDIF
         IF (NTCIR(K).LT.0.d0.OR.MTCIR(K).LT.0.d0) THEN
           MTCIR(K)=0.d0
           NTCIR(K)=0.d0
         ENDIF
         IF (NTGRA(K).LT.0.d0.OR.MTGRA(K).LT.0.d0) THEN
           MTGRA(K)=0.d0
           NTGRA(K)=0.d0
         ENDIF
        ENDDO
        if (ibug3.eq.1) then
         write(98,*) 'after sum production terms1 tk',tz_old(KZ)
         write(98,*) ntcir(34),mtcir(34)
        endif
        IF (tz_old(KZ) > T00) THEN

!     calculations of melting of the snow flakes and  graupel particles
!     
!     The melting changes the melted fraction of the snow and graupel particles
!     If the melted fraction becomes equal to one the solid particles are transfered to water drops
!     
!     melting of the rimed ice
!     

         IF (QSNOW(KZ) > EPS) THEN

      if (debug_flag .and. ibug4.eq.1) then
        WRITE (mp_debug,*) '   DEBUG MELT-1, snow (kz,Temp) ', kz,tz_old(kz)
        CALL wrf_debug(150, mp_debug)
        DO K = 1, K4
           WRITE (mp_debug,*) '       (bin,num,mass,melt) ', k,nsnow0(kz,k),qsnow0(kz,k),qsnowm0(kz,k)
           CALL wrf_debug(150, mp_debug)
        enddo
      endif
           DO K=1,K4
            MTSNOWI(K)= QSNOW0(KZ,K)-QSNOWM0(KZ,K)
            NTCIR1(K)=NSNOW0(KZ,K)
            MTCIR1(K)=QSNOW0(KZ,K)
            IF (MTSNOWI(K) < 0.0) THEN
             MTSNOWI(K) =0.0
             MTSNOWM(K)= QSNOW0(KZ,K)
            ENDIF
           ENDDO
          CALL MELTSNOW (K4,NTCIR1,MTCIR1,MTSNOWI,DMTSNOWM3,FQSM,       &
     &     DNTCIR2V,DMTCIR2V,DQSHC,ACIR,BCIR,CCIR,DCIR,ROA1,DT,         &
     &     ROA,P,TKE1,QVE1,DIFF,KG,VISC,LD,IBUG4,KZ)

      if (debug_flag .and. ibug4.eq.1) then
        WRITE (mp_debug,*) '   DEBUG MELT-2'
        CALL wrf_debug(150, mp_debug)
        DO K = 1, K4
           WRITE (mp_debug,*) '       (bin,num,mass,melt,rate) ', k,nsnow0(kz,k),qsnow0(kz,k),qsnowm0(kz,k),DMTSNOWM3(k)
           CALL wrf_debug(150, mp_debug)
        enddo
      endif

         ENDIF            !  endif for melting of snow flakes
!     
!     melting of graupel
!     
         IF (QGRA(KZ) > 0.0) THEN
           DO K=1,K4
            MTGRAI(K)= QGRA0(KZ,K)-QGRAM0(KZ,K)
            NTGRA1(K)=NGRA0(KZ,K)
            MTGRA1(K)=QGRA0(KZ,K)
            IF (MTGRAI(K) < 0.0) THEN
             MTGRAI(K) =0.0
             MTGRAM(K)= QGRA0(KZ,K)
            ENDIF           
           ENDDO
              
! xue add LD to meltgra to account for refreezing
          CALL MELTGRA (K4,NTGRA1,MTGRA1,MTGRAI,DMTGRAM4,FQGM,        &
     &         DNTGRA3V,DMTGRA3V,DQGRHC,AGRA,BGRA,CGRA,DGRA,DT,       &
     &         ROA,P,TKE1,QVE1,DIFF,KG,VISC,LD,ibug0)                   
         ENDIF            ! end if for graupel particles

          
         DO K=1,K4
          MTSNOWM(K)=MTSNOWM(K)+                                        &
     &         (DMTSNOWM1(K)+DMTSNOWM2(K))*CONST1+DMTSNOWM3(K)*DT
          IF (MTSNOWM(K).LT.0.0) MTSNOWM(K)=0.0
      if (debug_flag .and. MTSNOWM(K).ne.0.0) then
        WRITE (mp_debug,*) '   total MTSNOWM ', k, MTSNOWM(K)
        CALL wrf_debug(150, mp_debug)
      endif
     

          IF (MTSNOWM(K).GE.MELTS_THRES*MTCIR(K)) THEN ! the snow flakes have melted completly in the k-th bin
            MTC(K)=MTC(K)+MTCIR(K)
            NTC(K)=NTC(K)+NTCIR(K)
! xue question: the melting of the increase of MTSNOWM should be counted before, DMTC10 is overestimated by this way!
            DNTC10(K)=DNTC10(K)+NTCIR(K)/DT
            DMTC10(K)=DMTC10(K)+MTCIR(K)/DT
            DSMTCIR8(KZ) = DSMTCIR8(KZ) - MTCIR(K)/DT
            DSNTCIR8(KZ) = DSNTCIR8(KZ) - NTCIR(K)/DT
            IF (MTSNOWM(K).LT.MTCIR(K)) THEN                   ! xue question: should this be outside of the upper IF statement?
             DMTSNOWM3(K) = DMTSNOWM3(K) + (MTCIR(K)-MTSNOWM(K))/DT
             DSMTSNOWM4(KZ)=DSMTSNOWM4(KZ)+(MTCIR(K)-MTSNOWM(K))/DT
            ENDIF
            MTCIR(K)=0.0
            NTCIR(K)=0.0
            MTSNOWM(K)=0.0
! xue add shedding test here
          ELSE
           IF(MELT_SHED) THEN
           if(MTSNOWM(K).gt.1.e-40 .and. NTCIR(K).gt.eps) then 
            MEANMSWM=MTSNOWM(K)/NTCIR(K)
            MEANMSM=(MTCIR(K)-MTSNOWM(K))/NTCIR(K)
            if(MEANMSWM.lt.M(1)) goto 111
            DO KK=1, K
             if(MEANMSWM.lt.M(KK+1)) then
              DNTC11(KK)=DNTC11(KK)+NTCIR(K)/DT
              DMTC11(KK)=DMTC11(KK)+MTSNOWM(K)/DT
              DNTCIR10(K)=DNTCIR10(K)-NTCIR(K)/DT
              DMTCIR10(K)=DMTCIR10(K)-MTCIR(K)/DT
              goto 109
             end if
            ENDDO
109         continue
            DO KK=1, K
             if(MEANMSM.lt.M(KK+1)) then
              DNTCIR11(KK)=DNTCIR11(KK)+NTCIR(K)/DT
              DMTCIR11(KK)=DMTCIR11(KK)+(MTCIR(K)-MTSNOWM(K))/DT
              MTSNOWM(K)=0.0
              goto 111
             end if
            ENDDO
           end if     
           END IF
! xue finish shedded test
          ENDIF
111       continue
          MTGRAM(K)=MTGRAM(K)+DMTGRAM3(K)*CONST1+DMTGRAM4(K)*DT
          IF (MTGRAM(K).LT.0.0) MTGRAM(K)=0.0

          IF (MTGRAM(K) >= MELTG_THRES*MTGRA(K)) THEN
            NTC(K)=NTC(K)+NTGRA(K)
            MTC(K)=MTC(K)+MTGRA(K)
! xue question: the melting of the increase of MTGRAM should be counted before, DMTC10 is overestimated by this way!
            DNTC10(K)= DNTC10(K)+NTGRA(K)/DT
            DMTC10(K)= DMTC10(K)+MTGRA(K)/DT
! xue quesiton: should the following terms divided by DT?
!            DSMTGRA11(KZ) = DSMTGRA11(KZ) - MTGRA(K)
!            DSNTGRA11(KZ) = DSNTGRA11(KZ) - NTGRA(K)
            DSMTGRA11(KZ) = DSMTGRA11(KZ) - MTGRA(K)/DT
            DSNTGRA11(KZ) = DSNTGRA11(KZ) - NTGRA(K)/DT
            IF (MTGRAM(K) .LT. MTGRA(K)) THEN
             DMTGRAM4(K) = DMTGRAM4(K) + (MTGRA(K)-MTGRAM(K))/DT
             DSMTGRAM5(KZ)=DSMTGRAM5(KZ)+(MTGRA(K)-MTGRAM(K))/DT
            ENDIF
            NTGRA(K)=0.0
            MTGRA(K)=0.0
            MTGRAM(K)=0.0
! xue add shedded test here
          ELSE
           IF(MELT_SHED) THEN
           if(MTGRAM(K).gt.1.e-40 .and. NTGRA(K).gt.eps) then
            MEANMGWM=MTGRAM(K)/NTGRA(K)
            MEANMGM=(MTGRA(K)-MTGRAM(K))/NTGRA(K)
            if(MEANMGWM.lt.M(1)) goto 112
            DO KK=1, K
             if(MEANMGWM.lt.M(KK+1)) then
              DNTC12(KK)=DNTC12(KK)+NTGRA(K)/DT
              DMTC12(KK)=DMTC12(KK)+MTGRAM(K)/DT
              DNTGRA13(K)=DNTGRA13(K)-NTGRA(K)/DT
              DMTGRA13(K)=DMTGRA13(K)-MTGRA(K)/DT
              goto 117
             end if
            ENDDO
117         continue
            DO KK=1, K
             if(MEANMGM.lt.M(KK+1)) then
              DNTGRA14(KK)=DNTGRA14(KK)+NTGRA(K)/DT
              DMTGRA14(KK)=DMTGRA14(KK)+(MTGRA(K)-MTGRAM(K))/DT
              MTGRAM(K)=0.0
              goto 112
             end if 
            ENDDO 
           end if 
           END IF
! xue finish shedded test
          ENDIF
112       continue

!     
!     the pristine ice particles are supposed to melt immediately as the particles get into the 
!     melting zone
!     
          DNTCI10(K) = -NTCI(K)/DT
          DMTCI10(K) = -MTCI(K)/DT
          DNTC10(K) = DNTC10(K) - DNTCI10(K)
          DMTC10(K) = DMTC10(K) - DMTCI10(K)
          NTC(K) = NTC(K) + NTCI(K)
          MTC(K) = MTC(K) + MTCI(K)
          NTCI(K) = 0.0
          MTCI(K) = 0.0
         ENDDO
        ENDIF               ! endif for melting (tk> 273.15 )
        if (ibug0.eq.1) then
         write(98,*) 'after all micro t_tend,qv_tend',tten1,qvten1
        endif        

! xue add for shedding
        DO K=1,K4
         NTC(K)=NTC(K)+(DNTC11(K)+DNTC12(K))*DT
         MTC(K)=MTC(K)+(DMTC11(K)+DMTC12(K))*DT
         NTCIR(K)=NTCIR(K)+(DNTCIR10(K)+DNTCIR11(K))*DT
         MTCIR(K)=MTCIR(K)+(DMTCIR10(K)+DMTCIR11(K))*DT
         NTGRA(K)=NTGRA(K)+(DNTGRA13(K)+DNTGRA14(K))*DT
         MTGRA(K)=MTGRA(K)+(DMTGRA13(K)+DMTGRA14(K))*DT
        ENDDO

!     
!     sum of the production terms over the bins
!     
        DO K=1,K4
! xue add for shed
         dsntc11(KZ)=dsntc11(KZ)+dntc11(K)
         dsmtc11(KZ)=dsmtc11(KZ)+dmtc11(K)
         dsntc12(KZ)=dsntc12(KZ)+dntc12(K)
         dsmtc12(KZ)=dsmtc12(KZ)+dmtc12(K)
         dsntcir10(KZ)=dsntcir10(KZ)+dntcir10(K)
         dsmtcir10(KZ)=dsmtcir10(KZ)+dmtcir10(K)
         dsntcir11(KZ)=dsntcir11(KZ)+dntcir11(K)
         dsmtcir11(KZ)=dsmtcir11(KZ)+dmtcir11(K)
         dsntgra13(KZ)=dsntgra13(KZ)+dntgra13(K)
         dsmtgra13(KZ)=dsmtgra13(KZ)+dmtgra13(K)
         dsntgra14(KZ)=dsntgra14(KZ)+dntgra14(K)
         dsmtgra14(KZ)=dsmtgra14(KZ)+dmtgra14(K)
! xue
         dsntc0(KZ)=dsntc0(KZ)+dntc0(K)
         dsntc1(KZ)=dsntc1(KZ)+dntc1(K)*roa1
         dsntc1B(KZ)=dsntc1B(KZ)+SNGL(dntc1B(K))*roa1
         dsntc3(KZ)=dsntc3(KZ)+dntc3(K)
         dsntc4(KZ)=dsntc4(KZ)+dntc4(K)*roa1
         dsntc5(KZ)=dsntc5(KZ)+dntc5(K)*roa1
         dsntc6(KZ)=dsntc6(KZ)+dntc6(K)*roa1
         dsntc8(KZ)=dsntc8(KZ)+dntc8(K)*roa1
         dsntc8s(KZ)=dsntc8s(KZ)+dntc8s(K)*roa1
         dsntc10(KZ)=dsntc10(KZ)+dntc10(K) ! +(1-IDELTA1)*ROA1*(DNTCIR1(K))
         dsmtc0(KZ)=dsmtc0(KZ)+dmtc0(K)
         dsmtc1(KZ)=dsmtc1(KZ)+dmtc1(K)*roa1
         dsmtc1B(KZ)=dsmtc1B(KZ)+dmtc1B(K)*roa1
         dsmtc3(KZ)=dsmtc3(KZ)+dmtc3(K)
         dsmtc4(KZ)=dsmtc4(KZ)+dmtc4(K)*roa1
         dsmtc5(KZ)=dsmtc5(KZ)+dmtc5(K)*roa1
         dsmtc6(KZ)=dsmtc6(KZ)+dmtc6(K)*roa1
         dsmtc8(KZ)=dsmtc8(KZ)+dmtc8(K)*roa1
         dsmtc8s(KZ)=dsmtc8s(KZ)+dmtc8s(K)*roa1
         dsmtc10(KZ)=dsmtc10(KZ)+dmtc10(K)    
         dsntci0(KZ)=dsntci0(KZ)+dntci0(K)
         dsntci1(KZ)=dsntci1(KZ)+dntci1(K)
         dsntci3(KZ)=dsntci3(KZ)+dntci3(K)*roa1
         dsntci4(KZ)=dsntci4(KZ)+dntci4(K)
         dsntci5(KZ)=dsntci5(KZ)+eicic*dntci5(K)*roa1
         dsntci9(KZ)=dsntci9(KZ)+ERICIC*dntci9(K)*roa1
         dsntci10(KZ)=dsntci10(KZ)+dntci10(K)+                          &
     &              (1-IDELTA1)*DNTCI3(K)*ROA1
         dsmtci0(KZ)=dsmtci0(KZ)+dmtci0(K)
         dsmtci1(KZ)=dsmtci1(KZ)+dmtci1(K)
         dsmtci3(KZ)=dsmtci3(KZ)+dmtci3(K)*roa1
         dsmtci4(KZ)=dsmtci4(KZ)+dmtci4(K)
         dsmtci5(KZ)=dsmtci5(KZ)+eicic*dmtci5(K)*roa1
         dsmtci9(KZ)=dsmtci9(KZ)+ERICIC*dmtci9(K)*roa1
         dsmtci10(KZ)=dsmtci10(KZ)+dmtci10(K)+                          &
     &              (1-IDELTA1)*DMTCI3(K)*ROA1
         dsntcir1(KZ)=dsntcir1(KZ)+dntcir1(K)*roa1
         dsntcir2(KZ)=dsntcir2(KZ)+dntcir2(K)*roa1
         dsntcir4(KZ)=dsntcir4(KZ)+ericric*dntcir4(K)*roa1
         dsntcir5(KZ)=dsntcir5(KZ)+EICIC*dntcir5(K)*roa1
         dsntcir7(KZ)=dsntcir7(KZ)+ERICIC*dntcir7(K)*roa1
         dsmtcir1(KZ)=dsmtcir1(KZ)+dmtcir1(K)*roa1
         dsmtcir2(KZ)=dsmtcir2(KZ)+dmtcir2(K)*roa1
         dsmtcir4(KZ)=dsmtcir4(KZ)+ericric*dmtcir4(K)*roa1
         dsmtcir5(KZ)=dsmtcir5(KZ)+EICIC*dmtcir5(K)*roa1
         dsmtcir7(KZ)=dsmtcir7(KZ)+ERICIC*dmtcir7(K)*roa1
         IF (tz_old(KZ) .LT.T00) THEN
          DSNTRIME0(KZ) = DSNTRIME0(KZ) + DNTRIME0(K)
          DSMTRIME0(KZ) = DSMTRIME0(KZ) + DMTRIME0(K)
          DSNTRIME1(KZ) = DSNTRIME1(KZ) + DNTRIME1(K)*ROA1 !CONST1
          DSNTRIME2(KZ) = DSNTRIME2(KZ) + DNTRIME2(K)*ROA1 !CONST1
          DSNTRIME3(KZ) = DSNTRIME3(KZ) + ERICRIC*DNTRIME3(K)*ROA1 !CONST1
          DSNTRIME4(KZ) = DSNTRIME4(KZ) + ERICIC*DNTRIME4(K)*ROA1 !CONST1
          DSMTRIME1(KZ) = DSMTRIME1(KZ) + DMTRIME1(K)*ROA1 !CONST1
          DSMTRIME2(KZ) = DSMTRIME2(KZ) + DMTRIME2(K)*ROA1 !CONST1
          DSMTRIME3(KZ) = DSMTRIME3(KZ) + ERICRIC*DMTRIME3(K)*ROA1 !CONST1
          DSMTRIME4(KZ) = DSMTRIME4(KZ) + ERICIC*DMTRIME4(K)*ROA1 !CONST1
         ELSE
          DSMTSNOWM1(KZ) = DSMTSNOWM1(KZ) + DMTSNOWM1(K)*ROA1 !CONST1
          DSMTSNOWM2(KZ) = DSMTSNOWM2(KZ) + DMTSNOWM2(K)*ROA1 !CONST1
          DSMTSNOWM3(KZ) = DSMTSNOWM3(KZ) + DMTSNOWM3(K) !*DT
          DSMTGRAM3(KZ) = DSMTGRAM3(KZ) + DMTGRAM3(K)*ROA1 !CONST1
          DSMTGRAM4(KZ) = DSMTGRAM4(KZ) + DMTGRAM4(K) !*DT
         ENDIF
         dsntgra0(KZ)=dsntgra0(KZ)+dntgra0(K)
         dsntgra2(KZ)=dsntgra2(KZ)+dntgra2(K)*roa1
         dsntgra3(KZ)=dsntgra3(KZ)+dntgra3(K)*roa1
         dsntgra4(KZ)=dsntgra4(KZ)+dntgra4(K)
         dsntgra5(KZ)=dsntgra5(KZ)+dntgra5(K)*roa1
         dsmtgra0(KZ)=dsmtgra0(KZ)+dmtgra0(K)
         dsmtgra2(KZ)=dsmtgra2(KZ)+dmtgra2(K)*roa1
         dsmtgra3(KZ)=dsmtgra3(KZ)+dmtgra3(K)*roa1
         dsmtgra4(KZ)=dsmtgra4(KZ)+dmtgra4(K)
         dsmtgra5(KZ)=dsmtgra5(KZ)+dmtgra5(K)*roa1
        ENDDO

        CCN1(KZ) = CCN
        NIDEP1(KZ) = NIDEP0(KZ) + TENDEP* DT
        IF (CCN1(KZ).LT.0.0) CCN1(KZ) = 0.0
        IF (NIDEP1(KZ).LT.0.0) NIDEP1(KZ) = 0.0
 121   CONTINUE
!----+-----------------------------------------------------------------+

!       QMELT1 = -DQSHC - DQGRHC - DQHLHC + LF*DSMTCI10(KZ)
! the melting of less than 20% ice mass in partially melted particles should be counted
       QMELT1 = -(DQSHC + DQGRHC + DQHLHC) + LF*(DSMTCI10(KZ)-DSMTSNOWM4(KZ)-DSMTGRAM5(KZ))

!       QMELT2 = (-DSMTC10(KZ)+DSMTC6(KZ)+DSMTC8(KZ)+                   &
!     &           DSMTCIR1(KZ))*(tz_old(KZ)-T00)*CW
! xue: heat conduction of melted water (partially melted snow and graupel should be treated as well)
       QMELT2 = -(DSMTC10(KZ)-DSMTC8S(KZ))*(tz_old(KZ)-T00)*CW
!       QMELT2 = -(DSMTSNOWM3(KZ)+DSMTGRAM4(KZ))*(tz_old(KZ)-T00)*CW/DT
       QFREEZ = LF*(DSMTGRA0(KZ)+DSMTGRA3(KZ)+DSMTGRA4(KZ)+             &
     &           DSMTCI1(KZ)+DSMTCI4(KZ)-DSMTC5(KZ)-DSMTC6(KZ)+         &
     &           DSMTC9(KZ))
! the diffusion on graupel include that of water on graupel, need to adjust it
! evaporation from partially melted snow and graupel should be calculated and counted
       TTEN1 = TTEN1+(IDELTA1*QFREEZ+(1-IDELTA1)*(QMELT1+QMELT2)        &
!     &       +  LD*(dsmtci0(KZ)+dsmtgra10(KZ)))/CP
     &       +  LD*(dsmtci0(KZ)+IDELTA1*dsmtgra10(KZ)))/CP
!     &       +  LD*(dsmtci0(KZ)+IDELTA1*dsmtgra10(KZ)                   &
!     &       -   (1-IDELTA1)*(DSMTCI2(KZ)+DSMTCIR0(KZ))))/CP  ! these two effects have been accounted in cond!


       QVTEN1 = QVTEN1 - (dsmtci0(KZ)+dsmtgra10(KZ))
       if (ibug0.eq.1) then
        write(98,*) 'ist,kz',ist,kz
        write(98,*) 'qmelt1,qmelt2,qfreez,dsmtci0,dsmtgra10'
        write(98,*) qmelt1,qmelt2,qfreez,dsmtci0(kz),dsmtgra10(kz)
        write(98,*) 'tk,tk11,qv,qv11,idelta1'
        write(98,*) tk,tk11,qv(kz),qv11,idelta1
        write(98,*) 'DSMTSNOWM3,DSMTGRAM4,DSMTCI10,DSMTCI3'
        write(98,*) DSMTSNOWM3(KZ),DSMTGRAM4(KZ),DSMTCI10(KZ),          &
     &          DSMTCI3(KZ)
        write(98,*)'DSMTC10,DSMTC6,DSMTC8,DSMTCIR1'
        write(98,*)DSMTC10(KZ),DSMTC6(KZ),DSMTC8(KZ),DSMTCIR1(KZ)
        write(98,*) 'DSMTGRA0,DSMTGRA3,DSMTGRA4,DSMTCI1,DSMTCI4,DSMTC5, &
     &               DSMTC6,DSMTC9'
        write(98,*) DSMTGRA0(KZ),DSMTGRA3(KZ),DSMTGRA4(KZ),             &
     &     DSMTCI1(KZ),DSMTCI4(KZ),DSMTC5(KZ),DSMTC6(KZ),DSMTC9(KZ)
       endif 

       tz(kz) = tz_old(kz) + TTEN1*DT
       QV(KZ) = qv_old(kz) + QVTEN1*DT

       DO K=1,K4
         EPSC1 = EPSC*M(K)
         NCW1(KZ,K) = NCW1(KZ,K)+(NTC(K)-NCW0(KZ,K)+fo_nw(KZ,K))
         QCW1(KZ,K) = QCW1(KZ,K)+(MTC(K)-QCW0(KZ,K)+fo_qw(KZ,K))
         IF (NCW1(KZ,K).LE.EPSC.OR.QCW1(KZ,K).LE.EPSC1) THEN               
                  NCW1(KZ,K) = 0.0
                  QCW1(KZ,K) = 0.0                      
         ENDIF
         NICE1(KZ,K) = NICE1(KZ,K)+(NTCI(K)-NICE0(KZ,K)+fo_ni(KZ,K))
         QICE1(KZ,K) = QICE1(KZ,K)+(MTCI(K)-QICE0(KZ,K)+fo_qi(KZ,K))
         IF (NICE1(KZ,K).LE.EPSC.OR.QICE1(KZ,K).LE.EPSC1) THEN
                  NICE1(KZ,K) = 0.0
                  QICE1(KZ,K) = 0.0
         ENDIF
         NSNOW1(KZ,K) = NSNOW1(KZ,K)+(NTCIR(K)-NSNOW0(KZ,K)+fo_ns(KZ,K))
         QSNOW1(KZ,K) = QSNOW1(KZ,K)+(MTCIR(K)-QSNOW0(KZ,K)+fo_qs(KZ,K))
         IF (NSNOW1(KZ,K).LE.EPSC.OR.QSNOW1(KZ,K).LE.EPSC1) THEN
                  NSNOW1(KZ,K) = 0.0
                  QSNOW1(KZ,K) = 0.0
         ENDIF
         NGRA1(KZ,K) = NGRA1(KZ,K)+(NTGRA(K)-NGRA0(KZ,K)+fo_ng(KZ,K))
         QGRA1(KZ,K) = QGRA1(KZ,K)+(MTGRA(K)-QGRA0(KZ,K)+fo_qg(KZ,K))
         IF (NGRA1(KZ,K).LE.EPSC.OR.QGRA1(KZ,K).LE.EPSC1) THEN
                  NGRA1(KZ,K) = 0.0
                  QGRA1(KZ,K) = 0.0
         ENDIF 
         IF (tz_old(KZ).LT.T00) THEN
           NSNOWR1(KZ,K)=NSNOWR1(KZ,K)+DNTRIME0(K)+(DNTRIME1(K)+        &
     &       DNTRIME2(K)+ERICRIC*DNTRIME3(K)+ERICIC*DNTRIME4(K))*CONST1 &
     &       + fo_nsr(KZ,K)
           QSNOWR1(KZ,K)=QSNOWR1(KZ,K)+DMTRIME0(K)+(DMTRIME1(K)+        &
     &       DMTRIME2(K)+ERICRIC*DMTRIME3(K)+ERICIC*DMTRIME4(K))*CONST1 &
     &       + fo_qsr(KZ,K)
           IF (NSNOWR1(KZ,K).LE.EPSC.OR.QSNOWR1(KZ,K).LE.EPSC1) THEN
                  NSNOWR1(KZ,K) = 0.0
                  QSNOWR1(KZ,K) = 0.0
           ENDIF
           IF (NSNOWR1(KZ,K).GT.NSNOW1(KZ,K)) THEN
             NSNOWR1(KZ,K)=NSNOW1(KZ,K)
           ENDIF
           IF (QSNOWR1(KZ,K).GT.QSNOW1(KZ,K)) THEN
             QSNOWR1(KZ,K)=QSNOW1(KZ,K)
           ENDIF
         ELSE
           NSNOWR1(KZ,K)=0.0
           QSNOWR1(KZ,K)=0.0
         ENDIF
         IF (tz_old(KZ).LT.T00) THEN
          QSNOWM1(KZ,K)=0.0
          QGRAM1(KZ,K)=0.0 
!     transfer of the rimed snow flakes to the graupel if the rimed water mass ratio is larger than the rimthres
          FQ1=0.0
          IF (QSNOW1(KZ,K).GT.0.0) THEN
           FQ1=QSNOWR1(KZ,K)/QSNOW1(KZ,K)
          ENDIF
          FN1=0.0
          IF (NSNOW1(KZ,K).GT.0.0) THEN
           FN1=NSNOWR1(KZ,K)/NSNOW1(KZ,K)
          ENDIF
          IF (FQ1.GT.RIMTHRES) THEN
           DMTGRA7(K)=FN1*QSNOW1(KZ,K)
           DNTGRA7(K)=NSNOWR1(KZ,K)
           DMTCIR6(K)=-DMTGRA7(K)
           DNTCIR6(K)=-DNTGRA7(K)
           DNTRIME5(K)=-NSNOWR1(KZ,K)
           DMTRIME5(K)=-QSNOWR1(KZ,K)
           NGRA1(KZ,K)=NGRA1(KZ,K)+DNTGRA7(K)
           QGRA1(KZ,K)=QGRA1(KZ,K)+DMTGRA7(K)
           NSNOW1(KZ,K)=NSNOW1(KZ,K)+DNTCIR6(K)
           QSNOW1(KZ,K)=QSNOW1(KZ,K)+DMTCIR6(K)
           NSNOWR1(KZ,K)=0.0
           QSNOWR1(KZ,K)=0.0
           DSMTGRA7(KZ)=DSMTGRA7(KZ)+DMTGRA7(K)
           DSNTGRA7(KZ)=DSNTGRA7(KZ)+DNTGRA7(K)
           DSMTCIR6(KZ)=DSMTCIR6(KZ)+DMTCIR6(K)
           DSNTCIR6(KZ)=DSNTCIR6(KZ)+DNTCIR6(K)
           DSNTRIME5(KZ)=DSNTRIME5(KZ)+DNTRIME5(K)
           DSMTRIME5(KZ)=DSMTRIME5(KZ)+DMTRIME5(K)
          ENDIF 
         ELSE 
         QSNOWM1(KZ,K)=QSNOWM1(KZ,K)+(MTSNOWM(K)-QSNOWM0(KZ,K)+         &
     &      fo_qsm(KZ,K))
         QGRAM1(KZ,K)=QGRAM1(KZ,K)+(MTGRAM(K)-QGRAM0(KZ,K)+fo_qgm(KZ,K))
 
          IF (QSNOWM1(KZ,K) .GT. QSNOW1(KZ,K)) THEN
           QSNOWM1(KZ,K) = QSNOW1(KZ,K)
          ENDIF
          IF (QSNOWM1(KZ,K).LT.0.0) THEN
           QSNOWM1(KZ,K)=0.0
          ENDIF
          IF (QGRAM1(KZ,K) .GT. QGRA1(KZ,K)) THEN
           QGRAM1(KZ,K) = QGRA1(KZ,K)
          ENDIF
          IF (QGRAM1(KZ,K).LT.0.0) THEN
           QGRAM1(KZ,K)=0.0
          ENDIF
         ENDIF
        ENDDO
        QGRA(KZ)=0.0
        QSNOW(KZ)=0.0
        QL(KZ)=0.0
        DO K=1,K4
         QGRA(KZ)=QGRA(KZ)+QGRA1(KZ,K)
         QSNOW(KZ)=QSNOW(KZ)+QSNOW1(KZ,K)
         QL(KZ)=QL(KZ)+QCW1(KZ,K) 
        ENDDO

! conversion rates begin
        DNWZ_ACTV(KZ) =dsntc0(KZ)
        DNWZ_COAG(KZ) =dsntc1(KZ)
        DNWZ_BRUP(KZ) =dsntc1b(KZ)
        DNIZ_COLL(KZ) =dsntci5(KZ)+dsntci9(KZ)+dsntcir4(KZ)+            &
     &                 dsntcir5(KZ)+dsntcir7(KZ)
        DMWZ_FRML(KZ) =dsmtc10(KZ)-(dsmtci4(KZ)+dsmtgra4(KZ)+dsmtgra0(KZ)+dsmtci1(KZ))
        DMWIZ_MELT(KZ)=(DSMTSNOWM3(KZ)+DSMTGRAM4(KZ)) !/DT
        DMWIZ_DIFF(KZ)=DMWIZ_DIFF(KZ)+DSMTRIME0(KZ)
        DMWZ_RIME(KZ) =dsmtc5(KZ)+dsmtc6(KZ)+dsmtc8(KZ)+dsmtc8s(KZ)
        DNWZ_SHED(KZ) =dsntc8s(kz)
!        DMGZ_RIME(KZ) =dsmtci8(KZ)+dsmtcir6(KZ)
        DMGZ_RIME(KZ) =dsmtgra2(KZ)+DSMTGRA3(kz)+dsmtgra7(KZ)+dsmtgra5(KZ) !+          &
!     &                 DSMTGRA3(KZ)
! conversion rates end

       if (ibug0.eq.1) then
         write(98,*) 'at end of the main loop tk,tk1', tk,tz_old(KZ)
        endif
 100  CONTINUE

         errseggr=0.0
         errseggr1=0.0
         errseggr2=0.0
         errseggr3=0.
         errseggr4=0.0
         errseggr5=0.0
         errseggr6=0.0
      DSMTC6MAX=0.0
      RIMPDIFF1MAX=0.0 
      KZRDF1=1
      KZRDF2=1
        DO KZ =1,NZ
         RIMPDIFF1(KZ)=-1.0
         IF (DSMTCIR0(KZ).GT.0) THEN
          RIMPDIFF1(KZ)=-0.6
          IF (ABS(DSMTC6(KZ)).GT.0.0) THEN
            RIMPDIFF1(KZ)=ABS(DSMTC6(KZ))/(DSMTCIR0(KZ)+                &
     &                    ABS(DSMTC6(KZ)))
          ENDIF         
         ENDIF
         IF (ABS(DSMTCIR0(KZ)) .GT. errseggr6) THEN
            errseggr6=ABS(DSMTCIR0(KZ))
            KZRDF2=KZ
         ENDIF
         IF (RIMPDIFF1(KZ).GT.RIMPDIFF1MAX) THEN
            RIMPDIFF1MAX=RIMPDIFF1(KZ)
            KZRDF1=KZ
         ENDIF
         errseggr2=abs(dsmtgram0(kz)-dsmtgra10(kz))
         if (errseggr2.gt.errseggr1) then
           errseggr1=errseggr2
           kzerr1=kz
         endif
      DELTAV0 = DZ(KZ)*DX*DX*RHOA(KZ) ! xue add *DX*RHOA
      DELTAV1 = DELTAV0*DT
!         DELTAV1=DELTAV*RHOA(KZ)
         IF (KZ.eq.1.OR.KZ.EQ.NZ) DELTAV1 =DELTAV1/2.
!     DELTAV=DELTAV1/DT
         TDSNTC0=TDSNTC0 + DSNTC0(KZ)*DELTAV1
         TDSNTC1=TDSNTC1 + DSNTC1(KZ)*DELTAV1
         TDSNTC1B=TDSNTC1B + DSNTC1B(KZ)*DELTAV1
         TDSNTC2=TDSNTC2 + DSNTC2(KZ)*DELTAV1
         TDSNTC3=TDSNTC3 + DSNTC3(KZ)*DELTAV1
         TDSNTC4=TDSNTC4 + DSNTC4(KZ)*DELTAV1
         TDSNTC5=TDSNTC5 + DSNTC5(KZ)*DELTAV1
         TDSNTC6=TDSNTC6 + DSNTC6(KZ)*DELTAV1
         TDSNTC8=TDSNTC8 + DSNTC8(KZ)*DELTAV1
         TDSNTC8S=TDSNTC8S + DSNTC8S(KZ)*DELTAV1
         TDSNTC10=TDSNTC10 + DSNTC10(KZ)*DELTAV1
         TDSMTC0=TDSMTC0 + DSMTC0(KZ)*DELTAV1
         TDSMTC1=TDSMTC1 + DSMTC1(KZ)*DELTAV1
         TDSMTC1B=TDSMTC1B + DSMTC1B(KZ)*DELTAV1
         TDSMTC2=TDSMTC2 + DSMTC2(KZ)*DELTAV1
         TDSMTC3=TDSMTC3 + DSMTC3(KZ)*DELTAV1
         TDSMTC4=TDSMTC4 + DSMTC4(KZ)*DELTAV1
         TDSMTC5=TDSMTC5 + DSMTC5(KZ)*DELTAV1
         TDSMTC6=TDSMTC6 + DSMTC6(KZ)*DELTAV1
         TDSMTC8=TDSMTC8 + DSMTC8(KZ)*DELTAV1
         TDSMTC8S=TDSMTC8S + DSMTC8S(KZ)*DELTAV1
         TDSMTC9=TDSMTC9 + DSMTC9(KZ)*DELTAV1 
         TDSMTC10=TDSMTC10 + DSMTC10(KZ)*DELTAV1
         TDSNTCI0=TDSNTCI0 + DSNTCI0(KZ)*DELTAV1
         TDSNTCI1=TDSNTCI1 + DSNTCI1(KZ)*DELTAV1
         TDSNTCI2=TDSNTCI2 + DSNTCI2(KZ)*DELTAV1
         TDSNTCI3=TDSNTCI3 + DSNTCI3(KZ)*DELTAV1
         TDSNTCI4=TDSNTCI4 + DSNTCI4(KZ)*DELTAV1
         TDSNTCI5=TDSNTCI5 + DSNTCI5(KZ)*DELTAV1
         TDSNTCI6=TDSNTCI6 + DSNTCI6(KZ)*DELTAV1
         TDSNTCI9=TDSNTCI9 + DSNTCI9(KZ)*DELTAV1
         TDSNTCI10=TDSNTCI10 + DSNTCI10(KZ)*DELTAV1
         TDSNTCI11=TDSNTCI11 + DSNTCI11(KZ)*DELTAV1
         TDSMTCI0=TDSMTCI0 + DSMTCI0(KZ)*DELTAV1
         TDSMTCI1=TDSMTCI1 + DSMTCI1(KZ)*DELTAV1
         TDSMTCI2=TDSMTCI2 + DSMTCI2(KZ)*DELTAV1
         TDSMTCI3=TDSMTCI3 + DSMTCI3(KZ)*DELTAV1
         TDSMTCI4=TDSMTCI4 + DSMTCI4(KZ)*DELTAV1
         TDSMTCI5=TDSMTCI5 + DSMTCI5(KZ)*DELTAV1
         TDSMTCI6=TDSMTCI6 + DSMTCI6(KZ)*DELTAV1
         TDSMTCI9=TDSMTCI9 + DSMTCI9(KZ)*DELTAV1
         TDSMTCI10=TDSMTCI10 + DSMTCI10(KZ)*DELTAV1
         TDSMTCI11=TDSMTCI11 + DSMTCI11(KZ)*DELTAV1
         TDSNTCIR0=TDSNTCIR0 + DSNTCIR0(KZ)*DELTAV1
         TDSNTCIR1=TDSNTCIR1 + DSNTCIR1(KZ)*DELTAV1
         TDSNTCIR2=TDSNTCIR2 + DSNTCIR2(KZ)*DELTAV1
         TDSNTCIR4=TDSNTCIR4 + DSNTCIR4(KZ)*DELTAV1
         TDSNTCIR5=TDSNTCIR5 + DSNTCIR5(KZ)*DELTAV1
         TDSNTCIR6=TDSNTCIR6 + DSNTCIR6(KZ)*DELTAV0
         TDSNTCIR7=TDSNTCIR7 + DSNTCIR7(KZ)*DELTAV1
         TDSNTCIR8=TDSNTCIR8 + DSNTCIR8(KZ)*DELTAV1
         TDSNTCIR9=TDSNTCIR9 + DSNTCIR9(KZ)*DELTAV1
         TDSMTCIR0=TDSMTCIR0 + DSMTCIR0(KZ)*DELTAV1
         TDSMTCIR1=TDSMTCIR1 + DSMTCIR1(KZ)*DELTAV1
         TDSMTCIR2=TDSMTCIR2 + DSMTCIR2(KZ)*DELTAV1
         TDSMTCIR4=TDSMTCIR4 + DSMTCIR4(KZ)*DELTAV1
         TDSMTCIR5=TDSMTCIR5 + DSMTCIR5(KZ)*DELTAV1
         TDSMTCIR6=TDSMTCIR6 + DSMTCIR6(KZ)*DELTAV0
         TDSMTCIR7=TDSMTCIR7 + DSMTCIR7(KZ)*DELTAV1
         TDSMTCIR8=TDSMTCIR8 + DSMTCIR8(KZ)*DELTAV1
         TDSMTCIR9=TDSMTCIR9 + DSMTCIR9(KZ)*DELTAV1
         TDSNTRIME0 = TDSNTRIME0 + DSNTRIME0(KZ)*DELTAV1
         TDSMTRIME0 = TDSMTRIME0 + DSMTRIME0(KZ)*DELTAV1
         TDSNTRIME1 = TDSNTRIME1 + DSNTRIME1(KZ)*DELTAV1 
         TDSNTRIME2 = TDSNTRIME2 + DSNTRIME2(KZ)*DELTAV1
         TDSNTRIME3 = TDSNTRIME3 + DSNTRIME3(KZ)*DELTAV1
         TDSNTRIME4 = TDSNTRIME4 + DSNTRIME4(KZ)*DELTAV1
         TDSNTRIME5 = TDSNTRIME5 + DSNTRIME5(KZ)*DELTAV0
         TDSMTRIME1 = TDSMTRIME1 + DSMTRIME1(KZ)*DELTAV1
         TDSMTRIME2 = TDSMTRIME2 + DSMTRIME2(KZ)*DELTAV1
         TDSMTRIME3 = TDSMTRIME3 + DSMTRIME3(KZ)*DELTAV1
         TDSMTRIME4 = TDSMTRIME4 + DSMTRIME4(KZ)*DELTAV1
         TDSMTRIME5 = TDSMTRIME5 + DSMTRIME5(KZ)*DELTAV0
         
         TDSMTSNOWM0 = TDSMTSNOWM0 + DSMTSNOWM0(KZ)*DELTAV1
         TDSMTSNOWM1 = TDSMTSNOWM1 + DSMTSNOWM1(KZ)*DELTAV1
         TDSMTSNOWM2 = TDSMTSNOWM2 + DSMTSNOWM2(KZ)*DELTAV1
         TDSMTSNOWM3 = TDSMTSNOWM3 + DSMTSNOWM3(KZ)*DELTAV1
         TDSMTSNOWM4 = TDSMTSNOWM4 + DSMTSNOWM4(KZ)*DELTAV1
         TDSMTGRAM0 = TDSMTGRAM0 + DSMTGRAM0(KZ)*DELTAV1
         TDSMTGRAM3 = TDSMTGRAM3 + DSMTGRAM3(KZ)*DELTAV1
         TDSMTGRAM4 = TDSMTGRAM4 + DSMTGRAM4(KZ)*DELTAV1
         TDSMTGRAM5 = TDSMTGRAM5 + DSMTGRAM5(KZ)*DELTAV1
         TDSNTGRA0=TDSNTGRA0 + DSNTGRA0(KZ)*DELTAV1
         TDSNTGRA2=TDSNTGRA2 + DSNTGRA2(KZ)*DELTAV1
         TDSNTGRA3=TDSNTGRA3 + DSNTGRA3(KZ)*DELTAV1
         TDSNTGRA4=TDSNTGRA4 + DSNTGRA4(KZ)*DELTAV1
         TDSNTGRA5=TDSNTGRA5 + DSNTGRA5(KZ)*DELTAV1
         TDSNTGRA7=TDSNTGRA7 + DSNTGRA7(KZ)*DELTAV0
         TDSNTGRA10=TDSNTGRA10 + DSNTGRA10(KZ)*DELTAV1
         TDSNTGRA11=TDSNTGRA11 + DSNTGRA11(KZ)*DELTAV1
         TDSNTGRA12=TDSNTGRA12 + DSNTGRA12(KZ)*DELTAV1
         TDSMTGRA0=TDSMTGRA0 + DSMTGRA0(KZ)*DELTAV1
         TDSMTGRA2=TDSMTGRA2 + DSMTGRA2(KZ)*DELTAV1
         TDSMTGRA3=TDSMTGRA3 + DSMTGRA3(KZ)*DELTAV1
         TDSMTGRA4=TDSMTGRA4 + DSMTGRA4(KZ)*DELTAV1
         TDSMTGRA5=TDSMTGRA5 + DSMTGRA5(KZ)*DELTAV1
         TDSMTGRA7=TDSMTGRA7 + DSMTGRA7(KZ)*DELTAV0
         TDSMTGRA10=TDSMTGRA10 + DSMTGRA10(KZ)*DELTAV1
         TDSMTGRA11=TDSMTGRA11 + DSMTGRA11(KZ)*DELTAV1
         TDSMTGRA12=TDSMTGRA12 + DSMTGRA12(KZ)*DELTAV1
! xue add for shedding
         TDSNTC11=TDSNTC11 + DSNTC11(KZ)*DELTAV1
         TDSNTC12=TDSNTC12 + DSNTC12(KZ)*DELTAV1
         TDSNTCIR10=TDSNTCIR10 + DSNTCIR10(KZ)*DELTAV1
         TDSNTCIR11=TDSNTCIR11 + DSNTCIR11(KZ)*DELTAV1
         TDSNTGRA13=TDSNTGRA13 + DSNTGRA13(KZ)*DELTAV1
         TDSNTGRA14=TDSNTGRA14 + DSNTGRA14(KZ)*DELTAV1
         TDSMTC11=TDSMTC11 + DSMTC11(KZ)*DELTAV1
         TDSMTC12=TDSMTC12 + DSMTC12(KZ)*DELTAV1
         TDSMTCIR10=TDSMTCIR10 + DSMTCIR10(KZ)*DELTAV1
         TDSMTCIR11=TDSMTCIR11 + DSMTCIR11(KZ)*DELTAV1
         TDSMTGRA13=TDSMTGRA13 + DSMTGRA13(KZ)*DELTAV1
         TDSMTGRA14=TDSMTGRA14 + DSMTGRA14(KZ)*DELTAV1
       ENDDO
      END SUBROUTINE mp_detailed

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      SUBROUTINE mp_detailed_pg (pz, rhoa, tz, tz_old, qv, qv_old, dz, dx, &
     &     ncw0,ncw1,qcw0,qcw1,nice0,nice1,qice0,qice1,                 &
     &     nsnow0,nsnow1,qsnow0,qsnow1,nsnowr0,nsnowr1,qsnowr0,qsnowr1, &
     &     qsnowm0,qsnowm1,ngra0,ngra1,qgra0,qgra1,qgram0,qgram1,       &
     &     ccn1,ccn0,nidep1,nidep0,                                     &
     &     pptrain,pptice,pptsnow,pptgra,pptsnowm,pptgram,              &
     &     dt, K4, nz, ist, ii, jj)

      IMPLICIT NONE   

      INTEGER, INTENT(IN) :: K4, nz, ist, ii, jj
      REAL, INTENT(IN) :: DT, DX
      REAL, INTENT(INOUT) :: pptrain,pptice,pptsnow,pptgra,pptsnowm,    &
     &           pptgram

      REAL, INTENT(IN), DIMENSION(NZ) :: pz, rhoa, tz_old, qv_old, dz
      REAL, INTENT(INOUT), DIMENSION(NZ) :: tz, qv
      REAL, INTENT(INOUT), DIMENSION(NZ, K4) ::                         &
     &           qcw0, qcw1, qice0, qice1, qsnow0, qsnow1, qgra0, qgra1 &
     &          ,qsnowr0, qsnowr1, qsnowm0, qsnowm1, qgram0, qgram1     &
     &          ,ncw0, ncw1, nice0, nice1, nsnow0, nsnow1, ngra0, ngra1 &
     &          ,nsnowr0, nsnowr1
      REAL, INTENT(INOUT), DIMENSION(NZ) :: ccn0, ccn1, nidep0, nidep1

!
!+---+  LOCAL VARS
!

      REAL, DIMENSION(NZ) :: QL,NL, QICE,NICE, QSNOW,NSNOW, QGRA,NGRA
      REAL*8, DIMENSION(NZ,K4) :: FN_OLD, FQ_OLD, FQSNOWM, FQGRAM
      REAL*8, DIMENSION(K4) :: FN, FQ, FQSM, FQGM

      REAL, DIMENSION(K4,NZ) :: SCR4N, SCR4Q
      REAL, DIMENSION(NZ,K4) :: fo_nw,fo_qw,fo_ni,fo_qi,fo_ns,fo_qs,    &
     &                          fo_ng,fo_qg,fo_nsr,fo_qsr,fo_qsm,fo_qgm
      REAL, DIMENSION(K4,NZ) :: vt_c, vt_i, vt_s, vt_g
      REAL, DIMENSION(NZ) :: sed_n, sed_q

      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     AC,BC,CC,DC, ACI,BCI,CCI,DCI, ACIR,BCIR,CCIR,DCIR,           &
     &     AGRA,BGRA,CGRA,DGRA, MTCIR1,NTCIR1,MTGRA1,NTGRA1,NTC1,MTC1  ! NTC1 and MTC1 were added by IG to avoid the overestimation of drop collection

      INTEGER K, KZ, IPRT, ITC, KSEG, IDELTA1, JUMP, ISTEP, NSTEP, n,   &
     &        nzstep,ksed1,KMIN,KMAX,KMIN1,KMAX1,KMINAE1,KMAXAE1,KTOP,  &
     &        KMINGRA,KMAXGRA,KMINCI,KMAXCI,KMINCIR,KMAXCIR,KS,         &
     &        IBUG0,IBUG01,IBUG1,IBUG2,IBUG3,IBUG4,IBUG5,ISMAX,         &
     &        KSMAX, KK ! xue add KK for shedding

! these variables are used because of the small time step for the graupel - water drop coag.
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,       &
     &     MTGRAMT,NTCT,MTCT
      DOUBLE PRECISION, DIMENSION (K4) :: DNTC8T,DMTC8T,DNTC8ST,DMTC8ST,&
     &    DNTGRA3T,DMTGRA3T,DNTGRA3VT,DMTGRA3VT,DMTGRAM3T
      REAL*8 CONST1T
      REAL*8, DIMENSION(K4) :: FQGMT
      REAL NLT,NGRAT,DTGRWAT,DSNTCI6T

! these variables are added because of the small time step for water drop coag.
      DOUBLE PRECISION, DIMENSION (K4) :: DNTC1T,DMTC1T,DNTC1BT,DMTC1BT
      REAL DTDRP

!.. dummies
      integer ierr1,ierr2,kzerr1,kzerr2

!.. bin production terms
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     DNTC0,DMTC0,DNTC1,DMTC1,DNTC1B,                              &
     &     DMTC1B,DNTC3,DMTC3,DNTC4,DMTC4,                              &
     &     DNTC5,DMTC5,DNTC6,DMTC6,                                     &
     &     DNTC8,DMTC8,DNTC10,DMTC10,                                   &
     &     DNTC8S,DMTC8S,                                               & ! added for collision shedding
     &     DNTCI0,DMTCI0,DNTCI1,DMTCI1,DNTCI3,                          &
     &     DMTCI3,DNTCI4,DMTCI4,DNTCI5,DMTCI5,                          &
     &     DNTCI9,DMTCI9,DNTCI10,DMTCI10,                               &
     &     DNTCI11,DMTCI11,                                             &
     &     DNTCIR1,DMTCIR1,DNTCIR2,DMTCIR2,                             &
     &     DNTCIR2V,DMTCIR2V,DNTCIR4,DMTCIR4,                           &
     &     DNTCIR5,DMTCIR5,DNTCIR6,DMTCIR6,                             &
     &     DNTCIR7,DMTCIR7,DNTCIR8,DMTCIR8,                             &
     &     DNTCIR9,DMTCIR9,                                             &
     &     DNTGRA0,DMTGRA0,DNTGRA2,DMTGRA2,                             &
     &     DNTGRA3,DMTGRA3,DNTGRA3V,DMTGRA3V,                           &
     &     DNTGRA4,DMTGRA4,DNTGRA5,DMTGRA5,                             &
     &     DNTGRA7,DMTGRA7,                                             &
     &     DNTGRA11,DMTGRA11,DNTGRA12,DMTGRA12,                         &
     &     DMTRIME0,DNTRIME0,DMTRIME1,DNTRIME1,                         &
     &     DMTRIME2,DNTRIME2,DMTRIME3,DNTRIME3,                         &
     &     DMTRIME4,DNTRIME4,DMTRIME5,DNTRIME5,                         &
     &     DMTSNOWM0,DMTSNOWM1,DMTSNOWM2,DMTSNOWM3,                     &
     &     DMTSNOWM4,DMTGRAM0,DMTGRAM3,DMTGRAM4,                        &
     &     DMTGRAM5

! xue add for shedding
      DOUBLE PRECISION, DIMENSION (K4) ::                               &
     &     DNTC11,DMTC11,DNTC12,DMTC12,                                 &
     &     DNTCIR10,DMTCIR10,DNTCIR11,DMTCIR11,                         &
     &     DNTGRA13,DMTGRA13,DNTGRA14,DMTGRA14

!.. sum of bin production terms (column in vertical)
      REAL, DIMENSION (NZ) ::                                           &
     &     DSNTC0,DSMTC0,DSNTC1,DSMTC1,DSNTC1B,                         &
     &     DSMTC1B,DSNTC2,DSMTC2,DSNTC3,DSMTC3,DSNTC4,DSMTC4,           & ! N,M2 added
     &     DSNTC5,DSMTC5,DSNTC6,DSMTC6,                                 &
     &     DSNTC8,DSMTC8,DSNTC8S,DSMTC8S,DSMTC9,DSNTC10,DSMTC10,        & ! M9 added
     &     DSNTCI0,DSMTCI0,DSNTCI1,DSMTCI1,DSNTCI2,DSMTCI2,DSNTCI3,     & ! N,M2 added
     &     DSMTCI3,DSNTCI4,DSMTCI4,DSNTCI5,DSMTCI5,DSNTCI6,DSMTCI6,     & ! N,M6 added
     &     DSNTCI9,DSMTCI9,DSNTCI10,DSMTCI10,                           &
     &     DSNTCI11,DSMTCI11,                                           &
     &     DSNTCIR0,DSMTCIR0,DSNTCIR1,DSMTCIR1,DSNTCIR2,DSMTCIR2,       & ! N,M0 added
     &     DSNTCIR2V,DSMTCIR2V,DSNTCIR4,DSMTCIR4,                       &
     &     DSNTCIR5,DSMTCIR5,DSNTCIR6,DSMTCIR6,                         &
     &     DSNTCIR7,DSMTCIR7,DSNTCIR8,DSMTCIR8,                         &
     &     DSNTCIR9,DSMTCIR9,                                           &
     &     DSNTGRA0,DSMTGRA0,DSNTGRA2,DSMTGRA2,                         &
     &     DSNTGRA3,DSMTGRA3,DSNTGRA3V,DSMTGRA3V,                       &
     &     DSNTGRA4,DSMTGRA4,DSNTGRA5,DSMTGRA5,                         &
     &     DSNTGRA7,DSMTGRA7,DSNTGRA10,DSMTGRA10,                       & ! N,M10 added ! diffusional growth
     &     DSNTGRA11,DSMTGRA11,DSNTGRA12,DSMTGRA12,                     &
     &     DSMTRIME0,DSNTRIME0,DSMTRIME1,DSNTRIME1,                     &
     &     DSMTRIME2,DSNTRIME2,DSMTRIME3,DSNTRIME3,                     &
     &     DSMTRIME4,DSNTRIME4,DSMTRIME5,DSNTRIME5,                     &
     &     DSMTSNOWM0,DSMTSNOWM1,DSMTSNOWM2,DSMTSNOWM3,                 &
     &     DSMTSNOWM4,DSMTGRAM0,DSMTGRAM3,DSMTGRAM4,                    &
     &     DSMTGRAM5

! xue add for shedding
      REAL, DIMENSION (NZ) ::                                           &
     &     DSNTC11,DSMTC11,DSNTC12,DSMTC12,                             &
     &     DSNTCIR10,DSMTCIR10,DSNTCIR11,DSMTCIR11,                     &
     &     DSNTGRA13,DSMTGRA13,DSNTGRA14,DSMTGRA14

      REAL RIMPDIFF1(NZ)

!     ntc(i) = concentration of the clear drops in i-th interval     (1/kg)
!     mtc(i) = mixing ratio of the clear drops in i-th interval      (kg/kg)
!     ntci(i) = concentration of the ice crystals in i-th interval     (1/kg)
!     mtci(i) = mixing ratio of the ice crystals in i-th interval      (kg/kg)
!     ntcir(i) = concentration of the snow flake crystals in i-th interval     (1/kg)
!     mtcir(i) = mixing ratio of the snow flake crystals in i-th interval      (kg/kg)
!     mtsnowr(i)= mixing ratio of the rimed water on the surface of the pure ice in i-th interval
!     mtsnown(i)= number concentration of the snow flakes have been collected at least one super cooled drops
!     mtsnowm(i)= mixing ratio of the melted water on surface of the snow flakes
!     mtsnowi(i)= mixing ratio of the solid ice in the melted snow flakes
!     ntgra(i)= number concentration of the graupel particles in the k-th bin
!     mtgra(i)= mixing ratio of the graupel particles in the  k-th bin
!     mtgram(i)= mixing ratio of the melted water on the graupel particles in the k-th bin
!     mtgrai(i)= mixing ratio of the solid ice in the melted graupel in the k-th bin  
!     nicont= concentration of active contact nuclei
!     nidep= concentration of active condensation-freezing and deposition nuclei
!     ccn= concentration of the active condensation nuclei

!     dntc0(i),dmtc0(i)= change of the conc.and mixing r. due to wapor diff. on CCN (aerosol activation)
!     dntc1(i)= change of the concentration due to the self coag.
!     dmtc1(i)= change of the mixing ratio due to the self coag.
!     dntc1b(i)= change of the concentration due to the collision induced break up
!     dmtc1b(i)= change of the mixing ratio due to the collision induced break up
!!!!!     there should be number and mass change due to freezing of droplets.
!     dntc3(i)= change of the concentration due to the collection of aerosol part.(Brownian +phoretic)
!     dmtc3(i)= change of the mixing ratio due to the collection of aerosol part. (Brownian +phoretic)
!     dntc4(i)= change of the concentration due to the collection of aerosol part.(gravitational) contact freezing
!     dmtc4(i)= change of the mixing ratio due to the collection of aerosol part. (gravitational) contact freezing
!     dntc5(i)= decrease of the drop concentration due to the collision with pristine ice
!     dmtc5(i)= decrease of the mixing ratio due to the collision with pristiner ice
!     dntc6(i)= decrease of the drop concentration due to the collision with snow flake
!     dmtc6(i)= decrease of the mixing ratio due to the collision with snow flake 
!     dntc8(i)= change of concentration of drops due to the caogulation of drop and high density graupel p
!     dmtc8(i)=  change of mixing ratio of drops due to the caogulation of drop and high density graupel p.
!     dntc8s(i)= change of concentration of drops  due to collision induced shedding 
!     dmtc8s(i)=  change of mixing ratio of drops due to collision induced shedding 
!     dntc10(i)=change of concentration of drops due to the melting of the ice particles (pristine and rimed ice , aggregates and graupel
!     dmtc10(i)=change of mixing ratio of drops due to the melting of the ice particles
!     dntci0(i)= increase of ice crystal concentration by nucleation of dep. nuclei
!     dmtci0(i)= increase of ice crystal mixing ratio by nucleation of dep. nuclei
!     dntci1(i)= increase of ice crystal concentration by immersional freezing of small drops
!     dmtci1(i)= increase of ice crystal mixing ratio by immersional freezing of small drops
!     dntci3(i)= decrease of ice crystal concentration due to the riming by  drops; snow flakes form
!     dmtci3(i)= decrease of the mixing ratio due to the riming; snow flakes form
!     dntci4(i)= increase of ice crystal concentration due to the contact nucleation of small drops
!     dmtci4(i)= increase of the mixing ratio due to to the contact nucleation of small drops
!     dntci5(i)= decrease of ice crystal concentration due to self collision; snow flake  form
!     dmtci5(i)= change of ice crystal mixing ratio due to self collision;  snow flake form
!     dntci8(i)= decrease of ice crystal concentration due to collision of graupel and pr. ice
!     dmtci8(i)= decrease of the mixing ratio due to collision of graupel and pr. ice
!     dntci9(i)= decrease of ice crystal concentration due to collision snow flake and pr. ice
!     dmtci9(i)= decrease of ice crystal mixing ratio due to collision snow flake and pr. ice
!     dntci10(i)=decrease of ice crystal concentration due to melting
!     dmtci10(i)=decrease of ice crystal  mixing ratio due to melting
!     dntci11(i)= transfer of the small snow flakes and graupel particles to the pristine ice category
!     dmtci11(i)=
!     dntcir1(i)= increase of concentration due to riming of pristine ice
!     dmtcir1(i)= increase of mixing ratio of snow flake crystals due to the riming of pristine ice
!     dntcir2(i)= change of snow flake concentration due to coll.  drops and snow flake cryst.
!     dmtcir2(i)= increase of the mixing ratio of snow flake crystals due to the riming
!     dntcir2v(i)= num. conc. of snow collect one drop and get in to the ith bin
!     dmtcir2v(i)= amount of water collected by snow flakes get into the ith bin
!     dntcir4(i)= decrease of snow flake crystal concentration due to the self coagulation of the snow flake particles
!     dmtcir4(i)= change of the mixing ratio of snow flake crystal due to the self coagulation of the snow flake particles
!     dntcir5(i)= increase of snow flake crystal concentration due to the self coagulation of the pristine ice particles
!     dmtcir5(i)= increase of the mixing ratio of snow flake crystal due to the self coagulation of pristine ice particle
!     dntcir6(i)= decrease of rimed ice crystal concentration due to transfer to graupel (the riming ratio is larger then a given threshold)
!     dmtcir6(i)= decrease of the mixing ratio due to transfer to graupel
!     dntcir7(i)= change of snow flake crystal concentration due to collision snow flake particles and pristine ice
!     dmtcir7(i)= increase of  snow flake mixing ratio due to collision snow flakes and pristine ice
!     dntcir8(i)= complet melting of snow flake crystals
!     dmtcir8(i)= complet melting of snow flake crystals
!     dntcir9(i)= small snow flakes are transfered to the pristine ice category
!     dmtcir9(i)= 
!     dntrime0(i) = change of the number conc. of rimed snow particles due to the diffusional growth
!     dmtrime0(i) = change of the mass of the rimed water due to the diffusional growth
!     dmtsnowm0(i) = change of the mass of the water on the melted snow flakes due to the diffusional growth
!     dmtsnowm1(i) = change of the mass of the water on the melted snow flakes due to the aggregation of the snow flakes
!     dmtsnowm2(i) = change of the mass of the water on the melted snow flakes due to the collision with water drops
!     dmtsnowm3(i) = change of the mass of the water on the melted snow flakes due to the melting
!     dmtsnowm4(i) = transfer of the melted  water due to the complet melting of the snow flakes         
!     dntgra0(i)=immersional freezing of the supercooled drops
!     dmtgra0(i)
!     dntgra1(i)=increase of graupel concentration due to the coagulation of snow flakes and water drops (qw >qwthres)
!     dmtgra1(i)=increase of graupel mixing ratio due to the coagulation of snow flakes and water drops
!     dntgra2(i)=collision of smaller snow flake cryst. and larger drop result in graupel    (if qw is low)
!     dmtgra2(i)= collision of smaller snow flake cryst. and larger drop result in graupel   (if qw is low)
!     dntgra3(i)= graupel - water drop coagulation
!     dmtgra3(i)= graupel - water drop coagulation
!     dntgra3v(i)= number of graupel collected one drop and get into the i-th bin
!     dmtgra3v(i)= amount of water drop collected by the graupel particle and get into the i-th bin
!     dntgra4(i)=increase of frozen drop concentration due to the contact nucleation
!     dmtgra4(i)=increase of frozen drop mixing ratio due to the contact nucleation
!     dntgra5(i)=collision of smaller ice cryst. and larger water drop
!     dmtgra5(i)= collision of smaller ice cryst. and larger water drop
!     dntgra6(i)= collision of smaller snow flakes and larger water drop ( if qw is high)
!     dmtgra6(i)= collision of smaller snow flakes and larger water drop ( if qw is high)
!     dntgra7(i)=increase of graupel concentration due to the transfer from snow flake (riming ratio is larger then a given thershold value (rimthres)
!     dmtgra7(i)=increase of graupel mixing ratio due to the transfer from snow flake
!     dntgra8(i)=increase of graupel concentration due to the coagulation of graupel and pristine ice
!     dmtgra8(i)=increase of graupel mixing ratio due to the coagulation of graupel  and pristine ice
!     dntgra9(i)=increase of graupel concentration due to the coagulation of graupel and snow flake
!     dmtgra9(i)=increase of graupel mixing ratio due to the coagulation of graupel  and snow flake
!     dntgra11(i)= change of the concentration of graupel particles due to the complet melting
!     dmtgra11(i)= change of the mixing ratio of graupel particles due to the complet melting
!     dntgra12(i)= transfer of the small graupel particles in to the pristine ice category
!     dmtgra12(i)= 
!     dmtgram0(i)=change of the mass of the water on the melted graupel due to the diffusional growth
!     dmtgram3(i)=change of the mass of the water on the surface of the graupel particles due to the collison with water drops
!     dmtgram4(i)=change of the mass of the water on the surface of graupel particles due to melting

!.. misc production calculation terms
      DOUBLE PRECISION DN0,DM0,DSNT,DSMT,DSNT2,DSMT2,DSNT0,DSMT0,TK1,   &
     &     QV1,QV11,TK11,DSEGN,DSEGM,DSEGN1,DSEGN2,DSSM1,DSSM2,DSSN1,   &
     &     CORRN,CORRM,VTSNDM,DSNDM,VTWATM,DWATM,VTSNWM,DSNWM,FQMSVT,   &
     &     VTSNOWFQ,CORR
      REAL DHIBAN,CCN,CCN11,CCNM,NIDEPM,MDROPM,MSNOWM,DNID1,FP,RIMCN,   &
     &     SHED,GRAN,MEANMSWM,MEANMSM,MEANMGWM,MEANMGM ! xue add for shedding
      real fqs_melt, fsvt, prcp

!.. VARIABLES USED TO CHECK OF THE MASS CONSERVATION DURING THE DIFFUSIONAL GROWTH
      REAL ERRCOND,SCOND,ERRDEP,SDEP,ERRDEP1,SDEP1

!.. COALLESCENCE EFFICIENCIES 
      REAL ERICIC,EICIC,ERICRIC,EWRIC
!.. dummies
      real*8 errseg0,errseggr,errseggr1,errseggr2,errseggr3,            &
     &     errseggr4,errseggr5,errseggr6,errseggr7,errseggr8,           &
     &     errseggr9,errseggr10,errseggr11,errseggr12

!.. Various thermodynamic variables
      REAL, DIMENSION (NZ) :: LV2, LF2, KG2, VISC2, DIFF2, SATW

      REAL DMEAN,MMEAN,TK,TKE1,P,QVE1,TKM,QVM,VISC,LV,LF,LD,KG,DIFF,    &
     &     TCC,GAMMA,EWS,QWS,EWS1,QWS1,SAT1,ROA,ROA1,TK2,QV2,EWS2,QWS2, &
     &     SAT2,TENTEMP,TENQV,TTEN1,QVTEN1,TENCCN,TENDEP,               &
     &     TOTALN,TOTALN1,SATWMEAN,SATWMAX,SUPSATMIN,SUPSATMAX,TIMES,   &
     &     QWSMAX,EWSMAX,PSMAX,EPSC1,EPSC2,SATS2,QMELT1,QMELT2,QFREEZ,  &
     &     FQ1,FN1,DSMTC6MAX,RIMPDIFF1MAX,RIMPDIFF2MAX,                 &
     &     DELTAV0,DELTAV,DELTAV1
      REAL EIS, SATS3 !,SATS
      real*8 CONST1,CONST11
      real*8 DQSHC, DQGRHC, DQHLHC

      INTEGER KZRDF1,KZRDF2
!+---+

! xue add for shedding
      MEANMSWM=M(1)
      MEANMSM=M(1)
      MEANMGWM=M(1)
      MEANMGM=M(1)

      kpt = 0
      ERICIC = 0.0
      EICIC = 0.0
      ERICRIC = 0.0
      EWRIC = 1. !0.5 !increase for snow water collection efficiency
      DNID1 = 0.0

      SATWMAX =0.0
      QWSMAX=0.0
      EWSMAX =0.0
      PSMAX =0.0
      KSMAX =0
      DO 10 KZ=1,NZ
!        EWS=EXP((23.684*tz_old(KZ)-4947.34)/(tz_old(KZ)-35.86))
        EWS=EXP(53.67957-6743.769/tz_old(kz)-4.8451*log(tz_old(kz)))*100.
        QWS=0.622*EWS/pz(KZ)
        SATW(KZ)=QV_old(KZ)/QWS
        IF (SATW(KZ).GT.SATWMAX) THEN
         SATWMAX = SATW(KZ)
         KSMAX = KZ
         EWSMAX = EWS
         QWSMAX = QWS
         PSMAX = pz(KZ)
        ENDIF
        TK=tz_old(KZ)
        TCC=TK-T00
        GAMMA=.167+3.67e-4*TK
        LV2(KZ)=4186.*597.3*(T00/TK)**GAMMA                              ! latent heat of condensation
        IF(TK.LT.T00) THEN
         LF2(KZ)=4186.*(79.7 + 0.488*TCC - 2.5e-3*TCC*TCC)               ! latent heat of fusion
        ELSE
         LF2(KZ)= LF0
        ENDIF
        KG2(KZ)=418.6*(5.69+0.017*TCC)*1e-5                              ! heat conductivity of the air
        DIFF2(KZ)=2.11e-5*(TK/T00)**1.94*(P00/pz(KZ))                    ! diffusion coef
        IF (TK.GT.T00) THEN
          VISC2(KZ)=(1.718+4.9e-3*TCC)*1e-5                              ! viscosity of the air
        ELSE
          VISC2(KZ)=(1.718+4.9e-3*TCC-1.2e-5*TCC*TCC)*1e-5
        ENDIF
 10   CONTINUE

      if (ksmax.gt.0) then
      WRITE (mp_debug,*) ' sat max, P(mb), T(C), and Qv(g/kg) at ',     &
             ipt,jpt,ksmax,satwmax,pz(ksmax)*0.01,tz(ksmax)-T00,qv(ksmax)*1000
      CALL wrf_debug(150, mp_debug)
      endif

!.. Initialize diagnostic fractions
      DO 40 KZ=1,NZ
        DSMTC9(KZ)=0.0
        QL(KZ)=0.0
        NL(KZ)=0.0
        QICE(KZ)=0.0
        NICE(KZ)=0.0
        QSNOW(KZ)=0.0
        NSNOW(KZ)=0.0
        QGRA(KZ) = 0.0
        NGRA(KZ) = 0.0
        DO 60 K =1,K4
          QL(KZ) = QL(KZ)+QCW0(KZ,K)
          NL(KZ) = NL(KZ)+NCW0(KZ,K)
          QICE(KZ) = QICE(KZ)+QICE0(KZ,K)
          NICE(KZ) = NICE(KZ)+NICE0(KZ,K)
          QSNOW(KZ) = QSNOW(KZ)+QSNOW0(KZ,K)
          NSNOW(KZ) = NSNOW(KZ)+NSNOW0(KZ,K)
          QGRA(KZ) = QGRA(KZ)+QGRA0(KZ,K)
          NGRA(KZ) = NGRA(KZ)+NGRA0(KZ,K)
          FN_OLD(KZ,K) = 0.0
          FQ_OLD(KZ,K) = 0.0
          FQSNOWM(KZ,K) = 0.0
          FQGRAM(KZ,K) = 0.0
          IF (tz_old(KZ).LE.T00) THEN
            IF (NSNOWR0(KZ,K) .GT. NSNOW0(KZ,K)) THEN
              NSNOWR0(KZ,K) = NSNOW0(KZ,K)
            ENDIF
            IF (NSNOW0(KZ,K).GT.0.0) THEN
              FN_OLD(KZ,K) = NSNOWR0(KZ,K)/NSNOW0(KZ,K)
            ENDIF
            IF (QSNOWR0(KZ,K) .GT. QSNOW0(KZ,K)) THEN
              QSNOWR0(KZ,K) = QSNOW0(KZ,K)
            ENDIF
            IF (QSNOW0(KZ,K).GT.0.0) THEN
              FQ_OLD(KZ,K) = QSNOWR0(KZ,K)/QSNOW0(KZ,K)
            ENDIF
            DSMTC9(KZ)=DSMTC9(KZ) + (QSNOWM0(KZ,K) + QGRAM0(KZ,K))/DT
            QSNOWM0(KZ,K) = 0.0
            QGRAM0(KZ,K) = 0.0
          ELSE
            NSNOWR0(KZ,K)=0.0
            QSNOWR0(KZ,K)=0.0
            IF (QSNOWM0(KZ,K) .GT. QSNOW0(KZ,K)) THEN
              QSNOWM0(KZ,K) = QSNOW0(KZ,K)
            ENDIF
            IF (QSNOW0(KZ,K).GT.0.0) THEN
              FQSNOWM(KZ,K)=MAX(0.0, MIN(QSNOWM0(KZ,K)/QSNOW0(KZ,K), 1.0))
            ENDIF
            IF (QGRAM0(KZ,K) .GT. QGRA0(KZ,K)) THEN
              QGRAM0(KZ,K) = QGRA0(KZ,K)
            ENDIF
            IF (QGRA0(KZ,K).GT.0.0) THEN
              FQGRAM(KZ,K)=MAX(0.0, MIN(QGRAM0(KZ,K)/QGRA0(KZ,K), 1.0))
            ENDIF
          ENDIF
 60     CONTINUE
 40   CONTINUE

!.. Initialize all tendencies to zero
      DO 70 K=1,NZ
        DSNTC0(K)=0.0
        DSNTC1(K)=0.0
        DSNTC1B(K)=0.0
        DSNTC2(K)=0.0
        DSNTC3(K)=0.0
        DSNTC4(K)=0.0
        DSNTC5(K)=0.0
        DSNTC6(K)=0.0
        DSNTC8(K)=0.0
        DSNTC8S(K)=0.0
        DSNTC10(K)=0.0
        DSMTC0(K)=0.0
        DSMTC1(K)=0.0
        DSMTC1B(K)=0.0
        DSMTC2(K)=0.0
        DSMTC3(K)=0.0
        DSMTC4(K)=0.0
        DSMTC5(K)=0.0
        DSMTC6(K)=0.0
        DSMTC8(K)=0.0
        DSMTC8S(K)=0.0
        DSMTC10(K)=0.0
        DSNTCI0(K)=0.0
        DSNTCI1(K)=0.0
        DSNTCI2(K)=0.0            
        DSNTCI3(K)=0.0
        DSNTCI4(K)=0.0
        DSNTCI5(K)=0.0
        DSNTCI6(K)=0.0
        DSNTCI9(K)=0.0
        DSNTCI10(K)=0.0
        DSNTCI11(K)=0.0
        DSMTCI0(K)=0.0
        DSMTCI1(K)=0.0
        DSMTCI2(K)=0.0
        DSMTCI3(K)=0.0
        DSMTCI4(K)=0.0
        DSMTCI5(K)=0.0
        DSMTCI6(K)=0.0
        DSMTCI9(K)=0.0
        DSMTCI10(K)=0.0
        DSMTCI11(K)=0.0
        DSNTCIR0(K)=0.0
        DSNTCIR1(K)=0.0
        DSNTCIR2(K)=0.0
        DSNTCIR2V(K)=0.0
        DSNTCIR4(K)=0.0
        DSNTCIR5(K)=0.0
        DSNTCIR6(K)=0.0
        DSNTCIR7(K)=0.0
        DSNTCIR8(K)=0.0
        DSNTCIR9(K)=0.0
        DSMTCIR0(K)=0.0
        DSMTCIR1(K)=0.0
        DSMTCIR2(K)=0.0
        DSMTCIR2V(K)=0.0
        DSMTCIR4(K)=0.0
        DSMTCIR5(K)=0.0
        DSMTCIR6(K)=0.0
        DSMTCIR7(K)=0.0
        DSMTCIR8(K)=0.0
        DSMTCIR9(K)=0.0
        DSNTGRA0(K)=0.0
        DSNTGRA2(K)=0.0
        DSNTGRA3(K)=0.0
        DSNTGRA3V(K)=0.0
        DSNTGRA4(K)=0.0
        DSNTGRA5(K)=0.0
        DSNTGRA7(K)=0.0
        DSNTGRA10(K)=0.0
        DSNTGRA11(K)=0.0
        DSNTGRA12(K)=0.0
        DSMTGRA0(K)=0.0
        DSMTGRA2(K)=0.0
        DSMTGRA3(K)=0.0
        DSMTGRA3V(K)=0.0
        DSMTGRA4(K)=0.0
        DSMTGRA5(K)=0.0
        DSMTGRA7(K)=0.0
        DSMTGRA10(K)=0.0
        DSMTGRA11(K)=0.0
        DSMTGRA12(K)=0.0
        DSNTRIME0(K)=0.0
        DSNTRIME1(K)=0.0
        DSNTRIME2(K)=0.0
        DSNTRIME3(K)=0.0
        DSNTRIME4(K)=0.0
        DSNTRIME5(K)=0.0
        DSMTRIME0(K)=0.0
        DSMTRIME1(K)=0.0
        DSMTRIME2(K)=0.0
        DSMTRIME3(K)=0.0
        DSMTRIME4(K)=0.0
        DSMTRIME5(K)=0.0
        DSMTSNOWM0(K)=0.0
        DSMTSNOWM1(K)=0.0
        DSMTSNOWM2(K)=0.0
        DSMTSNOWM3(K)=0.0
        DSMTSNOWM4(K)=0.0
        DSMTGRAM0(K)=0.0
        DSMTGRAM3(K)=0.0
        DSMTGRAM4(K)=0.0
        DSMTGRAM5(K)=0.0
        RIMPDIFF1(K)=0.0
! xue add for shedding
        DSNTC11(K)=0.0
        DSMTC11(K)=0.0
        DSNTC12(K)=0.0
        DSMTC12(K)=0.0
        DSNTCIR10(K)=0.0
        DSMTCIR10(K)=0.0
        DSNTCIR11(K)=0.0
        DSMTCIR11(K)=0.0
        DSNTGRA13(K)=0.0
        DSMTGRA13(K)=0.0
        DSNTGRA14(K)=0.0
        DSMTGRA14(K)=0.0
 70   CONTINUE

! initialize conversion rates in vertical
      DO KZ=1,NZ
        DNWZ_ACTV(KZ) =0.
        DNWZ_COAG(KZ) =0.
        DNWZ_BRUP(KZ) =0.
        DNIZ_COLL(KZ) =0.
        DMWZ_DIFF(KZ) =0.
        DMWZ_FRML(KZ) =0.
        DMIZ_DIFF(KZ) =0.
        DMWIZ_MELT(KZ)=0.
        DMWIZ_DIFF(KZ)=0.
        DMWZ_RIME(KZ) =0.
        DNWZ_SHED(KZ) =0.
        DMGZ_RIME(KZ) =0.
      ENDDO


!+---+-----------------------------------------------------------------+

!.. Sedimentation.  First find highest level with any mixing ratio and
!.. do not bother to perform calculations above this level. Start with
!.. liquid droplets, then remaining hydrometeors.  Using scratch arrays
!.. for minor efficiency improvements.

      WRITE (mp_debug,*) ' DEBUG:  sedim of water drops'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, ncw0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qcw0(KZ,K))
         vt_c(k,kz) = vtc(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_c, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptrain = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_nw(KZ,K) = SCR4N(K,KZ) - ncw0(KZ,K)
         fo_qw(KZ,K) = SCR4Q(K,KZ) - qcw0(KZ,K)
        ENDDO
      ENDDO

      
!+---+-----------------------------------------------------------------+

!.. Next is cloud ice

      WRITE (mp_debug,*) ' DEBUG:  sedim of cloud ice'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nice0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qice0(KZ,K))
         vt_i(k,kz) = vtci(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_i, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptice = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ni(KZ,K) = SCR4N(K,KZ) - nice0(KZ,K)
         fo_qi(KZ,K) = SCR4Q(K,KZ) - qice0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is snow.  Special terminal velocity of melting snow.

      WRITE (mp_debug,*) ' DEBUG:  sedim of snow'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nsnow0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qsnow0(KZ,K))
         if (qsnow0(kz,k).gt.0.0 .and. qsnowm0(kz,k).gt.0.0) then
            fqs_melt = max(0., min(qsnowm0(kz,k)/qsnow0(kz,k), 1.))
            fsvt = 0.01195*EXP(4.411*fqs_melt)
            vt_s(k,kz) = fsvt*VTC(k)+(1.0 - FSVT)*VTCIR(k)
         else
            vt_s(k,kz) = vtcir(k)
         endif
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptsnow = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ns(KZ,K) = SCR4N(K,KZ) - nsnow0(KZ,K)
         fo_qs(KZ,K) = SCR4Q(K,KZ) - qsnow0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is rime on snow amount

      WRITE (mp_debug,*) ' DEBUG:  sedim of rimed snow'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, nsnowr0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qsnowr0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
!.. We do not add prcp to snow because the qsnow1 variable already
!.. includes both masses.  However, we need proper accouting for rime
!.. amount to pass back into the WRF moist array.
!     pptsnow = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_nsr(KZ,K) = SCR4N(K,KZ) - nsnowr0(KZ,K)
         fo_qsr(KZ,K) = SCR4Q(K,KZ) - qsnowr0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is graupel

      WRITE (mp_debug,*) ' DEBUG:  sedim of graupel'
      CALL wrf_debug(250, mp_debug)

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = AMAX1(0.0, ngra0(KZ,K))
         SCR4Q(K,KZ) = AMAX1(0.0, qgra0(KZ,K))
         vt_g(k,kz) = vtgra(k)
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_g, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptgra = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_ng(KZ,K) = SCR4N(K,KZ) - ngra0(KZ,K)
         fo_qg(KZ,K) = SCR4Q(K,KZ) - qgra0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is meltwater on snow; mass var only, number will be ignored.

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = 0.0
         SCR4Q(K,KZ) = AMAX1(0.0, qsnowm0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_s, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptsnowm = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_qsm(KZ,K) = SCR4Q(K,KZ) - qsnowm0(KZ,K)
        ENDDO
      ENDDO

!+---+-----------------------------------------------------------------+

!.. Next is meltwater on graupel; mass var only, number will be ignored.

      DO  KZ = 1, nz
        sed_n(kz) = 0.
        sed_q(kz) = 0.
        DO  K=1,K4
         SCR4N(K,KZ) = 0.0
         SCR4Q(K,KZ) = AMAX1(0.0, qgram0(KZ,K))
        ENDDO
      ENDDO

      prcp = 0.
      call sedimentation (scr4n, scr4q, vt_g, rhoa, sed_n, sed_q,       &
     &            dz,dt,1,nz,k4,prcp)
      pptgram = prcp

!.. Switch back from scratch arrays to final.

      DO  KZ = 1, nz
        DO  K=1,K4
         fo_qgm(KZ,K) = SCR4Q(K,KZ) - qgram0(KZ,K)
        ENDDO
      ENDDO


!..END SEDIMENTATION
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

!.. Start of calculations for microphysics
      IDELTA1=1 
      TIMES = IST*DT
      supsatmin=10.0
      supsatmax=0.0
      DO 100 KZ=1,NZ
        TENTEMP = (tz(kz) - tz_old(kz))/DT
        TENQV = (qv(kz) - qv_old(kz))/DT
        DQSHC = 0.0
        DQGRHC = 0.0
        DQHLHC = 0.0
        ERICIC = 0.0
        EICIC = 0.0
        ERICRIC = 0.0
        EWRIC = 1. !0.5
        DNID1 = 0.0
        FP = 0.0
!        IF (TK > T00) THEN 
        IF (TZ_OLD(KZ) > T00) THEN
          IDELTA1=0
        ELSE
          IDELTA1=1
        ENDIF

        DO K=1,K4  
! use combination of pre and after advection values
!         NCW0(KZ,K)=NCW0(KZ,K)*0.5+NCW1(KZ,K)*0.5
!         QCW0(KZ,K)=QCW0(KZ,K)*0.5+QCW1(KZ,K)*0.5
!         NICE0(KZ,K)=NICE0(KZ,K)*0.5+NICE1(KZ,K)*0.5
!         QICE0(KZ,K)=QICE0(KZ,K)*0.5+QICE1(KZ,K)*0.5
!         NSNOW0(KZ,K)=NSNOW0(KZ,K)*0.5+NSNOW1(KZ,K)*0.5
!         QSNOW0(KZ,K)=QSNOW0(KZ,K)*0.5+QSNOW1(KZ,K)*0.5
!         NSNOWR0(KZ,K)=NSNOWR0(KZ,K)*0.5+NSNOWR1(KZ,K)*0.5
!         QSNOWR0(KZ,K)=QSNOWR0(KZ,K)*0.5+QSNOWR1(KZ,K)*0.5
!         QSNOWM0(KZ,K)=QSNOWM0(KZ,K)*0.5+QSNOWM1(KZ,K)*0.5
!         NGRA0(KZ,K)=NGRA0(KZ,K)*0.5+NGRA1(KZ,K)*0.5
!         QGRA0(KZ,K)=QGRA0(KZ,K)*0.5+QGRA1(KZ,K)*0.5
!         QGRAM0(KZ,K)=QGRAM0(KZ,K)*0.5+QGRAM1(KZ,K)*0.5
!         NCW0(KZ,K)=NCW0(KZ,K)*0.+NCW1(KZ,K)*1.
!         QCW0(KZ,K)=QCW0(KZ,K)*0.+QCW1(KZ,K)*1.
!         NICE0(KZ,K)=NICE0(KZ,K)*0.+NICE1(KZ,K)*1.
!         QICE0(KZ,K)=QICE0(KZ,K)*0.+QICE1(KZ,K)*1.
!         NSNOW0(KZ,K)=NSNOW0(KZ,K)*0.+NSNOW1(KZ,K)*1.
!         QSNOW0(KZ,K)=QSNOW0(KZ,K)*0.+QSNOW1(KZ,K)*1.
!         NSNOWR0(KZ,K)=NSNOWR0(KZ,K)*0.+NSNOWR1(KZ,K)*1.
!         QSNOWR0(KZ,K)=QSNOWR0(KZ,K)*0.+QSNOWR1(KZ,K)*1.
!         QSNOWM0(KZ,K)=QSNOWM0(KZ,K)*0.+QSNOWM1(KZ,K)*1.
!         NGRA0(KZ,K)=NGRA0(KZ,K)*0.+NGRA1(KZ,K)*1.
!         QGRA0(KZ,K)=QGRA0(KZ,K)*0.+QGRA1(KZ,K)*1.
!         QGRAM0(KZ,K)=QGRAM0(KZ,K)*0.+QGRAM1(KZ,K)*1.
         NTC(K) = DBLE(NCW0(KZ,K))
         MTC(K) = DBLE(QCW0(KZ,K))
         NTCI(K) = DBLE(NICE0(KZ,K))
         MTCI(K) = DBLE(QICE0(KZ,K))
         NTCIR(K) = DBLE(NSNOW0(KZ,K))
         MTCIR(K) = DBLE(QSNOW0(KZ,K))
! these variables bellow are used to controll the diff. growth in subroutine cond. 
!         NTC1(K) = DBLE(NCW1(KZ,K))
!         MTC1(K) = DBLE(QCW1(KZ,K))
!         NTCI1(K) = DBLE(NICE1(KZ,K))
!         MTCI1(K) = DBLE(QICE1(KZ,K))
!         NTCIR1(K) = DBLE(NSNOW1(KZ,K))
!         MTCIR1(K) = DBLE(QSNOW1(KZ,K))

         NTSNOWR(K) =DBLE(NSNOWR0(KZ,K))
         MTSNOWR(K) =DBLE(QSNOWR0(KZ,K))
         MTSNOWM(K) = DBLE(QSNOWM0(KZ,K))
         NTGRA(K) = DBLE(NGRA0(KZ,K))
         MTGRA(K) = DBLE(QGRA0(KZ,K))
         MTGRAM(K) = DBLE(QGRAM0(KZ,K))
! update the fraction after mean advection values are calculated
!         IF (NTCIR(K).GT.0.0) THEN
!           FN(K) = MAX(0.0,MIN(NTSNOWR(K)/NTCIR(K),1.0))
!         ELSE
!           FN(K)=0.0
!         ENDIF
!         IF (MTCIR(K).GT.0.0) THEN
!           FQ(K) = MAX(0.0,MIN(MTSNOWR(K)/MTCIR(K),1.0))
!         ELSE
!           FQ(K)=0.0
!         ENDIF
!         IF (MTCIR(K).GT.0.0) THEN
!           FQSM(K)=MAX(0.0, MIN(MTSNOWM(K)/MTCIR(K), 1.0))
!         ELSE
!           FQSM(K)=0.0
!         ENDIF
!         IF (MTGRA(K).GT.0.0) THEN
!           FQGM(K)=MAX(0.0, MIN(MTGRAM(K)/MTGRA(K),1.0))
!         ELSE
!           FQGM(K)=0.0
!         ENDIF
         FN(K) = FN_OLD(KZ,K)
         FQ(K) = FQ_OLD(KZ,K)
         FQSM(K) = FQSNOWM(KZ,K)
         FQGM(K) = FQGRAM(KZ,K)

         DNTC0(K)=0.0
         DMTC0(K)=0.0
         DNTC1(K)=0.0
         DMTC1(K)=0.0
         DNTC1B(K)=0.0
         DMTC1B(K)=0.0
         DNTC3(K)=0.0
         DMTC3(K)=0.0
         DNTC4(K)=0.0
         DMTC4(K)=0.0
         DNTC5(K)=0.0
         DMTC5(K)=0.0
         DNTC6(K)=0.0
         DMTC6(K)=0.0
         DNTC8(K)=0.0
         DMTC8(K)=0.0
         DNTC8S(K)=0.0   ! collision shedding
         DMTC8S(K)=0.0   ! collision shedding
         DNTC10(K)=0.0
         DMTC10(K)=0.0
         DNTCI0(K)=0.0
         DMTCI0(K)=0.0
         DNTCI1(K)=0.0
         DMTCI1(K)=0.0
         DNTCI3(K)=0.0
         DMTCI3(K)=0.0
         DNTCI4(K)=0.0
         DMTCI4(K)=0.0
         DNTCI5(K)=0.0
         DMTCI5(K)=0.0
         DNTCI9(K)=0.0
         DMTCI9(K)=0.0
         DNTCI10(K)=0.0
         DMTCI10(K)=0.0
         DNTCI11(K)=0.0
         DMTCI11(K)=0.0
         DNTCIR1(K)=0.0
         DMTCIR1(K)=0.0
         DNTCIR2(K)=0.0
         DMTCIR2(K)=0.0
         DNTCIR2V(K)=0.0
         DMTCIR2V(K)=0.0
         DNTCIR4(K)=0.0
         DMTCIR4(K)=0.0
         DNTCIR5(K)=0.0
         DMTCIR5(K)=0.0
         DNTCIR6(K)=0.0
         DMTCIR6(K)=0.0
         DNTCIR7(K)=0.0
         DMTCIR7(K)=0.0
         DNTCIR8(K)=0.0
         DMTCIR8(K)=0.0
         DNTCIR9(K)=0.0
         DMTCIR9(K)=0.0
         DNTGRA0(K)=0.0
         DMTGRA0(K)=0.0
         DNTGRA2(K)=0.0
         DMTGRA2(K)=0.0
         DNTGRA3(K)=0.0
         DMTGRA3(K)=0.0
         DNTGRA3V(K)=0.0
         DMTGRA3V(K)=0.0
         DNTGRA4(K)=0.0
         DMTGRA4(K)=0.0
         DNTGRA5(K)=0.0
         DMTGRA5(K)=0.0
         DNTGRA7(K)=0.0
         DMTGRA7(K)=0.0
         DNTGRA11(K)=0.0
         DMTGRA11(K)=0.0
         DNTGRA12(K)=0.0
         DMTGRA12(K)=0.0
         DMTRIME0(K)=0.0
         DNTRIME0(K)=0.0
         DMTRIME1(K)=0.0
         DNTRIME1(K)=0.0
         DMTRIME2(K)=0.0
         DNTRIME2(K)=0.0
         DMTRIME3(K)=0.0
         DNTRIME3(K)=0.0
         DMTRIME4(K)=0.0
         DNTRIME4(K)=0.0
         DMTRIME5(K)=0.0
         DNTRIME5(K)=0.0
         DMTSNOWM0(K)=0.0
         DMTSNOWM1(K)=0.0
         DMTSNOWM2(K)=0.0
         DMTSNOWM3(K)=0.0
         DMTSNOWM4(K)=0.0
         DMTGRAM0(K)=0.0
         DMTGRAM3(K)=0.0
         DMTGRAM4(K)=0.0
         DMTGRAM5(K)=0.0
! xue add for shedding
         DNTC11(K)=0.0
         DMTC11(K)=0.0
         DNTC12(K)=0.0
         DMTC12(K)=0.0
         DNTCIR10(K)=0.0
         DMTCIR10(K)=0.0
         DNTCIR11(K)=0.0
         DMTCIR11(K)=0.0
         DNTGRA13(K)=0.0
         DMTGRA13(K)=0.0
         DNTGRA14(K)=0.0
         DMTGRA14(K)=0.0
        ENDDO

        ibug0=0
        ibug01=0
        ibug1=0
        ibug2=0
        ibug3=0
        ibug4=0
        ibug5=0
        
        if (TIMES.ge.815.and.TIMES.le.818) then
          if (ii.eq.302.and.kz.eq.14) then
!             ibug5=1
          endif
        endif

        kpt = KZ
        if (ibug5.eq.1) then
        write(95,*) 'mixing ratios and conc. before micro time',times
        write(95,*) 'at x: ',ii
        write(95,*) 'kz,k,ntc,mtc'
        do k = 1,k4
         write(95,*) kz,k,ntc(k),mtc(k)
        enddo
        write(95,*) 'qv,qvold,tz,tz_old',qv(kz),qv_old(kz),tz(kz),tz_old(kz)
        write(95,*) 'dt',dt
        write(95,*) 'tenqv,tentemp',tenqv,TENTEMP
        endif
 
        ROA = RHOA(KZ)
        ROA1 = SQRT(ROA0/ROA)
        CONST1 = DBLE (ROA1*DT)
        TK1 = DBLE(tz_old(KZ))
        QV1 = DBLE(qv_old(KZ))
        TKE1 = TK1
        QVE1 = QV1
        TK11 = TK1
        QV11 = QV1
        CCN = CCN0(KZ)
        P = pz(KZ)
        VISC = VISC2(KZ)
        LV = LV2(KZ)
        LF = LF2(KZ)
        IF (tz_old(KZ).LT.T00) THEN
         LD = LF + LV
        ELSE
         LD = LV
        ENDIF
        KG = KG2(KZ)
        DIFF = DIFF2(KZ)
        VISC = VISC2(KZ)
        TK2 = tz(kz)
        QV2 = qv(kz)
!        EWS2 = EXP((23.684*TK2-4947.34)/(TK2-35.86))
        EWS2=EXP(53.67957-6743.769/tk2-4.8451*log(tk2))*100.
        QWS2 = 0.622*EWS2/P
        SATS2 = QV2/QWS2
!        EIS = EXP((28.2890*TK2-6024.330)/(TK2-7.660))
        EIS = EXP(23.33086-6111.72784/tk2+0.15215*log(tk2))*100.
!        SATS3 = QV2*P/(0.622+QV2) / EIS
        SATS3 = QV2*P/0.622/EIS

       if (ibug0.eq.1) then
         write(98,*) 'before call coef1 ist,kz,ii,jj',ist,kz,ii,jj
         write(98,*) 'temp,qv,sats2,sats3',tz_old(KZ),qv_old(KZ),sats2,sats3
         write(98,*) 'tk1,tk2,qv1,qv2',tk1,tk2,qv1,qv2
         write(98,*) 'water size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntc(k),mtc(k)
         enddo
         write(98,*) 'snow size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntcir(k),mtcir(k),fqsm(k),fn(k),fq(k)
         enddo
         write(98,*) 'graupel size distribution befor coef1'
         do k=1,k4
          write(98,*) k,ntgra(k),mtgra(k),fqgm(k)
         enddo
       endif

        TTEN1=TENTEMP
        QVTEN1=TENQV
        TENCCN = (CCN1(KZ) - CCN0(KZ))/DT
        TENDEP = (NIDEP1(KZ)- NIDEP0(KZ))/DT
        TOTALN1 = AMAX1(NL(KZ),0.0) + AMAX1(NICE(KZ),0.0) +             &
     &           AMAX1(NSNOW(KZ),0.0)
        TOTALN = TOTALN1+ AMAX1(NGRA(KZ),0.0)
!..Original code checked for water saturation.  In this case, no ice would form
!.. unless it was also water saturated.  Now, we check for ice supersaturation,
!.. so that subroutine DEPACT can decide if ice forms in less than water saturated.
! xue add SATS2 < 1 to make sure water will be generated in warm region
        IF (TOTALN < EPS .AND. SATS3 < 1.0 .AND. SATS2 < 1.0) THEN ! no particles and they will not form at at this point
          CCN1(KZ) = CCN0(KZ) + TENCCN*DT
          NIDEP1(KZ) = NIDEP0(KZ) + TENDEP*DT
!          write(*,*)'no microphysics is called: sat2,sats3 at i,j,k',sats2,sats3,ii,jj,kz
          GOTO 121
        ENDIF

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for water drops'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,AC,BC,CC,DC,MTC,NTC,KMIN,KMAX,NL(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for graupel'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,AGRA,BGRA,CGRA,DGRA,MTGRA,NTGRA,KMINGRA,KMAXGRA,  &
     &           NGRA(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for cloud ice'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,ACI,BCI,CCI,DCI,MTCI,NTCI,KMINCI,KMAXCI,          &
     &           NICE(KZ))

        WRITE (mp_debug,*) ' DEBUG: calling coef1 for snow'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

        CALL COEF1(K4,ACIR,BCIR,CCIR,DCIR,MTCIR,NTCIR,KMINCIR,KMAXCIR,  &
     &           NSNOW(KZ))

        KTOP=0
        IF (tz_old(KZ) .GT. T00) THEN
!     calculation of the mass weighted mean terminal velocity and mass weighted mean diameter of the
!     water drops, dry snow flakes and wet snow flakes
!     these paramers are used for the correction of  wet snow - water drop collison because the kernels are calculated 
!     for  dry snow - water drop the collison 
         DSSM1=0.0
         DSSM2=0.0
!     mean values for dry snow
         DO 130 K = 1, K4 
           MMEAN=0.0
           IF (NTCIR(K) .LE. 0.0) GOTO 130
           MMEAN=MTCIR(K)/NTCIR(K)
           IF (MMEAN > M(K+1)) MMEAN = M(K+1)
           IF (MMEAN < M(K)) MMEAN = M(K)
           IF (MMEAN.LE.MSNOW100) THEN
            RSNOW=RSNOW0
            ROSNOW=ROSNOW0
            DMEAN=16.28*SQRT(MMEAN)
           ENDIF
           IF (MMEAN.GE.MSNOW500) THEN
             RSNOW=RSNOW1
             DMEAN=SQRT(6.*MMEAN/PI/0.17)
             rosnow = 0.17/DMEAN
             if (rosnow .lt. 20.0) then
                rosnow=20.0
                DMEAN = (6.0*MMEAN/3.14159/rsnow/rosnow)**0.33333333
             endif
           ENDIF
           IF (MMEAN.GT.MSNOW100.AND.MMEAN.LT.MSNOW500) THEN
             A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
             B1=RSNOW1-A1*ALOG10(MSNOW500)
             A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
             B2=ROSNOW1-A2*ALOG10(MSNOW500)
             RSNOW=A1*ALOG10(MMEAN)+B1
             ROSNOW=A2*ALOG10(MMEAN)+B2
             DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333
           ENDIF
           DSSM1=DSSM1+MTCIR(K)*DMEAN
           DSSM2=DSSM2+MTCIR(K)*VTCIR(K)
 130     CONTINUE
         IF (QSNOW(KZ) .GT. 0.0) THEN
           DSNDM=DSSM1/QSNOW(KZ)
           VTSNDM=DSSM2/QSNOW(KZ)
         ENDIF   
         DSSM1=0.0
         DSSM2=0.0
!     mean values for wet snow
         DO 135 K = 1, K4  
          MMEAN=0.0
          IF (NTCIR(K) <= 0.0) GOTO 135
          MMEAN=MTCIR(K)/NTCIR(K)
          IF (MMEAN > M(K+1)) MMEAN = M(K+1)
          IF (MMEAN < M(K)) MMEAN = M(K)
          IF (MMEAN.LE.MSNOW100) THEN
           RSNOW=RSNOW0
           ROSNOW=ROSNOW0
           DMEAN=16.28*SQRT(MMEAN)
          ENDIF
          IF (MMEAN.GE.MSNOW500) THEN
            RSNOW=RSNOW1
            ROSNOW=0.17/SQRT(6*MMEAN/Pi/0.17)
            if (rosnow .lt. 20.0) rosnow=20.0
          ENDIF
          IF (M(K).GT.MSNOW100.AND.M(K).LT.MSNOW500) THEN
            A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
            B1=RSNOW1-A1*ALOG10(MSNOW500)
            A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
            B2=ROSNOW1-A2*ALOG10(MSNOW500)
            RSNOW=A1*ALOG10(MMEAN)+B1
            ROSNOW=A2*ALOG10(MMEAN)+B2        
          ENDIF
          RSNOW=FQSM(K) + (1-FQSM(K))*RSNOW
          ROSNOW = FQSM(K)*1000 + (1-FQSM(K))*ROSNOW 
          DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333 
          DSSM1=DSSM1+MTCIR(K)*DMEAN
          FQMSVT=0.01195*exp(4.411*FQSM(K))  
          VTSNOWFQ=FQMSVT*VTC(K)+(1 - FQMSVT)*VTCIR(K)       
          DSSM2=DSSM2+MTCIR(K)*VTSNOWFQ
 135     CONTINUE
         IF (QSNOW(KZ) .GT. 0.0) THEN
           DSNWM=DSSM1/QSNOW(KZ)
           VTSNWM=DSSM2/QSNOW(KZ)
         ENDIF
!     mean values for water drops
         DSSM1=0.0
         DSSM2=0.0
         DO 140 K = 1, K4 
           MMEAN=0.0
           IF (NTC(K).LE.0.0) GOTO 140
           MMEAN=MTC(K)/NTC(K)
           IF (MMEAN > M(K+1)) MMEAN = M(K+1)
           IF (MMEAN < M(K)) MMEAN = M(K)
           DSSM1=DSSM1+MTC(K)*(6*MMEAN/PI/1000.)**0.3333 
           DSSM2=DSSM2+MTC(K)*VTC(K)
 140     CONTINUE
         IF (QL(KZ) .GT. 0.0) THEN
           DWATM=DSSM1/QL(KZ)
           VTWATM=DSSM2/QL(KZ)
         ENDIF      
        ENDIF               ! endif for calculation of the correction terms for melting snow - water collison

!.. loop for diffusional growth of water drops

        NSTEP = MAX(1, INT(DT/DTCOND+0.5))

!+---+----------------- DEBUG IF NEEDED -------------------------------+
         if (ibug5.eq.1) then
          write(95,*) 'times',times
          write(95,*) 'nstep,dt,dtcond',nstep,dt,dtcond
          write(95,*) 'temp,qv',tk1,qv1
          write(95,*) 'tentemp,tenqv',tentemp,tenqv
          write(95,*) 'ql,nl,qice,nice,qsnow,nsnow,qgra,ngra'
          write(95,*) ql(kz),nl(kz),qice(kz),nice(kz),                  &
     &               qsnow(kz),nsnow(kz),qgra(kz),                      &
     &               ngra(kz) 
         endif
!+---+----------------- END DEBUG -------------------------------------+

        DO 200 ISTEP=1,NSTEP
          DSNT = 0.0
          DSMT = 0.0
          DSNT2 = 0.0
          DSMT2 = 0.0
          DSNT0 = 0.0
          DSMT0 = 0.0
          CCN11 = CCN
          IF (CCN11 < 0.0) CCN11 = 0.0
          QV11=QV1
          TK11=TK1
!          EWS=EXP((23.684*TK1-4947.34)/(TK1-35.86))
          EWS=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
          QWS=0.622*EWS/P
          SAT1=QV1/QWS-1.0         
          CCN=CCN+TENCCN*DTCOND
          IF (CCN < 0.0) CCN=0.0
!          QV1=QV1+TENQV*DTCOND
!          TK1=TK1+TENTEMP*DTCOND
!          EWS=EXP((23.684*TK1-4947.34)/(TK1-35.86))
          EWS=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
          QWS2=0.622*EWS/P
          SAT2=QV1/QWS2-1.0
         

!+---+----------------- DEBUG IF NEEDED -------------------------------+
          if (ibug5.eq.1) then       
            write(95,*) 'istep,dtcond,qv1,tk1,sat1,sat2'
            write(95,*) istep,dtcond,qv1,tk1,sat1,sat2
          dsegm=0.0
          dsegn=0.0
           do k=1,k4
           dsegn=dsegn+ntc(k)
           dsegm=dsegm+mtc(k)
          enddo
          write(95,*)'water before cond, mass and conc.',dsegm, dsegn
          endif
       
!+---+----------------- END DEBUG -------------------------------------+

!.. EFFECT OF RADIATION COOLING IS ALSO CALCULATED AT THE CLOUD TOP WHERE KTOP=1



          CALL COND(K4,DSNT,DSMT,DSNT2,DSMT2,DSNT0,DSMT0,               &
     &         DTCOND,ERRCOND,SCOND,ERRDEP,SDEP,                        &
!     &         NTC1,MTC1,NTCI1,MTCI1,NTCIR1,MTCIR1,                     &
!     &         TK1,QV1,TK11,QV11,CCN,DNID1,TENQV,TENTEMP,KTOP,ibug5,    &
     &         TK1,QV1,CCN,DNID1,TENQV,TENTEMP,KTOP,ibug5,              &
     &         TIMES,KZ,errseg0,P,TKE1,QVE1,ROA,LV,LD,LF,KG,VISC,DIFF)

!         if (times.eq.780.or.times.eq.781) then
!         write(98,*)'BEF. COND,times:',times,'ii:',ii,'kz,dsmtc2,dsntc2'
!         write(98,*) kz,DSMTC2(KZ),DSNTC2(KZ)
!         endif


          DSNTC2(KZ) = DSNTC2(KZ) + DSNT
          DSMTC2(KZ) = DSMTC2(KZ) + DSMT
          DSNTCI2(KZ) = DSNTCI2(KZ) + DSNT2
          DSMTCI2(KZ) = DSMTCI2(KZ) + DSMT2
          DSNTCIR0(KZ) = DSNTCIR0(KZ) + DSNT0
          DSMTCIR0(KZ) = DSMTCIR0(KZ) + DSMT0
!     CCNM = 0.5*(CCN11+CCN1)
!     TKM = 0.5*(TK11+TK1)
!     QVM = 0.5*(QV11+QV1)
          CCNM = (CCN11 + 0.5*TENCCN*DTCOND) ! fontos modositas 2007. 10. 31.
          IF (CCNM < 0.0) CCNM = 0.0
          TKM = (TK11 + 0.5*TENTEMP*DTCOND)
          QVM = (QV11 + 0.5*TENQV*DTCOND)

        WRITE (mp_debug,*) ' DEBUG: calling COND0 piggyback'
        if (kz.eq.1) CALL wrf_debug(150, mp_debug)

!      EWS = EXP((23.684*TKM-4947.34)/(TKM-35.86))
!      QWS = 0.622*EWS/P
!      SATS = QVM/QWS

!      if(sats.gt.1.) write(*,*)'bf cond0, sats at i,j,k',SATS,ii,jj,kz

! xue limit the surface activation within cold pool
!          if(kz.gt.1) then
          CALL COND0(CCN,CCNM,DN0,DM0,TK1,QV1,TKM,QVM,P,LV,ibug1,0)
!          end if
          
          NTC(1) = NTC(1) + DN0
          MTC(1) = MTC(1) + DM0
          DNTC0(1) = DNTC0(1) + DN0
          DMTC0(1) = DMTC0(1) + DM0
 200    CONTINUE

        TTEN1 = (TK1 - tz_old(kz))/DT
        QVTEN1 = (QV1 - qv_old(kz))/DT

! xue add this to make sure the LD is correct after cond is called
!        IF (tz_old(KZ).LT.T00) THEN
!         LD = LF + LV
!        ELSE
!         LD = LV
!        ENDIF
! xue 

!+---+----------------- DEBUG IF NEEDED -------------------------------+
        if (ibug5.eq.1) then
         write(95,*) 'after cond,tk,qv,tk1,qv1',tk11,qv11,tk1,qv1
        endif
!+---+----------------- END DEBUG -------------------------------------+

        DO K =1,K4
         DNTRIME0(K) = NTSNOWR(K) - NSNOWR0(KZ,K) !FN(K)*NSNOW1(KZ,K)
         DMTRIME0(K) = MTSNOWR(K) - QSNOWR0(Kz,K) !FQ(K)*QSNOW1(KZ,K)
         DMTSNOWM0(K) = MTSNOWM(K) - QSNOWM0(KZ,K)
         DSMTSNOWM0(KZ) = DSMTSNOWM0(KZ) + DMTSNOWM0(K) 
        ENDDO
        DSNTC0(KZ) = DSNTC0(KZ)/DT
        DSMTC0(KZ) = DSMTC0(KZ)/DT
        DSMTC2(KZ) = DSMTC2(KZ)/DT
        DSNTC2(KZ) = DSNTC2(KZ)/DT
        DSNTCI2(KZ) = DSNTCI2(KZ)/DT
        DSMTCI2(KZ) = DSMTCI2(KZ)/DT
        DSNTCIR0(KZ) = DSNTCIR0(KZ)/DT
        DSMTCIR0(KZ) = DSMTCIR0(KZ)/DT
        DSMTSNOWM0(KZ) = DSMTSNOWM0(KZ)/DT
! bulk diffusion rate
        DMWZ_DIFF(KZ) = DMWZ_DIFF(KZ)+DSMTC2(KZ)
        DMIZ_DIFF(KZ) = DSMTCI2(KZ)+DSMTCIR0(KZ)
        DMWIZ_DIFF(KZ)= DMWIZ_DIFF(KZ)+DSMTSNOWM0(KZ)
! bulk diffusion rate end

!+---+----------------- DEBUG IF NEEDED -------------------------------+
        if (ibug5.eq.1) then   
!         write(95,*) 'after cond,times,ii',times,ii
         dsegn=0.0
         dsegm=0.0
         do k=1,k4
           dsegn=dsegn+ntc(k)
           dsegm=dsegm+mtc(k)
         enddo
         write(95,*)'water after cond, mass and conc.',dsegm, dsegn
         write(95,*) 'times,kz,dsmtc2,dsntc2,dsmtc0,dsntc0',times
         write(95,*) kz,dsmtc2(kz),dsntc2(kz),dsmtc0(kz),dsntc0(kz)
        endif
        if (times.eq.781.) then
        write(98,*)'AFTER COND,times:',times,'ii:',ii,'kz,dsmtc2,dsntc2'
        write(98,*) kz,DSMTC2(KZ),DSNTC2(KZ)
        endif

!+---+----------------- END DEBUG -------------------------------------+

!     ttend(kz)=(tk1-tk)/DT
!     dqv(kz)=(qv1-qve)/DT
        tz(kz) = TK1
        QV(KZ)=QV1
        TK = 0.5*(TK11 + TK1)
        QVM = 0.5*(QV11 + QV1)
!        EWS = EXP((23.684*TK-4947.34)/(TK-35.86))
        EWS=EXP(53.67957-6743.769/tk-4.8451*log(tk))*100.
        QWS = 0.622*EWS/P
        SATWMEAN = QVM/QWS
!        EWS2 = EXP((23.684*TK1-4947.34)/(TK1-35.86))
        EWS2=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
        QWS2 = 0.622*EWS2/P 
        SAT2=QV1/QWS2

!  NTC1 and MTC1 variables are used to avoid the overestimation the collection of water drops 
        DO K =1,K4
          NTC1(K)=NTC(K)
          MTC1(K)=MTC(K)
        ENDDO

!     formation of the pristine ice by deposition or condensational freezing 
        NIDEPM = (NIDEP0(KZ) +  0.5*TENDEP*DT)
        IF(DNID1 + NIDEPM < 0.0) DNID1 = -NIDEPM
!..GT        IF (TK <  T00-5 .AND. SATWMEAN >  1.000) THEN    ! This means it must be water saturated.
        IF (TK <  T00-5) THEN
!     uncomment these two rows for no ice depletion
!     NIDEP1(KZ)=NICE1(KZ)
!     TENDEP=0.0

        WRITE (mp_debug,*) ' DEBUG: calling DEPACT'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

         CALL DEPACT(K4,DNTCI0,DMTCI0,NIDEPM,TENDEP,DT, P,TK,QVM,ROA)
         DO K=1,K4
          NTCI(K)=NTCI(K)+DNTCI0(K)*DT
          MTCI(K)=MTCI(K)+DMTCI0(K)*DT
         ENDDO
        ENDIF
        TENDEP=TENDEP+DNID1/DT
!     uncomment this row for no ice depletion
!     TENDEP=0.0
            
!      goto 2222     ! collison - colescence is neglected
 125  IF (NL(KZ) > EPS) THEN
!     collection of IN by drops with Brownian and phoretic
!     CALL phoresis(ntc,mtc,dntc3,dmtc3,m,ac,bc,cc,dc, &
!     rada,pk,k4,ibug)
!     self coagulation of the water drops

!     self coagulation of the water drops
       DTDRP=DT/10. !0.1
       NSTEP=DT/DTDRP
       CONST1T = CONST1/DT*DTDRP
       NLT=0.0
       DO K=1,K4
        MTCT(K)=MTC(K)
        NTCT(K)=NTC(K)
        NLT=NLT+NTC(K)
       ENDDO

!        WRITE (mp_debug,*) ' DEBUG: calling COAGS'
!        if (kz.eq.1) CALL wrf_debug(250, mp_debug)
    
!         CALL COAGS(K4,AC,BC,CC,DC,DNTC1,DMTC1,CCW,CCCW)

!
!     coag. of graupel particles and  drops  + H-M ice multiplication
!
       DO ISTEP =1,NSTEP
        CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
        DO K=1,K4
         DMTC1T(K)=0.d0
         DNTC1T(K)=0.d0
         DNTC1BT(K)=0.d0
         DMTC1BT(K)=0.d0
        ENDDO
        CALL COAGS(K4,ACT,BCT,CCT,DCT,DNTC1T,DMTC1T,CCW,CCCW)
        IF (IBREAKUP == 1) THEN
!     collison induced breakup
!         CALL BREAKUP(K4,DNTC1B,DMTC1B,CCCWMEAN,DT)    !modofied 04.27. by SN.
         CALL BREAKUP(K4,MTCT,NTCT,DNTC1BT,DMTC1BT,CCCWMEAN,DTDRP,ibug0)
        ENDIF
        NLT=0.0
        DO K = 1, K4
         NTCT(K)=NTCT(K)+CONST1T*(DNTC1T(K)+DNTC1B(K))
         MTCT(K)=MTCT(K)+CONST1T*(DMTC1T(K)+DMTC1B(K))
         IF (NTCT(K).LT.0.d0.OR.MTCT(K).LT.0.d0) THEN
          NTCT(K)=0.d0
          MTCT(K)=0.d0
         ENDIF
         NLT=NLT+NTCT(K)
         DNTC1(K)=DNTC1(K)+DTDRP*DNTC1T(K)
         DMTC1(K)=DMTC1(K)+DTDRP*DMTC1T(K)
         DNTC1B(K)=DNTC1B(K)+DTDRP*DNTC1BT(K)
         DMTC1B(K)=DMTC1B(K)+DTDRP*DMTC1BT(K)
        ENDDO
       ENDDO
       DO K=1,K4
        NTC1(K)=NTCT(K)
        MTC1(K)=MTCT(K)
        DNTC1(K)=DNTC1(K)/DT
        DMTC1(K)=DMTC1(K)/DT
        DNTC1B(K)=DNTC1B(K)/DT
        DMTC1B(K)=DMTC1B(K)/DT
       ENDDO

      ENDIF

!+---+-----------------------------------------------------------------+
        IF (NICE(KZ) > EPS.AND.NL(KZ) > EPS) THEN
         IF (tz_old(KZ) < T00) THEN
!     coag. of pristine ice crystals and drops
   
          CALL COAG40(K4,ACI,BCI,CCI,DCI,AC,BC,CC,DC,DMTCI3,DNTCI3,     &
     &     DMTC5,DNTC5,DMTCIR1,DNTCIR1,DMTGRA5,DNTGRA5,CCIW,CCCIW,C5IW, &
     &     CCCVIW,C5VIW,DMTRIME1,DNTRIME1)
     
!     if  dmtci3 is greater than the mixing ratio of the pristine ice cryst. the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTCI3(K)
           DSSN1=DSSN1+CONST1*DNTCI3(K)
           IF ((CONST1*DNTCI3(K)+NTCI(K).LT.0.d0) .OR.                  &
     &                       (CONST1*DMTCI3(K)+MTCI(K).LT.0.d0)) THEN     
            DNTCI3(K)=-NTCI(K)/CONST1
            DMTCI3(K)=-MTCI(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTCI3(K)
           DSEGN=DSEGN+CONST1*DNTCI3(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 145
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTC5(K)=CORRM*DMTC5(K)
            DNTC5(K)=CORRN*DNTC5(K)
            DNTCIR1(K)=CORRN*DNTCIR1(K)
            DMTCIR1(K)=CORRM*DMTCIR1(K)
            DNTGRA5(K)=CORRN*DNTGRA5(K)
            DMTGRA5(K)=CORRM*DMTGRA5(K)
            DNTRIME1(K)=CORRN*DNTRIME1(K)
            DMTRIME1(K)=CORRM*DMTRIME1(K)
           ENDDO
          ENDIF
 145      CONTINUE
          DO K =1,K4
           NTC1(K)= NTC1(K) + CONST1*DNTC5(K)
           MTC1(K)= MTC1(K) + CONST1*DMTC5(K)
           NTC1(K)= DMAX1(0.d0,NTC1(K))
           MTC1(K)= DMAX1(0.d0,MTC1(K))
          ENDDO
         ENDIF            ! endif for tk< 273.15
        ENDIF               !  nic > eps and nw > eps

        IF (NICE(KZ) > EPS) THEN
!     aggregatin of pristine ice crystals
         IF (TK < T00) THEN ! coalesence efficiency of ice cr. - ice cr. collision
          EICIC=EXP(0.38*(TK-T00))
         ELSE
          EICIC=1.00
         ENDIF
         EICIC=0.10       ! Paul's suggestion
        WRITE (mp_debug,*) ' DEBUG: calling COAG6'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)
         CALL COAG6(K4,ACI,BCI,CCI,DCI,DMTCI5,DNTCI5,                   &
     &              DMTCIR5,DNTCIR5,CCSNOW1,CCCSNOW1,CSNOW15)
        ENDIF
        IF (NSNOW(KZ) > EPS) THEN
!     aggregation of snow flakes
         IF (TK < T00) THEN ! coalesence efficiency of rimed ice cr. - rimed ice cr. collision
!-GT           ERICRIC=EXP(0.09*(TK-T00))
           ERICRIC=0.1
         ELSE
           ERICRIC=1.00
         ENDIF
!        ERICRIC=0.1    ! Paul's suggestion, modified:2013.04.15.
         WRITE (mp_debug,*) ' DEBUG: calling COAGS1, ERICRIC=',ERICRIC
         if (kz.eq.1) CALL wrf_debug(250, mp_debug)
         IF (tz_old(KZ) < T00) THEN
           CALL COAGS1(K4,ACIR,BCIR,CCIR,DCIR,DNTCIR4,DMTCIR4,          &
     &                 CCSNOW2,CCCSNOW2,FQ,DMTRIME3,FN,DNTRIME3)
         ELSE
           CALL COAGS1M(K4,ACIR,BCIR,CCIR,DCIR,DNTCIR4,DMTCIR4,         &
     &                 CCSNOW2,CCCSNOW2,FQSM,DMTSNOWM1)

!..New addition to adjust snow self-collection due to changed diameter of melted snow compared to dry snow used in the kernels.  I.G. 2013Aug20
           CORR = (DSNWM/DSNDM)*(DSNWM/DSNDM)
           CORR = MIN(CORR, 1.0)
           DO K = 1,K4
              DNTCIR4(K) = CORR*DNTCIR4(K)
              DMTCIR4(K) = CORR*DMTCIR4(K)
              DMTSNOWM1(K) = CORR*DMTSNOWM1(K)
           ENDDO
         ENDIF
        if (ibug3.eq.1) then
         write(98,*) 'after aggregation tk',tk1,tz_old(KZ)
         write(98,*) ntcir(34),mtcir(34)
        endif

        ENDIF
        IF (NSNOW(KZ) > EPS.AND.NL(KZ) > EPS) THEN
!     coag. of snow flake crystals and  drops

         IF (tz_old(KZ).LT.T00) THEN
         
          CALL COAG5 (K4,AC,BC,CC,DC,ACIR,BCIR,CCIR,DCIR,DMTC6,DNTC6,   &
     &          DMTCIR2,DNTCIR2,DMTGRA2,DNTGRA2,CCRIW,CCCRIW,CCCVRIW,   &
     &          C5VRIW,FQ,DMTRIME2,FN,DNTRIME2)
          DO K=1,K4
             DMTC6(K)=EWRIC*DMTC6(K)
             DNTC6(K)=EWRIC*DNTC6(K)
             DMTCIR2(K)=EWRIC*DMTCIR2(K)
             DNTCIR2(K)=EWRIC*DNTCIR2(K)
             DMTGRA2(K)=EWRIC*DMTGRA2(K)
             DNTGRA2(K)=EWRIC*DNTGRA2(K)
             DMTRIME2(K)=EWRIC*DMTRIME2(K)
             DNTRIME2(K)=EWRIC*DNTRIME2(K)
          ENDDO
!     if  dmtc6 is greater than the mixing ratio of the water drops the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTC6(K)
           DSSN1=DSSN1+CONST1*DNTC6(K)
!           IF ((CONST1*DNTC6(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC6(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC6(K)=-NTC1(K)/CONST1
!            DMTC6(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1*DNTC6(K)+NTC1(K).LT.0.d0) THEN                   !  IG 15May2014
            DNTC6(K)=-NTC1(K)/CONST1
           ENDIF
           IF (CONST1*DMTC6(K)+MTC1(K).LT.0.d0) THEN
            DMTC6(K)=-MTC1(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTC6(K)
           DSEGN=DSEGN+CONST1*DNTC6(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 143
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTCIR2(K)=CORRM*DMTCIR2(K)
            DNTCIR2(K)=CORRN*DNTCIR2(K)
            DMTGRA2(K)=CORRM*DMTGRA2(K) 
            DNTGRA2(K)=CORRN*DNTGRA2(K)
            DMTRIME2(K)= CORRM*DMTRIME2(K)
            DNTRIME2(K)=CORRN*DNTRIME2(K)
           ENDDO
          ENDIF
 143      CONTINUE
           if (ibug3.eq.1) then
            write(98,*)'corrm,corrn after drop - snow coll'
            write(98,*) corrm,corrn
           endif
         ELSE
          if (ibug3.eq.1) then
           write(98,*) 'before coag5m snow'
          endif
        WRITE (mp_debug,*) ' DEBUG: calling COAG5M'
        if (kz.eq.1) CALL wrf_debug(250, mp_debug)

          CALL COAG5M (K4,AC,BC,CC,DC,ACIR,BCIR,CCIR,DCIR,DMTC6,DNTC6,  &
     &               DMTCIR2,DNTCIR2,CCRIW,CCCRIW,CCCVRIW,C5VRIW,FQSM,  &
     &               DMTSNOWM2,DMTCIR2V,DNTCIR2V,ibug3)

!     correction of  modified kernel
!     correction was made on 08. 20. 2013 to avoid the division by zero
          if (abs(VTSNDM-VTWATM) .gt. 1.E-5) then
             CORR = abs(VTSNWM-VTWATM)/abs(VTSNDM-VTWATM)*                 &
     &                              (DSNWM+DWATM)**2/(DSNDM+DWATM)**2
             CORR = MIN(1.0, CORR)
           else
             CORR = 1.0
           endif
!          CORR = 1.0
!2013.04.15.
          CORR = CORR*EWRIC
          DO K = 1,K4
           DNTC6(K)=CORR*DNTC6(K)
           DMTC6(K)=CORR*DMTC6(K)
           DMTCIR2(K)=CORR*DMTCIR2(K)
           DNTCIR2(K)=CORR*DNTCIR2(K)
           DMTCIR2V(K)=CORR*DMTCIR2V(K)
           DNTCIR2V(K)=CORR*DNTCIR2V(K)
           DMTSNOWM2(K)=CORR*DMTSNOWM2(K)
          ENDDO
!
!     if  dmtc6 is greater than the mixing ratio of the water drops the calculated
!     values are renormalized
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1*DMTC6(K)
           DSSN1=DSSN1+CONST1*DNTC6(K)
!           IF ((CONST1*DNTC6(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC6(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC6(K)=-NTC1(K)/CONST1
!            DMTC6(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1*DNTC6(K)+NTC1(K).LT.0.d0) THEN                   !  IG 15May2014
            DNTC6(K)=-NTC1(K)/CONST1
           ENDIF
           IF (CONST1*DMTC6(K)+MTC1(K).LT.0.d0) THEN
            DMTC6(K)=-MTC1(K)/CONST1
           ENDIF
           DSEGM=DSEGM+CONST1*DMTC6(K)
           DSEGN=DSEGN+CONST1*DNTC6(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 146
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTCIR2(K)=CORRM*DMTCIR2(K)
            DNTCIR2(K)=CORRN*DNTCIR2(K)            
            DMTSNOWM2(K)=CORRM*DMTSNOWM2(K)
            DMTCIR2V(K)=CORRM*DMTCIR2V(K)
            DNTCIR2V(K)=CORRN*DNTCIR2V(K)
           ENDDO
          ENDIF
 146     CONTINUE

         ENDIF

         DO K = 1, K4
          NTC1(K) = NTC1(K) + CONST1*DNTC6(K)
          MTC1(K) = MTC1(K) + CONST1*DMTC6(K)
          NTC1(K) = DMAX1(0.d0,NTC1(K))
          MTC1(K) = DMAX1(0.d0,MTC1(K))
         ENDDO
        ENDIF                ! endif for snow  - drop collision 
!     
!     a different subroutine has to be used in the melting region, because in this case
!     no graupel form even if the size of the drops is larger than that of the collector snow. The kernel should also depends on the melted fraction 
!     
        IF (NSNOW(KZ)> EPS.AND.NICE(KZ) > EPS) THEN
         IF (tz_old(KZ) < T00) THEN
!     coag. of  pristine ice crystals and snow flake
           IF (TK < T00) THEN ! coalesence efficiency of snow flake - pristine ice cr.collision
             ERICIC=EXP(0.09*(TK-T00))
           ELSE
             ERICIC=1.00
           ENDIF
           ERICIC=0.10   ! Paul's suggestion
        WRITE (mp_debug,*) ' DEBUG: calling COAG3  k=',kz
        CALL wrf_debug(250, mp_debug)
           CALL COAG3(K4,ACI,BCI,CCI,DCI,ACIR,BCIR,CCIR,DCIR,DMTCI9,    &
     &          DNTCI9,DMTCIR7,DNTCIR7,CCCICIR,CCCCICIR,CCCVCICIR,      &
     &          C5VCICIR,FQ,DMTRIME4,FN,DNTRIME4)

!     
!     if  roa1*dmtcir7(k)+mtcir(k) is less than 0 values are renormalized
!     
           DSEGN1=0.d0
           DSEGN2=0.d0
           CONST11=DBLE(CONST1*ERICIC)
           DSSM1=0.d0
           DSSN1=0.d0
           DSSM2=0.d0
           DO K=1,K4
            dssm1=dssm1+CONST11*DMTCI9(K)
            dssn1=dssn1+CONST11*DNTCI9(K)
            IF (CONST11*DNTCIR7(K)+NTCIR(K).LT.0.d0) THEN
              DSEGN1=DSEGN1+CONST11*DNTCIR7(K)
              DNTCIR7(K)=-NTCIR(K)/CONST11
              DSEGN2=DSEGN2-NTCIR(K)
            ENDIF
            IF (CONST11*DMTCIR7(K)+MTCIR(K).LT.0.d0) THEN
              DMTCIR7(K)=-MTCIR(K)/CONST11
            ENDIF
            DSSM2=DSSM2+CONST11*DMTCIR7(K)
           ENDDO
           dhiban=ABS(DSEGN1-DSEGN2)
           corrn=1.0
           corrm=1.0
           IF (DSSN1.LT.0.0) THEN
             corrn=1.0+dhiban/DSSN1
           ENDIF
           IF (DSSM1.LT.0.0) THEN
                     corrm=dabs(DSSM2/DSSM1)
           ENDIF
           IF (corrm.gt.1.d0) corrm=1.d0
           IF (corrn.gt.1.d0) corrn=1.d0
           IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
             DO K=1,K4
               dmtci9(K)=corrm*dmtci9(K)
               dntci9(K)=corrn*dntci9(K)
             ENDDO
           ENDIF
         ENDIF            ! endif for tk < t00
        ENDIF               ! endif for ncir > eps and nic > eps
        IF (NGRA(KZ) > EPS  .AND. NL(KZ) > EPS) THEN
         DTGRWAT=0.1 !DT/10. !0.1
         NSTEP=DT/DTGRWAT
         CONST1T = CONST1/DT*DTGRWAT
         if (ibug1.eq.1) then
          write(98,*) 'start graupel - water'
          write(98,*) 'dtgrwat,nstep,const1t',dtgrwat,nstep,const1t
         endif
         NLT=0.0
         NGRAT=0.0
         DO K=1,K4
          MTCT(K)=MTC1(K)
          NTCT(K)=NTC1(K)
          MTGRAT(K)=MTGRA(K)
          NTGRAT(K)=NTGRA(K)
          MTGRAMT(K)=MTGRAM(K)
          NLT=NLT+NTC1(K)
          NGRAT=NGRAT+NTGRA(K)
         ENDDO
!     
!     coag. of graupel particles and  drops  + H-M ice multiplication
!     
         IF (tz_old(KZ)  < T00) THEN
          DO ISTEP =1,NSTEP
           CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
           CALL COEF1(K4,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,KMINGRA,   &
     &                KMAXGRA,NGRAT)
           DSNTCI6T=0.0
           DO K=1,K4
            DMTC8T(K)=0.d0
            DNTC8T(K)=0.d0
            DMTGRA3T(K)=0.d0
            DNTGRA3T(K)=0.d0
           ENDDO
           CALL COAG31 (K4,ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,       &
     &      DMTC8T,DNTC8T,DMTGRA3T,DNTGRA3T,CCGW1,CCCGW1,CCCVGW1,C5VGW1,  &
     &      CICEM,DSNTCI6T,tz_old(kz))
!           CALL COAG31 (K4,AC,BC,CC,DC,agra,bgra,cgra,dgra,dmtc8,dntc8,  &
!     &     dmtgra3,dntgra3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,CICEM,            &
!     &     DSNTCI6(KZ),tz_old(kz))

          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1T*DMTC8T(K)
           DSSN1=DSSN1+CONST1T*DNTC8T(K)
!           IF ((CONST1*DNTC8(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC8(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC8(K)=-NTC1(K)/CONST1
!            DMTC8(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1T*DNTC8T(K)+NTCT(K).LT.0.d0) THEN                   !  IG 15May2014
             DNTC8T(K)=-NTCT(K)/CONST1T
           ENDIF
           IF (CONST1T*DMTC8T(K)+MTCT(K).LT.0.d0) THEN
             DMTC8T(K)=-MTCT(K)/CONST1T
           ENDIF
           DSEGM=DSEGM+CONST1T*DMTC8T(K)
           DSEGN=DSEGN+CONST1T*DNTC8T(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 247
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTGRA3T(K)=CORRM*DMTGRA3T(K)
            DNTGRA3T(K)=CORRN*DNTGRA3T(K)
           ENDDO
          ENDIF
247      CONTINUE

!     calculation of the Hallett - Mossop ice multiplication rate
!     DSNTCI6(KZ)=0.0
!     no ice multiplication if dsntci6z(kz) = 0.0
!           IF (TK < 265.16 .OR. tk > 270.16) GOTO 110
!           IF (TK  > 268.15) THEN
!             FP = (270.16-TK)/2.d0
!           ELSE
!             FP  = (TK-265.15)/3.d0
!           ENDIF
           FP=0.0
           IF (TZ_OLD(KZ) < 265.16 .OR. TZ_OLD(KZ) > 270.16) GOTO 110
           IF (TZ_OLD(KZ)  > 268.15) THEN
             FP = (270.16-TZ_OLD(KZ))/2.d0
           ELSE
             FP  = (TZ_OLD(KZ)-265.16)/3.d0
           ENDIF
 110       DSNTCI6T=DSNTCI6T*FP*0.16
           DSMTCI6(KZ)=DSNTCI6(KZ)+DSNTCI6T*DTGRWAT !*1.5*M(2)
            NLT=0.0
            NGRAT=0.0
            DO K = 1,K4
             NTCT(K)=NTCT(K)+CONST1T*DNTC8T(K)
             MTCT(K)=MTCT(K)+CONST1T*DMTC8T(K)
             NTGRAT(K)=NTGRAT(K)+CONST1T*DNTGRA3T(K)
             MTGRAT(K)=MTGRAT(K)+CONST1T*DMTGRA3T(K)
             NLT=NLT+NTCT(K)
             NGRAT=NGRAT+NTGRAT(K)
             DNTC8(K)=DNTC8(K)+DTGRWAT*DNTC8T(K)
             DMTC8(K)=DMTC8(K)+DTGRWAT*DMTC8T(K)
             DNTGRA3(K)=DNTGRA3(K)+DTGRWAT*DNTGRA3T(K)
             DMTGRA3(K)=DMTGRA3(K)+DTGRWAT*DMTGRA3T(K)
            ENDDO
          ENDDO         !  enddo for the loop of small time step
          DO K=1,K4
           NTC1(K)=NTCT(K)
           MTC1(K)=MTCT(K)
           DNTC8(K)=DNTC8(K)/DT
           DMTC8(K)=DMTC8(K)/DT
           DNTGRA3(K)=DNTGRA3(K)/DT
           DMTGRA3(K)=DMTGRA3(K)/DT
          ENDDO
          DSNTCI6(KZ)=DSNTCI6(KZ)/DT
          DSMTCI6(KZ)=DSNTCI6(KZ)*1.5*M(2)
         ELSE             !   else  for tk < t00
!     if the temperature is over the melting temperature no ice multiplications occures,
!     it is supposed that the melting of the graupel particles does not affect the drop - graupel collison kernels
           if (ibug3.eq.1) then
            write(98,*) 'befor graupel coag5m'
           endif
!!           CALL COAG5M(K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,DMTC8,DNTC8,  &
!!     &                 DMTGRA3,DNTGRA3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,FQGM,&    
!!     &                 DMTGRAM3,DMTGRA3V,DNTGRA3V,ibug3)

!          CALL COAG5M1(K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,DMTC8,DNTC8,DMTC8S,  &
!     &                 DNTC8S,DMTGRA3,DNTGRA3,CCGW1,CCCGW1,CCCVGW1,C5VGW1,FQGM,&
!     &                 DMTGRAM3,DMTGRA3V,DNTGRA3V,DT,ibug3,ii,kz,times)
          DO ISTEP =1,NSTEP
           CALL COEF1(K4,ACT,BCT,CCT,DCT,MTCT,NTCT,KMIN,KMAX,NLT)
           CALL COEF1(K4,AGRAT,BGRAT,CGRAT,DGRAT,MTGRAT,NTGRAT,KMINGRA,   &
     &                KMAXGRA,NGRAT)

           DO K=1,K4
            DMTC8T(K)=0.d0
            DNTC8T(K)=0.d0
            DMTC8ST(K)=0.d0
            DNTC8ST(K)=0.d0
            DMTGRA3T(K)=0.d0
            DNTGRA3T(K)=0.d0
            DMTGRAM3T(K)=0.d0
            DMTGRA3VT(K)=0.d0
            DNTGRA3VT(K)=0.d0
            FQGMT(K)=0.0
            IF (MTGRAT(K).GT.0.0) THEN
             FQGMT(K)=MTGRAMT(K)/MTGRAT(K)
            ENDIF
            FQGMT(K)=MIN(1.0,MAX(0.0,FQGMT(K)))
           ENDDO
           CALL COAG5M1(K4,ACT,BCT,CCT,DCT,AGRAT,BGRAT,CGRAT,DGRAT,                 &
     &                NTGRAT,MTGRAT,MTGRAMT,                                        &  
     &                DMTC8T,DNTC8T,DMTC8ST,DNTC8ST,DMTGRA3T,DNTGRA3T,CCGW1,CCCGW1, &
     &                CCCVGW1,C5VGW1,FQGMT,DMTGRAM3T,DMTGRA3VT,DNTGRA3VT,DT,CONST1T,&
     &                 ibug1,ii,kz,times)
     
          DSEGN=0.d0
          DSEGM=0.d0
          DSSM1=0.d0
          DSSM2=0.d0
          DSSN1=0.d0
          DO K=1,K4
           DSSM1=DSSM1+CONST1T*DMTC8T(K)
           DSSN1=DSSN1+CONST1T*DNTC8T(K)
!           IF ((CONST1*DNTC8(K)+NTC1(K).LT.0.d0) .OR.                    &
!     &                       (CONST1*DMTC8(K)+MTC1(K).LT.0.d0)) THEN
!            DNTC8(K)=-NTC1(K)/CONST1
!            DMTC8(K)=-MTC1(K)/CONST1
!           ENDIF
           IF (CONST1T*DNTC8T(K)+NTCT(K).LT.0.d0) THEN                   !  IG 15May2014
             DNTC8T(K)=-NTCT(K)/CONST1T
           ENDIF
           IF (CONST1T*DMTC8T(K)+MTCT(K).LT.0.d0) THEN
             DMTC8T(K)=-MTCT(K)/CONST1T
           ENDIF
           DSEGM=DSEGM+CONST1T*DMTC8T(K)
           DSEGN=DSEGN+CONST1T*DNTC8T(K)
          ENDDO
          IF (DSSN1.GT.-EPS) GOTO 147
          CORRM=DSEGM/DSSM1
          CORRN=DSEGN/DSSN1
          IF (CORRM.GT.1.d0) CORRM=1.d0
          IF (CORRN.GT.1.d0) CORRN=1.d0
          IF (CORRN.LT.1.d0.OR.CORRM.LT.1.d0) THEN
           DO K=1,K4
            DMTGRA3T(K)=CORRM*DMTGRA3T(K)
            DNTGRA3T(K)=CORRN*DNTGRA3T(K)
            DMTGRA3VT(K)=CORRM*DMTGRA3VT(K)
            DNTGRA3VT(K)=CORRN*DNTGRA3VT(K)
            DMTGRAM3T(K)=CORRM*DMTGRAM3T(K)
            DNTC8ST(K)=CORRN*DNTC8ST(K)
            DMTC8ST(K)=CORRM*DMTC8ST(K)
           ENDDO
          ENDIF
 147      CONTINUE
!   
!    calculation of the constrain for the graupel particles
!
           dsegn1=0.d0
           dsegn2=0.d0
           dssm1=0.d0
           dssn1=0.d0
           dssm2=0.d0
           DO K=1,K4
            dssm1=dssm1+const1t*dmtgra3t(K)
            dssn1=dssn1+const1t*DNTC8T(K)
            IF (const1t*dntgra3t(K)+ntgrat(K) < 0.d0) THEN
             dsegn1=dsegn1+const1t*dntgra3t(K)
             dntgra3t(K)=-ntgrat(K)/const1t
             dsegn2=dsegn2-ntgrat(K)
            ENDIF
            IF (const1t*dmtgra3t(K)+mtgrat(K) < 0.d0) THEN
             dmtgra3t(K)=-mtgrat(K)/const1t
            ENDIF
            dssm2=dssm2+const1t*dmtgra3t(K)
           ENDDO
           dhiban=dabs(dsegn1-dsegn2)
           corrn=1.d0
           corrm=1.d0
           IF (dssn1 < 0.d0) THEN
            corrn=1.d0+dhiban/dssn1
           ENDIF
           IF (dssm1 < 0.d0) THEN
            corrm=dabs(dssm2/dssm1)
           ENDIF
           IF (CORRM > 1.d0) CORRM=1.d0
           IF (CORRN > 1.d0) CORRN=1.d0
           IF (CORRN < 1.d0 .OR. CORRM < 1.d0) THEN
            DO K=1,K4
             DMTC8T(K)=corrm*DMTC8T(K)
             DNTC8T(K)=corrn*DNTC8T(K)
             DMTGRA3VT(K)=CORRM*DMTGRA3VT(K)
             DNTGRA3VT(K)=CORRN*DNTGRA3VT(K)
             DMTGRAM3T(K)=CORRM*DMTGRAM3T(K)
             DNTC8ST(K)=CORRN*DNTC8ST(K)
             DMTC8ST(K)=CORRM*DMTC8ST(K)
            ENDDO
           ENDIF
           NLT=0.0
           NGRAT=0.0
           DO K = 1,K4
             NTCT(K)=NTCT(K)+CONST1T*DNTC8T(K)      !!     +DNTC8ST(K))
             MTCT(K)=MTCT(K)+CONST1T*DMTC8T(K)      !!     +DMTC8ST(K))
             NTGRAT(K)=NTGRAT(K)+CONST1T*DNTGRA3T(K)
             MTGRAT(K)=MTGRAT(K)+CONST1T*DMTGRA3T(K)
             MTGRAMT(K)=MTGRAMT(K)+CONST1T*DMTGRAM3T(K)
             NTCT(K)=DMAX1(0.d0,NTCT(K))
             MTCT(K)=DMAX1(0.d0,MTCT(K))
             NTGRAT(K)=DMAX1(0.d0,NTGRAT(K))
             MTGRAT(K)=DMAX1(0.d0,MTGRAT(K))
             MTGRAMT(K)=DMAX1(0.d0,MTGRAMT(K))
             NLT=NLT+NTCT(K)
             NGRAT=NGRAT+NTGRAT(K)
             DNTC8(K)=DNTC8(K)+DTGRWAT*DNTC8T(K)
             DMTC8(K)=DMTC8(K)+DTGRWAT*DMTC8T(K)
             DNTC8S(K)=DNTC8S(K)+DTGRWAT*DNTC8ST(K)
             DMTC8S(K)=DMTC8S(K)+DTGRWAT*DMTC8ST(K)
             DNTGRA3(K)=DNTGRA3(K)+DTGRWAT*DNTGRA3T(K)
             DMTGRA3(K)=DMTGRA3(K)+DTGRWAT*DMTGRA3T(K)
             DNTGRA3V(K)=DNTGRA3V(K)+DTGRWAT*DNTGRA3VT(K)
             DMTGRA3V(K)=DMTGRA3V(K)+DTGRWAT*DMTGRA3VT(K)
             DMTGRAM3(K)=DMTGRAM3(K)+DTGRWAT*DMTGRAM3T(K)
           ENDDO
          ENDDO         !  enddo for the loop of small time step
          if (ibug1.eq.1) then
           write(98,*) 'after loop for the small timestep'
          endif
          DO K=1,K4
           NTC1(K)=NTCT(K)
           MTC1(K)=MTCT(K)
           if (ibug1.eq.1) then
             write(98,*) 'k,ntc1,dntc8,dntc8s',k,ntc1(k),dntc8(k),dntc8s(k)
             write(98,*) 'k,mtc1,dmtc8,dmtc8s',k,mtc1(k),dmtc8(k),dmtc8s(k)
           endif
           DNTC8(K)=DNTC8(K)/DT
           DMTC8(K)=DMTC8(K)/DT
           DNTGRA3(K)=DNTGRA3(K)/DT
           DMTGRA3(K)=DMTGRA3(K)/DT
           DNTC8S(K)=DNTC8S(K)/DT
           DMTC8S(K)=DMTC8S(K)/DT
           DNTGRA3V(K)=DNTGRA3V(K)/DT
           DMTGRA3V(K)=DMTGRA3V(K)/DT
           DMTGRAM3(K)=DMTGRAM3(K)/DT
          ENDDO
         ENDIF 
         DO K = 1,K4
          NTC1(K)=NTC1(K) + CONST1*DNTC8(K)
          MTC1(K)=MTC1(K) + CONST1*DMTC8(K)
          NTC1(K)=DMAX1(0.d0,NTC1(K))
          MTC1(K)=DMAX1(0.d0,MTC1(K))
         ENDDO
        ENDIF               ! endif for ngr > eps and nw > eps
        IF (NGRA(KZ) > EPS) THEN
      
!     diffusional growth of graupel particles
! xue if the water mass on graupel is reduced after depos, where the heat is accounted for in meltgra?
          CALL DEPOS(k4,kmingra,kmaxgra,QGRA(KZ),NGRA(KZ),              &
     &        agra,bgra,cgra,dgra,DSNTGRA10(KZ),DSMTGRA10(KZ),FQGM,     &
     &        p,TKE1,QVE1,ROA,ld,kg,diff,visc,         &
     &        errdep1,sdep1,dt,ibug0)
         DSNTGRA10(KZ) = DSNTGRA10(KZ)/DT
         DSMTGRA10(KZ) = DSMTGRA10(KZ)/DT
         DO K = 1, K4
           DSMTGRAM0(KZ)=DSMTGRAM0(KZ)+(MTGRAM(K)-QGRAM0(KZ,K))/DT ! xue add /DT
         ENDDO
! bulk ice diffusion rate  
         DMIZ_DIFF(KZ) = DMIZ_DIFF(KZ) + DSMTGRA10(KZ)
         DMWIZ_DIFF(KZ)= DMWIZ_DIFF(KZ)+ DSMTGRAM0(KZ) !/DT
! bulk ice diffusion rate  
        ENDIF

!! Commented out by SN, 2018
!       IF (RADA  >= 1.0e-6) THEN
!          CALL GRAVCOAG(K4,AC,BC,CC,DC,DNTC4,DMTC4,CA6,ROA)          ! collection of IN by drops due to grav. coag.
!        ENDIF
!! 
        IF (NL(KZ) > EPS) THEN
!         IF (TK < 268.0) THEN
         IF (TZ_OLD(KZ) < 268.0) THEN
          CALL FREEZINGI(K4,NTC1,MTC1,DNTCI1,DMTCI1,DNTGRA0,DMTGRA0,DT, &
     &                   p,TKE1,QVE1)
         ENDIF
        ENDIF
        NTCI(2) = NTCI(2) + DSNTCI6(KZ)*DT
        MTCI(2) = MTCI(2) + DSNTCI6(KZ)*1.5*M(2)*DT
! 2222   continue
!+---+-----------------------------------------------------------------+

        WRITE (mp_debug,*) ' DEBUG:  done primary microphys steps'
        CALL wrf_debug(250, mp_debug)

        DO K=1,K4-1
!         NTC(K)=NTC(K)+DT*(ROA1*(dntc1(K)+DNTC1B(K)+dntc5(K)+dntc6(K)+  &
!     &           dntc8(K))-dntgra0(K)-dntci1(K)-dntgra4(K)-             &
!     &          dntci4(K))
         NTC(K)=NTC(K)+DT*(ROA1*(dntc1(K)+DNTC1B(K)+dntc5(K)+dntc6(K)+  &
     &           dntc8(K)+dntc8S(K))-dntgra0(K)-dntci1(K)-dntgra4(K)-   &
     &          dntci4(K))
!         MTC(K)=MTC(K)+DT*(ROA1*(dmtc1(K)+DMTC1B(K)+dmtc5(K)+dmtc6(K)+  &
!     &               dmtc8(K))-dmtgra0(K)-dmtci1(K)-dmtgra4(K)-         &
!     &              dmtci4(K))
         MTC(K)=MTC(K)+DT*(ROA1*(dmtc1(K)+DMTC1B(K)+dmtc5(K)+dmtc6(K)+  &
     &           dmtc8(K)+dmtc8S(K))-dmtgra0(K)-dmtci1(K)-dmtgra4(K)-   &
     &              dmtci4(K))
         NTCIR(K)=NTCIR(K)+CONST1*(DNTCIR1(K)+DNTCIR2(K)+               &
     &             ERICRIC*DNTCIR4(K)+EICIC*DNTCIR5(K)+                 & 
     &            ERICIC*DNTCIR7(K))
         MTCIR(K)=MTCIR(K)+CONST1*(DMTCIR1(K)+DMTCIR2(K)+               &
     &             ERICRIC*DMTCIR4(K)+EICIC*DMTCIR5(K)+                 &
     &            ERICIC*DMTCIR7(K))
         NTCI(K)=NTCI(K)+DT*(DNTCI1(K)+DNTCI4(K)+ROA1*(DNTCI3(K)+       &
     &           EICIC*DNTCI5(K)+ERICIC*DNTCI9(K)))
         MTCI(K)=MTCI(K)+DT*(DMTCI1(K)+DMTCI4(K)+ROA1*(DMTCI3(K)+       &
     &           EICIC*DMTCI5(K)+ERICIC*DMTCI9(K)))
         NTGRA(K)=NTGRA(K)+DT*(ROA1*((DNTGRA2(K)+                       &
     &            DNTGRA3(K)+DNTGRA5(K)))+DNTGRA0(K)+DNTGRA4(K))
         MTGRA(K)=MTGRA(K)+DT*(ROA1*((DMTGRA2(K)+                       &
     &              DMTGRA3(K)+DMTGRA5(K)))+DMTGRA0(K)+DMTGRA4(K))   

         
!     
!     transfer of the small ice particles (k<10) into the pristine ice category
!     
         IF (K < 10) THEN
          DSSN1 = NTCIR(K) + NTGRA(K)
          DSSM1 = MTCIR(K) + MTGRA(K)
          NTCI(K) = NTCI(K) + DSSN1
          MTCI(K) = MTCI(K) + DSSM1
          DSNTCI11(KZ) = DSNTCI11(KZ) + DSSN1/DT   ! xue add /DT for the following terms
          DSMTCI11(KZ) = DSMTCI11(KZ) + DSSM1/DT
          DSNTCIR9(KZ) = DSNTCIR9(KZ) - NTCIR(K)/DT
          DSMTCIR9(KZ) = DSMTCIR9(KZ) - MTCIR(K)/DT
          DSNTGRA12(KZ) = DSNTGRA12(KZ) - NTGRA(K)/DT
          DSMTGRA12(KZ) = DSMTGRA12(KZ) - MTGRA(K)/DT
          NTCIR(K)=0.d0
          MTCIR(K)=0.d0
          NTGRA(K)=0.d0
          MTGRA(K)=0.d0
         ENDIF
!     corrections for negativ values
         IF (NTC(K).LT.0.d0.OR.MTC(K).LT.0.d0) THEN
           NTC(K)=0.d0
           MTC(K)=0.d0
         ENDIF
         IF (NTCI(K).LT.0.d0.OR.MTCI(K).LT.0.d0) THEN
           NTCI(K)=0.d0
           MTCI(K)=0.d0
         ENDIF
         IF (NTCIR(K).LT.0.d0.OR.MTCIR(K).LT.0.d0) THEN
           MTCIR(K)=0.d0
           NTCIR(K)=0.d0
         ENDIF
         IF (NTGRA(K).LT.0.d0.OR.MTGRA(K).LT.0.d0) THEN
           MTGRA(K)=0.d0
           NTGRA(K)=0.d0
         ENDIF
        ENDDO
        if (ibug3.eq.1) then
         write(98,*) 'after sum production terms1 tk',tz_old(KZ)
         write(98,*) ntcir(34),mtcir(34)
        endif
        IF (tz_old(KZ) > T00) THEN

!     calculations of melting of the snow flakes and  graupel particles
!     
!     The melting changes the melted fraction of the snow and graupel particles
!     If the melted fraction becomes equal to one the solid particles are transfered to water drops
!     
!     melting of the rimed ice
!     

         IF (QSNOW(KZ) > EPS) THEN

      if (debug_flag .and. ibug4.eq.1) then
        WRITE (mp_debug,*) '   DEBUG MELT-1, snow (kz,Temp) ', kz,tz_old(kz)
        CALL wrf_debug(150, mp_debug)
        DO K = 1, K4
           WRITE (mp_debug,*) '       (bin,num,mass,melt) ', k,nsnow0(kz,k),qsnow0(kz,k),qsnowm0(kz,k)
           CALL wrf_debug(150, mp_debug)
        enddo
      endif
           DO K=1,K4
            MTSNOWI(K)= QSNOW0(KZ,K)-QSNOWM0(KZ,K)
            NTCIR1(K)=NSNOW0(KZ,K)
            MTCIR1(K)=QSNOW0(KZ,K)
            IF (MTSNOWI(K) < 0.0) THEN
             MTSNOWI(K) =0.0
             MTSNOWM(K)= QSNOW0(KZ,K)
            ENDIF
           ENDDO
          CALL MELTSNOW (K4,NTCIR1,MTCIR1,MTSNOWI,DMTSNOWM3,FQSM,       &
     &     DNTCIR2V,DMTCIR2V,DQSHC,ACIR,BCIR,CCIR,DCIR,ROA1,DT,         &
     &     ROA,P,TKE1,QVE1,DIFF,KG,VISC,LD,IBUG4,KZ)

      if (debug_flag .and. ibug4.eq.1) then
        WRITE (mp_debug,*) '   DEBUG MELT-2'
        CALL wrf_debug(150, mp_debug)
        DO K = 1, K4
           WRITE (mp_debug,*) '       (bin,num,mass,melt,rate) ', k,nsnow0(kz,k),qsnow0(kz,k),qsnowm0(kz,k),DMTSNOWM3(k)
           CALL wrf_debug(150, mp_debug)
        enddo
      endif

         ENDIF            !  endif for melting of snow flakes
!     
!     melting of graupel
!     
         IF (QGRA(KZ) > 0.0) THEN
           DO K=1,K4
            MTGRAI(K)= QGRA0(KZ,K)-QGRAM0(KZ,K)
            NTGRA1(K)=NGRA0(KZ,K)
            MTGRA1(K)=QGRA0(KZ,K)
            IF (MTGRAI(K) < 0.0) THEN
             MTGRAI(K) =0.0
             MTGRAM(K)= QGRA0(KZ,K)
            ENDIF           
           ENDDO
              
! xue add LD to meltgra to account for refreezing
          CALL MELTGRA (K4,NTGRA1,MTGRA1,MTGRAI,DMTGRAM4,FQGM,        &
     &         DNTGRA3V,DMTGRA3V,DQGRHC,AGRA,BGRA,CGRA,DGRA,DT,       &
     &         ROA,P,TKE1,QVE1,DIFF,KG,VISC,LD,ibug0)                   
         ENDIF            ! end if for graupel particles

          
         DO K=1,K4
          MTSNOWM(K)=MTSNOWM(K)+                                        &
     &         (DMTSNOWM1(K)+DMTSNOWM2(K))*CONST1+DMTSNOWM3(K)*DT
          IF (MTSNOWM(K).LT.0.0) MTSNOWM(K)=0.0
      if (debug_flag .and. MTSNOWM(K).ne.0.0) then
        WRITE (mp_debug,*) '   total MTSNOWM ', k, MTSNOWM(K)
        CALL wrf_debug(150, mp_debug)
      endif
     

          IF (MTSNOWM(K).GE.MELTS_THRES*MTCIR(K)) THEN ! the snow flakes have melted completly in the k-th bin
            MTC(K)=MTC(K)+MTCIR(K)
            NTC(K)=NTC(K)+NTCIR(K)
! xue question: the melting of the increase of MTSNOWM should be counted before, DMTC10 is overestimated by this way!
            DNTC10(K)=DNTC10(K)+NTCIR(K)/DT
            DMTC10(K)=DMTC10(K)+MTCIR(K)/DT
            DSMTCIR8(KZ) = DSMTCIR8(KZ) - MTCIR(K)/DT
            DSNTCIR8(KZ) = DSNTCIR8(KZ) - NTCIR(K)/DT
            IF (MTSNOWM(K).LT.MTCIR(K)) THEN                   ! xue question: should this be outside of the upper IF statement?
             DMTSNOWM3(K) = DMTSNOWM3(K) + (MTCIR(K)-MTSNOWM(K))/DT
             DSMTSNOWM4(KZ)=DSMTSNOWM4(KZ)+(MTCIR(K)-MTSNOWM(K))/DT
            ENDIF
            MTCIR(K)=0.0
            NTCIR(K)=0.0
            MTSNOWM(K)=0.0
! xue add shedding test here
          ELSE
           IF(MELT_SHED) THEN
           if(MTSNOWM(K).gt.1.e-40 .and. NTCIR(K).gt.eps) then 
            MEANMSWM=MTSNOWM(K)/NTCIR(K)
            MEANMSM=(MTCIR(K)-MTSNOWM(K))/NTCIR(K)
            if(MEANMSWM.lt.M(1)) goto 111
            DO KK=1, K
             if(MEANMSWM.lt.M(KK+1)) then
              DNTC11(KK)=DNTC11(KK)+NTCIR(K)/DT
              DMTC11(KK)=DMTC11(KK)+MTSNOWM(K)/DT
              DNTCIR10(K)=DNTCIR10(K)-NTCIR(K)/DT
              DMTCIR10(K)=DMTCIR10(K)-MTCIR(K)/DT
              goto 109
             end if
            ENDDO
109         continue
            DO KK=1, K
             if(MEANMSM.lt.M(KK+1)) then
              DNTCIR11(KK)=DNTCIR11(KK)+NTCIR(K)/DT
              DMTCIR11(KK)=DMTCIR11(KK)+(MTCIR(K)-MTSNOWM(K))/DT
              MTSNOWM(K)=0.0
              goto 111
             end if
            ENDDO
           end if     
           END IF
! xue finish shedded test
          ENDIF
111       continue
          MTGRAM(K)=MTGRAM(K)+DMTGRAM3(K)*CONST1+DMTGRAM4(K)*DT
          IF (MTGRAM(K).LT.0.0) MTGRAM(K)=0.0

          IF (MTGRAM(K) >= MELTG_THRES*MTGRA(K)) THEN
            NTC(K)=NTC(K)+NTGRA(K)
            MTC(K)=MTC(K)+MTGRA(K)
! xue question: the melting of the increase of MTGRAM should be counted before, DMTC10 is overestimated by this way!
            DNTC10(K)= DNTC10(K)+NTGRA(K)/DT
            DMTC10(K)= DMTC10(K)+MTGRA(K)/DT
! xue quesiton: should the following terms divided by DT?
!            DSMTGRA11(KZ) = DSMTGRA11(KZ) - MTGRA(K)
!            DSNTGRA11(KZ) = DSNTGRA11(KZ) - NTGRA(K)
            DSMTGRA11(KZ) = DSMTGRA11(KZ) - MTGRA(K)/DT
            DSNTGRA11(KZ) = DSNTGRA11(KZ) - NTGRA(K)/DT
            IF (MTGRAM(K) .LT. MTGRA(K)) THEN
             DMTGRAM4(K) = DMTGRAM4(K) + (MTGRA(K)-MTGRAM(K))/DT
             DSMTGRAM5(KZ)=DSMTGRAM5(KZ)+(MTGRA(K)-MTGRAM(K))/DT
            ENDIF
            NTGRA(K)=0.0
            MTGRA(K)=0.0
            MTGRAM(K)=0.0
! xue add shedded test here
          ELSE
           IF(MELT_SHED) THEN
           if(MTGRAM(K).gt.1.e-40 .and. NTGRA(K).gt.eps) then
            MEANMGWM=MTGRAM(K)/NTGRA(K)
            MEANMGM=(MTGRA(K)-MTGRAM(K))/NTGRA(K)
            if(MEANMGWM.lt.M(1)) goto 112
            DO KK=1, K
             if(MEANMGWM.lt.M(KK+1)) then
              DNTC12(KK)=DNTC12(KK)+NTGRA(K)/DT
              DMTC12(KK)=DMTC12(KK)+MTGRAM(K)/DT
              DNTGRA13(K)=DNTGRA13(K)-NTGRA(K)/DT
              DMTGRA13(K)=DMTGRA13(K)-MTGRA(K)/DT
              goto 117
             end if
            ENDDO
117         continue
            DO KK=1, K
             if(MEANMGM.lt.M(KK+1)) then
              DNTGRA14(KK)=DNTGRA14(KK)+NTGRA(K)/DT
              DMTGRA14(KK)=DMTGRA14(KK)+(MTGRA(K)-MTGRAM(K))/DT
              MTGRAM(K)=0.0
              goto 112
             end if 
            ENDDO 
           end if 
           END IF
! xue finish shedded test
          ENDIF
112       continue

!     
!     the pristine ice particles are supposed to melt immediately as the particles get into the 
!     melting zone
!     
          DNTCI10(K) = -NTCI(K)/DT
          DMTCI10(K) = -MTCI(K)/DT
          DNTC10(K) = DNTC10(K) - DNTCI10(K)
          DMTC10(K) = DMTC10(K) - DMTCI10(K)
          NTC(K) = NTC(K) + NTCI(K)
          MTC(K) = MTC(K) + MTCI(K)
          NTCI(K) = 0.0
          MTCI(K) = 0.0
         ENDDO
        ENDIF               ! endif for melting (tk> 273.15 )
        if (ibug0.eq.1) then
         write(98,*) 'after all micro t_tend,qv_tend',tten1,qvten1
        endif        

! xue add for shedding
        DO K=1,K4
         NTC(K)=NTC(K)+(DNTC11(K)+DNTC12(K))*DT
         MTC(K)=MTC(K)+(DMTC11(K)+DMTC12(K))*DT
         NTCIR(K)=NTCIR(K)+(DNTCIR10(K)+DNTCIR11(K))*DT
         MTCIR(K)=MTCIR(K)+(DMTCIR10(K)+DMTCIR11(K))*DT
         NTGRA(K)=NTGRA(K)+(DNTGRA13(K)+DNTGRA14(K))*DT
         MTGRA(K)=MTGRA(K)+(DMTGRA13(K)+DMTGRA14(K))*DT
        ENDDO

!     
!     sum of the production terms over the bins
!     
        DO K=1,K4
! xue add for shed
         dsntc11(KZ)=dsntc11(KZ)+dntc11(K)
         dsmtc11(KZ)=dsmtc11(KZ)+dmtc11(K)
         dsntc12(KZ)=dsntc12(KZ)+dntc12(K)
         dsmtc12(KZ)=dsmtc12(KZ)+dmtc12(K)
         dsntcir10(KZ)=dsntcir10(KZ)+dntcir10(K)
         dsmtcir10(KZ)=dsmtcir10(KZ)+dmtcir10(K)
         dsntcir11(KZ)=dsntcir11(KZ)+dntcir11(K)
         dsmtcir11(KZ)=dsmtcir11(KZ)+dmtcir11(K)
         dsntgra13(KZ)=dsntgra13(KZ)+dntgra13(K)
         dsmtgra13(KZ)=dsmtgra13(KZ)+dmtgra13(K)
         dsntgra14(KZ)=dsntgra14(KZ)+dntgra14(K)
         dsmtgra14(KZ)=dsmtgra14(KZ)+dmtgra14(K)
! xue
         dsntc0(KZ)=dsntc0(KZ)+dntc0(K)
         dsntc1(KZ)=dsntc1(KZ)+dntc1(K)*roa1
         dsntc1B(KZ)=dsntc1B(KZ)+SNGL(dntc1B(K))*roa1
         dsntc3(KZ)=dsntc3(KZ)+dntc3(K)
         dsntc4(KZ)=dsntc4(KZ)+dntc4(K)*roa1
         dsntc5(KZ)=dsntc5(KZ)+dntc5(K)*roa1
         dsntc6(KZ)=dsntc6(KZ)+dntc6(K)*roa1
         dsntc8(KZ)=dsntc8(KZ)+dntc8(K)*roa1
         dsntc8s(KZ)=dsntc8s(KZ)+dntc8s(K)*roa1
         dsntc10(KZ)=dsntc10(KZ)+dntc10(K) ! +(1-IDELTA1)*ROA1*(DNTCIR1(K))
         dsmtc0(KZ)=dsmtc0(KZ)+dmtc0(K)
         dsmtc1(KZ)=dsmtc1(KZ)+dmtc1(K)*roa1
         dsmtc1B(KZ)=dsmtc1B(KZ)+dmtc1B(K)*roa1
         dsmtc3(KZ)=dsmtc3(KZ)+dmtc3(K)
         dsmtc4(KZ)=dsmtc4(KZ)+dmtc4(K)*roa1
         dsmtc5(KZ)=dsmtc5(KZ)+dmtc5(K)*roa1
         dsmtc6(KZ)=dsmtc6(KZ)+dmtc6(K)*roa1
         dsmtc8(KZ)=dsmtc8(KZ)+dmtc8(K)*roa1
         dsmtc8s(KZ)=dsmtc8s(KZ)+dmtc8s(K)*roa1
         dsmtc10(KZ)=dsmtc10(KZ)+dmtc10(K)    
         dsntci0(KZ)=dsntci0(KZ)+dntci0(K)
         dsntci1(KZ)=dsntci1(KZ)+dntci1(K)
         dsntci3(KZ)=dsntci3(KZ)+dntci3(K)*roa1
         dsntci4(KZ)=dsntci4(KZ)+dntci4(K)
         dsntci5(KZ)=dsntci5(KZ)+eicic*dntci5(K)*roa1
         dsntci9(KZ)=dsntci9(KZ)+ERICIC*dntci9(K)*roa1
         dsntci10(KZ)=dsntci10(KZ)+dntci10(K)+                          &
     &              (1-IDELTA1)*DNTCI3(K)*ROA1
         dsmtci0(KZ)=dsmtci0(KZ)+dmtci0(K)
         dsmtci1(KZ)=dsmtci1(KZ)+dmtci1(K)
         dsmtci3(KZ)=dsmtci3(KZ)+dmtci3(K)*roa1
         dsmtci4(KZ)=dsmtci4(KZ)+dmtci4(K)
         dsmtci5(KZ)=dsmtci5(KZ)+eicic*dmtci5(K)*roa1
         dsmtci9(KZ)=dsmtci9(KZ)+ERICIC*dmtci9(K)*roa1
         dsmtci10(KZ)=dsmtci10(KZ)+dmtci10(K)+                          &
     &              (1-IDELTA1)*DMTCI3(K)*ROA1
         dsntcir1(KZ)=dsntcir1(KZ)+dntcir1(K)*roa1
         dsntcir2(KZ)=dsntcir2(KZ)+dntcir2(K)*roa1
         dsntcir4(KZ)=dsntcir4(KZ)+ericric*dntcir4(K)*roa1
         dsntcir5(KZ)=dsntcir5(KZ)+EICIC*dntcir5(K)*roa1
         dsntcir7(KZ)=dsntcir7(KZ)+ERICIC*dntcir7(K)*roa1
         dsmtcir1(KZ)=dsmtcir1(KZ)+dmtcir1(K)*roa1
         dsmtcir2(KZ)=dsmtcir2(KZ)+dmtcir2(K)*roa1
         dsmtcir4(KZ)=dsmtcir4(KZ)+ericric*dmtcir4(K)*roa1
         dsmtcir5(KZ)=dsmtcir5(KZ)+EICIC*dmtcir5(K)*roa1
         dsmtcir7(KZ)=dsmtcir7(KZ)+ERICIC*dmtcir7(K)*roa1
         IF (tz_old(KZ) .LT.T00) THEN
          DSNTRIME0(KZ) = DSNTRIME0(KZ) + DNTRIME0(K)
          DSMTRIME0(KZ) = DSMTRIME0(KZ) + DMTRIME0(K)
          DSNTRIME1(KZ) = DSNTRIME1(KZ) + DNTRIME1(K)*ROA1 !CONST1
          DSNTRIME2(KZ) = DSNTRIME2(KZ) + DNTRIME2(K)*ROA1 !CONST1
          DSNTRIME3(KZ) = DSNTRIME3(KZ) + ERICRIC*DNTRIME3(K)*ROA1 !CONST1
          DSNTRIME4(KZ) = DSNTRIME4(KZ) + ERICIC*DNTRIME4(K)*ROA1 !CONST1
          DSMTRIME1(KZ) = DSMTRIME1(KZ) + DMTRIME1(K)*ROA1 !CONST1
          DSMTRIME2(KZ) = DSMTRIME2(KZ) + DMTRIME2(K)*ROA1 !CONST1
          DSMTRIME3(KZ) = DSMTRIME3(KZ) + ERICRIC*DMTRIME3(K)*ROA1 !CONST1
          DSMTRIME4(KZ) = DSMTRIME4(KZ) + ERICIC*DMTRIME4(K)*ROA1 !CONST1
         ELSE
          DSMTSNOWM1(KZ) = DSMTSNOWM1(KZ) + DMTSNOWM1(K)*ROA1 !CONST1
          DSMTSNOWM2(KZ) = DSMTSNOWM2(KZ) + DMTSNOWM2(K)*ROA1 !CONST1
          DSMTSNOWM3(KZ) = DSMTSNOWM3(KZ) + DMTSNOWM3(K) !*DT
          DSMTGRAM3(KZ) = DSMTGRAM3(KZ) + DMTGRAM3(K)*ROA1 !CONST1
          DSMTGRAM4(KZ) = DSMTGRAM4(KZ) + DMTGRAM4(K) !*DT
         ENDIF
         dsntgra0(KZ)=dsntgra0(KZ)+dntgra0(K)
         dsntgra2(KZ)=dsntgra2(KZ)+dntgra2(K)*roa1
         dsntgra3(KZ)=dsntgra3(KZ)+dntgra3(K)*roa1
         dsntgra4(KZ)=dsntgra4(KZ)+dntgra4(K)
         dsntgra5(KZ)=dsntgra5(KZ)+dntgra5(K)*roa1
         dsmtgra0(KZ)=dsmtgra0(KZ)+dmtgra0(K)
         dsmtgra2(KZ)=dsmtgra2(KZ)+dmtgra2(K)*roa1
         dsmtgra3(KZ)=dsmtgra3(KZ)+dmtgra3(K)*roa1
         dsmtgra4(KZ)=dsmtgra4(KZ)+dmtgra4(K)
         dsmtgra5(KZ)=dsmtgra5(KZ)+dmtgra5(K)*roa1
        ENDDO

        CCN1(KZ) = CCN
        NIDEP1(KZ) = NIDEP0(KZ) + TENDEP* DT
        IF (CCN1(KZ).LT.0.0) CCN1(KZ) = 0.0
        IF (NIDEP1(KZ).LT.0.0) NIDEP1(KZ) = 0.0
 121   CONTINUE
!----+-----------------------------------------------------------------+

!       QMELT1 = -DQSHC - DQGRHC - DQHLHC + LF*DSMTCI10(KZ)
! the melting of less than 20% ice mass in partially melted particles should be counted
       QMELT1 = -(DQSHC + DQGRHC + DQHLHC) + LF*(DSMTCI10(KZ)-DSMTSNOWM4(KZ)-DSMTGRAM5(KZ))

!       QMELT2 = (-DSMTC10(KZ)+DSMTC6(KZ)+DSMTC8(KZ)+                   &
!     &           DSMTCIR1(KZ))*(tz_old(KZ)-T00)*CW
! xue: heat conduction of melted water (partially melted snow and graupel should be treated as well)
       QMELT2 = -(DSMTC10(KZ)-DSMTC8S(KZ))*(tz_old(KZ)-T00)*CW
!       QMELT2 = -(DSMTSNOWM3(KZ)+DSMTGRAM4(KZ))*(tz_old(KZ)-T00)*CW/DT
       QFREEZ = LF*(DSMTGRA0(KZ)+DSMTGRA3(KZ)+DSMTGRA4(KZ)+             &
     &           DSMTCI1(KZ)+DSMTCI4(KZ)-DSMTC5(KZ)-DSMTC6(KZ)+         &
     &           DSMTC9(KZ))
! the diffusion on graupel include that of water on graupel, need to adjust it
! evaporation from partially melted snow and graupel should be calculated and counted
       TTEN1 = TTEN1+(IDELTA1*QFREEZ+(1-IDELTA1)*(QMELT1+QMELT2)        &
!     &       +  LD*(dsmtci0(KZ)+dsmtgra10(KZ)))/CP
     &       +  LD*(dsmtci0(KZ)+IDELTA1*dsmtgra10(KZ)))/CP
!     &       +  LD*(dsmtci0(KZ)+IDELTA1*dsmtgra10(KZ)                   &
!     &       -   (1-IDELTA1)*(DSMTCI2(KZ)+DSMTCIR0(KZ))))/CP  ! these two effects have been accounted in cond!


       QVTEN1 = QVTEN1 - (dsmtci0(KZ)+dsmtgra10(KZ))
       if (ibug0.eq.1) then
        write(98,*) 'ist,kz',ist,kz
        write(98,*) 'qmelt1,qmelt2,qfreez,dsmtci0,dsmtgra10'
        write(98,*) qmelt1,qmelt2,qfreez,dsmtci0(kz),dsmtgra10(kz)
        write(98,*) 'tk,tk11,qv,qv11,idelta1'
        write(98,*) tk,tk11,qv(kz),qv11,idelta1
        write(98,*) 'DSMTSNOWM3,DSMTGRAM4,DSMTCI10,DSMTCI3'
        write(98,*) DSMTSNOWM3(KZ),DSMTGRAM4(KZ),DSMTCI10(KZ),          &
     &          DSMTCI3(KZ)
        write(98,*)'DSMTC10,DSMTC6,DSMTC8,DSMTCIR1'
        write(98,*)DSMTC10(KZ),DSMTC6(KZ),DSMTC8(KZ),DSMTCIR1(KZ)
        write(98,*) 'DSMTGRA0,DSMTGRA3,DSMTGRA4,DSMTCI1,DSMTCI4,DSMTC5, &
     &               DSMTC6,DSMTC9'
        write(98,*) DSMTGRA0(KZ),DSMTGRA3(KZ),DSMTGRA4(KZ),             &
     &     DSMTCI1(KZ),DSMTCI4(KZ),DSMTC5(KZ),DSMTC6(KZ),DSMTC9(KZ)
       endif 

       tz(kz) = tz_old(kz) + TTEN1*DT
       QV(KZ) = qv_old(kz) + QVTEN1*DT

       DO K=1,K4
         EPSC1 = EPSC*M(K)
         NCW1(KZ,K) = NCW1(KZ,K)+(NTC(K)-NCW0(KZ,K)+fo_nw(KZ,K))
         QCW1(KZ,K) = QCW1(KZ,K)+(MTC(K)-QCW0(KZ,K)+fo_qw(KZ,K))
         IF (NCW1(KZ,K).LE.EPSC.OR.QCW1(KZ,K).LE.EPSC1) THEN               
                  NCW1(KZ,K) = 0.0
                  QCW1(KZ,K) = 0.0                      
         ENDIF
         NICE1(KZ,K) = NICE1(KZ,K)+(NTCI(K)-NICE0(KZ,K)+fo_ni(KZ,K))
         QICE1(KZ,K) = QICE1(KZ,K)+(MTCI(K)-QICE0(KZ,K)+fo_qi(KZ,K))
         IF (NICE1(KZ,K).LE.EPSC.OR.QICE1(KZ,K).LE.EPSC1) THEN
                  NICE1(KZ,K) = 0.0
                  QICE1(KZ,K) = 0.0
         ENDIF
         NSNOW1(KZ,K) = NSNOW1(KZ,K)+(NTCIR(K)-NSNOW0(KZ,K)+fo_ns(KZ,K))
         QSNOW1(KZ,K) = QSNOW1(KZ,K)+(MTCIR(K)-QSNOW0(KZ,K)+fo_qs(KZ,K))
         IF (NSNOW1(KZ,K).LE.EPSC.OR.QSNOW1(KZ,K).LE.EPSC1) THEN
                  NSNOW1(KZ,K) = 0.0
                  QSNOW1(KZ,K) = 0.0
         ENDIF
         NGRA1(KZ,K) = NGRA1(KZ,K)+(NTGRA(K)-NGRA0(KZ,K)+fo_ng(KZ,K))
         QGRA1(KZ,K) = QGRA1(KZ,K)+(MTGRA(K)-QGRA0(KZ,K)+fo_qg(KZ,K))
         IF (NGRA1(KZ,K).LE.EPSC.OR.QGRA1(KZ,K).LE.EPSC1) THEN
                  NGRA1(KZ,K) = 0.0
                  QGRA1(KZ,K) = 0.0
         ENDIF 
         IF (tz_old(KZ).LT.T00) THEN
           NSNOWR1(KZ,K)=NSNOWR1(KZ,K)+DNTRIME0(K)+(DNTRIME1(K)+        &
     &       DNTRIME2(K)+ERICRIC*DNTRIME3(K)+ERICIC*DNTRIME4(K))*CONST1 &
     &       + fo_nsr(KZ,K)
           QSNOWR1(KZ,K)=QSNOWR1(KZ,K)+DMTRIME0(K)+(DMTRIME1(K)+        &
     &       DMTRIME2(K)+ERICRIC*DMTRIME3(K)+ERICIC*DMTRIME4(K))*CONST1 &
     &       + fo_qsr(KZ,K)
           IF (NSNOWR1(KZ,K).LE.EPSC.OR.QSNOWR1(KZ,K).LE.EPSC1) THEN
                  NSNOWR1(KZ,K) = 0.0
                  QSNOWR1(KZ,K) = 0.0
           ENDIF
           IF (NSNOWR1(KZ,K).GT.NSNOW1(KZ,K)) THEN
             NSNOWR1(KZ,K)=NSNOW1(KZ,K)
           ENDIF
           IF (QSNOWR1(KZ,K).GT.QSNOW1(KZ,K)) THEN
             QSNOWR1(KZ,K)=QSNOW1(KZ,K)
           ENDIF
         ELSE
           NSNOWR1(KZ,K)=0.0
           QSNOWR1(KZ,K)=0.0
         ENDIF
         IF (tz_old(KZ).LT.T00) THEN
          QSNOWM1(KZ,K)=0.0
          QGRAM1(KZ,K)=0.0 
!     transfer of the rimed snow flakes to the graupel if the rimed water mass ratio is larger than the rimthres
          FQ1=0.0
          IF (QSNOW1(KZ,K).GT.0.0) THEN
           FQ1=QSNOWR1(KZ,K)/QSNOW1(KZ,K)
          ENDIF
          FN1=0.0
          IF (NSNOW1(KZ,K).GT.0.0) THEN
           FN1=NSNOWR1(KZ,K)/NSNOW1(KZ,K)
          ENDIF
          IF (FQ1.GT.RIMTHRES) THEN
           DMTGRA7(K)=FN1*QSNOW1(KZ,K)
           DNTGRA7(K)=NSNOWR1(KZ,K)
           DMTCIR6(K)=-DMTGRA7(K)
           DNTCIR6(K)=-DNTGRA7(K)
           DNTRIME5(K)=-NSNOWR1(KZ,K)
           DMTRIME5(K)=-QSNOWR1(KZ,K)
           NGRA1(KZ,K)=NGRA1(KZ,K)+DNTGRA7(K)
           QGRA1(KZ,K)=QGRA1(KZ,K)+DMTGRA7(K)
           NSNOW1(KZ,K)=NSNOW1(KZ,K)+DNTCIR6(K)
           QSNOW1(KZ,K)=QSNOW1(KZ,K)+DMTCIR6(K)
           NSNOWR1(KZ,K)=0.0
           QSNOWR1(KZ,K)=0.0
           DSMTGRA7(KZ)=DSMTGRA7(KZ)+DMTGRA7(K)
           DSNTGRA7(KZ)=DSNTGRA7(KZ)+DNTGRA7(K)
           DSMTCIR6(KZ)=DSMTCIR6(KZ)+DMTCIR6(K)
           DSNTCIR6(KZ)=DSNTCIR6(KZ)+DNTCIR6(K)
           DSNTRIME5(KZ)=DSNTRIME5(KZ)+DNTRIME5(K)
           DSMTRIME5(KZ)=DSMTRIME5(KZ)+DMTRIME5(K)
          ENDIF 
         ELSE 
         QSNOWM1(KZ,K)=QSNOWM1(KZ,K)+(MTSNOWM(K)-QSNOWM0(KZ,K)+         &
     &      fo_qsm(KZ,K))
         QGRAM1(KZ,K)=QGRAM1(KZ,K)+(MTGRAM(K)-QGRAM0(KZ,K)+fo_qgm(KZ,K))
 
          IF (QSNOWM1(KZ,K) .GT. QSNOW1(KZ,K)) THEN
           QSNOWM1(KZ,K) = QSNOW1(KZ,K)
          ENDIF
          IF (QSNOWM1(KZ,K).LT.0.0) THEN
           QSNOWM1(KZ,K)=0.0
          ENDIF
          IF (QGRAM1(KZ,K) .GT. QGRA1(KZ,K)) THEN
           QGRAM1(KZ,K) = QGRA1(KZ,K)
          ENDIF
          IF (QGRAM1(KZ,K).LT.0.0) THEN
           QGRAM1(KZ,K)=0.0
          ENDIF
         ENDIF
        ENDDO
        QGRA(KZ)=0.0
        QSNOW(KZ)=0.0
        QL(KZ)=0.0
        DO K=1,K4
         QGRA(KZ)=QGRA(KZ)+QGRA1(KZ,K)
         QSNOW(KZ)=QSNOW(KZ)+QSNOW1(KZ,K)
         QL(KZ)=QL(KZ)+QCW1(KZ,K) 
        ENDDO

! conversion rates begin
        DNWZ_ACTV(KZ) =dsntc0(KZ)
        DNWZ_COAG(KZ) =dsntc1(KZ)
        DNWZ_BRUP(KZ) =dsntc1b(KZ)
        DNIZ_COLL(KZ) =dsntci5(KZ)+dsntci9(KZ)+dsntcir4(KZ)+            &
     &                 dsntcir5(KZ)+dsntcir7(KZ)
        DMWZ_FRML(KZ) =dsmtc10(KZ)-(dsmtci4(KZ)+dsmtgra4(KZ)+dsmtgra0(KZ)+dsmtci1(KZ))
        DMWIZ_MELT(KZ)=(DSMTSNOWM3(KZ)+DSMTGRAM4(KZ)) !/DT
        DMWIZ_DIFF(KZ)=DMWIZ_DIFF(KZ)+DSMTRIME0(KZ)
        DMWZ_RIME(KZ) =dsmtc5(KZ)+dsmtc6(KZ)+dsmtc8(KZ)+dsmtc8s(KZ)
        DNWZ_SHED(KZ) =dsntc8s(kz)
!        DMGZ_RIME(KZ) =dsmtci8(KZ)+dsmtcir6(KZ)
        DMGZ_RIME(KZ) =dsmtgra2(KZ)+DSMTGRA3(kz)+dsmtgra7(KZ)+dsmtgra5(KZ) !+          &
!     &                 DSMTGRA3(KZ)
! conversion rates end

       if (ibug0.eq.1) then
         write(98,*) 'at end of the main loop tk,tk1', tk,tz_old(KZ)
        endif
 100  CONTINUE

         errseggr=0.0
         errseggr1=0.0
         errseggr2=0.0
         errseggr3=0.
         errseggr4=0.0
         errseggr5=0.0
         errseggr6=0.0
      DSMTC6MAX=0.0
      RIMPDIFF1MAX=0.0 
      KZRDF1=1
      KZRDF2=1
        DO KZ =1,NZ
         RIMPDIFF1(KZ)=-1.0
         IF (DSMTCIR0(KZ).GT.0) THEN
          RIMPDIFF1(KZ)=-0.6
          IF (ABS(DSMTC6(KZ)).GT.0.0) THEN
            RIMPDIFF1(KZ)=ABS(DSMTC6(KZ))/(DSMTCIR0(KZ)+                &
     &                    ABS(DSMTC6(KZ)))
          ENDIF         
         ENDIF
         IF (ABS(DSMTCIR0(KZ)) .GT. errseggr6) THEN
            errseggr6=ABS(DSMTCIR0(KZ))
            KZRDF2=KZ
         ENDIF
         IF (RIMPDIFF1(KZ).GT.RIMPDIFF1MAX) THEN
            RIMPDIFF1MAX=RIMPDIFF1(KZ)
            KZRDF1=KZ
         ENDIF
         errseggr2=abs(dsmtgram0(kz)-dsmtgra10(kz))
         if (errseggr2.gt.errseggr1) then
           errseggr1=errseggr2
           kzerr1=kz
         endif
      DELTAV0 = DZ(KZ)*DX*DX*RHOA(KZ) ! xue add *DX*RHOA
      DELTAV1 = DELTAV0*DT
!         DELTAV1=DELTAV*RHOA(KZ)
         IF (KZ.eq.1.OR.KZ.EQ.NZ) DELTAV1 =DELTAV1/2.
!     DELTAV=DELTAV1/DT
         TDSNTC0=TDSNTC0 + DSNTC0(KZ)*DELTAV1
         TDSNTC1=TDSNTC1 + DSNTC1(KZ)*DELTAV1
         TDSNTC1B=TDSNTC1B + DSNTC1B(KZ)*DELTAV1
         TDSNTC2=TDSNTC2 + DSNTC2(KZ)*DELTAV1
         TDSNTC3=TDSNTC3 + DSNTC3(KZ)*DELTAV1
         TDSNTC4=TDSNTC4 + DSNTC4(KZ)*DELTAV1
         TDSNTC5=TDSNTC5 + DSNTC5(KZ)*DELTAV1
         TDSNTC6=TDSNTC6 + DSNTC6(KZ)*DELTAV1
         TDSNTC8=TDSNTC8 + DSNTC8(KZ)*DELTAV1
         TDSNTC8S=TDSNTC8S + DSNTC8S(KZ)*DELTAV1
         TDSNTC10=TDSNTC10 + DSNTC10(KZ)*DELTAV1
         TDSMTC0=TDSMTC0 + DSMTC0(KZ)*DELTAV1
         TDSMTC1=TDSMTC1 + DSMTC1(KZ)*DELTAV1
         TDSMTC1B=TDSMTC1B + DSMTC1B(KZ)*DELTAV1
         TDSMTC2=TDSMTC2 + DSMTC2(KZ)*DELTAV1
         TDSMTC3=TDSMTC3 + DSMTC3(KZ)*DELTAV1
         TDSMTC4=TDSMTC4 + DSMTC4(KZ)*DELTAV1
         TDSMTC5=TDSMTC5 + DSMTC5(KZ)*DELTAV1
         TDSMTC6=TDSMTC6 + DSMTC6(KZ)*DELTAV1
         TDSMTC8=TDSMTC8 + DSMTC8(KZ)*DELTAV1
         TDSMTC8S=TDSMTC8S + DSMTC8S(KZ)*DELTAV1
         TDSMTC9=TDSMTC9 + DSMTC9(KZ)*DELTAV1 
         TDSMTC10=TDSMTC10 + DSMTC10(KZ)*DELTAV1
         TDSNTCI0=TDSNTCI0 + DSNTCI0(KZ)*DELTAV1
         TDSNTCI1=TDSNTCI1 + DSNTCI1(KZ)*DELTAV1
         TDSNTCI2=TDSNTCI2 + DSNTCI2(KZ)*DELTAV1
         TDSNTCI3=TDSNTCI3 + DSNTCI3(KZ)*DELTAV1
         TDSNTCI4=TDSNTCI4 + DSNTCI4(KZ)*DELTAV1
         TDSNTCI5=TDSNTCI5 + DSNTCI5(KZ)*DELTAV1
         TDSNTCI6=TDSNTCI6 + DSNTCI6(KZ)*DELTAV1
         TDSNTCI9=TDSNTCI9 + DSNTCI9(KZ)*DELTAV1
         TDSNTCI10=TDSNTCI10 + DSNTCI10(KZ)*DELTAV1
         TDSNTCI11=TDSNTCI11 + DSNTCI11(KZ)*DELTAV1
         TDSMTCI0=TDSMTCI0 + DSMTCI0(KZ)*DELTAV1
         TDSMTCI1=TDSMTCI1 + DSMTCI1(KZ)*DELTAV1
         TDSMTCI2=TDSMTCI2 + DSMTCI2(KZ)*DELTAV1
         TDSMTCI3=TDSMTCI3 + DSMTCI3(KZ)*DELTAV1
         TDSMTCI4=TDSMTCI4 + DSMTCI4(KZ)*DELTAV1
         TDSMTCI5=TDSMTCI5 + DSMTCI5(KZ)*DELTAV1
         TDSMTCI6=TDSMTCI6 + DSMTCI6(KZ)*DELTAV1
         TDSMTCI9=TDSMTCI9 + DSMTCI9(KZ)*DELTAV1
         TDSMTCI10=TDSMTCI10 + DSMTCI10(KZ)*DELTAV1
         TDSMTCI11=TDSMTCI11 + DSMTCI11(KZ)*DELTAV1
         TDSNTCIR0=TDSNTCIR0 + DSNTCIR0(KZ)*DELTAV1
         TDSNTCIR1=TDSNTCIR1 + DSNTCIR1(KZ)*DELTAV1
         TDSNTCIR2=TDSNTCIR2 + DSNTCIR2(KZ)*DELTAV1
         TDSNTCIR4=TDSNTCIR4 + DSNTCIR4(KZ)*DELTAV1
         TDSNTCIR5=TDSNTCIR5 + DSNTCIR5(KZ)*DELTAV1
         TDSNTCIR6=TDSNTCIR6 + DSNTCIR6(KZ)*DELTAV0
         TDSNTCIR7=TDSNTCIR7 + DSNTCIR7(KZ)*DELTAV1
         TDSNTCIR8=TDSNTCIR8 + DSNTCIR8(KZ)*DELTAV1
         TDSNTCIR9=TDSNTCIR9 + DSNTCIR9(KZ)*DELTAV1
         TDSMTCIR0=TDSMTCIR0 + DSMTCIR0(KZ)*DELTAV1
         TDSMTCIR1=TDSMTCIR1 + DSMTCIR1(KZ)*DELTAV1
         TDSMTCIR2=TDSMTCIR2 + DSMTCIR2(KZ)*DELTAV1
         TDSMTCIR4=TDSMTCIR4 + DSMTCIR4(KZ)*DELTAV1
         TDSMTCIR5=TDSMTCIR5 + DSMTCIR5(KZ)*DELTAV1
         TDSMTCIR6=TDSMTCIR6 + DSMTCIR6(KZ)*DELTAV0
         TDSMTCIR7=TDSMTCIR7 + DSMTCIR7(KZ)*DELTAV1
         TDSMTCIR8=TDSMTCIR8 + DSMTCIR8(KZ)*DELTAV1
         TDSMTCIR9=TDSMTCIR9 + DSMTCIR9(KZ)*DELTAV1
         TDSNTRIME0 = TDSNTRIME0 + DSNTRIME0(KZ)*DELTAV1
         TDSMTRIME0 = TDSMTRIME0 + DSMTRIME0(KZ)*DELTAV1
         TDSNTRIME1 = TDSNTRIME1 + DSNTRIME1(KZ)*DELTAV1 
         TDSNTRIME2 = TDSNTRIME2 + DSNTRIME2(KZ)*DELTAV1
         TDSNTRIME3 = TDSNTRIME3 + DSNTRIME3(KZ)*DELTAV1
         TDSNTRIME4 = TDSNTRIME4 + DSNTRIME4(KZ)*DELTAV1
         TDSNTRIME5 = TDSNTRIME5 + DSNTRIME5(KZ)*DELTAV0
         TDSMTRIME1 = TDSMTRIME1 + DSMTRIME1(KZ)*DELTAV1
         TDSMTRIME2 = TDSMTRIME2 + DSMTRIME2(KZ)*DELTAV1
         TDSMTRIME3 = TDSMTRIME3 + DSMTRIME3(KZ)*DELTAV1
         TDSMTRIME4 = TDSMTRIME4 + DSMTRIME4(KZ)*DELTAV1
         TDSMTRIME5 = TDSMTRIME5 + DSMTRIME5(KZ)*DELTAV0
         
         TDSMTSNOWM0 = TDSMTSNOWM0 + DSMTSNOWM0(KZ)*DELTAV1
         TDSMTSNOWM1 = TDSMTSNOWM1 + DSMTSNOWM1(KZ)*DELTAV1
         TDSMTSNOWM2 = TDSMTSNOWM2 + DSMTSNOWM2(KZ)*DELTAV1
         TDSMTSNOWM3 = TDSMTSNOWM3 + DSMTSNOWM3(KZ)*DELTAV1
         TDSMTSNOWM4 = TDSMTSNOWM4 + DSMTSNOWM4(KZ)*DELTAV1
         TDSMTGRAM0 = TDSMTGRAM0 + DSMTGRAM0(KZ)*DELTAV1
         TDSMTGRAM3 = TDSMTGRAM3 + DSMTGRAM3(KZ)*DELTAV1
         TDSMTGRAM4 = TDSMTGRAM4 + DSMTGRAM4(KZ)*DELTAV1
         TDSMTGRAM5 = TDSMTGRAM5 + DSMTGRAM5(KZ)*DELTAV1
         TDSNTGRA0=TDSNTGRA0 + DSNTGRA0(KZ)*DELTAV1
         TDSNTGRA2=TDSNTGRA2 + DSNTGRA2(KZ)*DELTAV1
         TDSNTGRA3=TDSNTGRA3 + DSNTGRA3(KZ)*DELTAV1
         TDSNTGRA4=TDSNTGRA4 + DSNTGRA4(KZ)*DELTAV1
         TDSNTGRA5=TDSNTGRA5 + DSNTGRA5(KZ)*DELTAV1
         TDSNTGRA7=TDSNTGRA7 + DSNTGRA7(KZ)*DELTAV0
         TDSNTGRA10=TDSNTGRA10 + DSNTGRA10(KZ)*DELTAV1
         TDSNTGRA11=TDSNTGRA11 + DSNTGRA11(KZ)*DELTAV1
         TDSNTGRA12=TDSNTGRA12 + DSNTGRA12(KZ)*DELTAV1
         TDSMTGRA0=TDSMTGRA0 + DSMTGRA0(KZ)*DELTAV1
         TDSMTGRA2=TDSMTGRA2 + DSMTGRA2(KZ)*DELTAV1
         TDSMTGRA3=TDSMTGRA3 + DSMTGRA3(KZ)*DELTAV1
         TDSMTGRA4=TDSMTGRA4 + DSMTGRA4(KZ)*DELTAV1
         TDSMTGRA5=TDSMTGRA5 + DSMTGRA5(KZ)*DELTAV1
         TDSMTGRA7=TDSMTGRA7 + DSMTGRA7(KZ)*DELTAV0
         TDSMTGRA10=TDSMTGRA10 + DSMTGRA10(KZ)*DELTAV1
         TDSMTGRA11=TDSMTGRA11 + DSMTGRA11(KZ)*DELTAV1
         TDSMTGRA12=TDSMTGRA12 + DSMTGRA12(KZ)*DELTAV1
! xue add for shedding
         TDSNTC11=TDSNTC11 + DSNTC11(KZ)*DELTAV1
         TDSNTC12=TDSNTC12 + DSNTC12(KZ)*DELTAV1
         TDSNTCIR10=TDSNTCIR10 + DSNTCIR10(KZ)*DELTAV1
         TDSNTCIR11=TDSNTCIR11 + DSNTCIR11(KZ)*DELTAV1
         TDSNTGRA13=TDSNTGRA13 + DSNTGRA13(KZ)*DELTAV1
         TDSNTGRA14=TDSNTGRA14 + DSNTGRA14(KZ)*DELTAV1
         TDSMTC11=TDSMTC11 + DSMTC11(KZ)*DELTAV1
         TDSMTC12=TDSMTC12 + DSMTC12(KZ)*DELTAV1
         TDSMTCIR10=TDSMTCIR10 + DSMTCIR10(KZ)*DELTAV1
         TDSMTCIR11=TDSMTCIR11 + DSMTCIR11(KZ)*DELTAV1
         TDSMTGRA13=TDSMTGRA13 + DSMTGRA13(KZ)*DELTAV1
         TDSMTGRA14=TDSMTGRA14 + DSMTGRA14(KZ)*DELTAV1
       ENDDO
      END SUBROUTINE mp_detailed_pg

!+---+-----------------------------------------------------------------+

!+---+-----------------------------------------------------------------+

      subroutine sedimentation (scr4n,scr4q,vt,rhoa,sed_n,sed_q,        &
     &            dz,dt,kts,kte,k4,prcp)

      IMPLICIT NONE
      integer, intent(in) :: kts, kte, k4
      real, intent(in), dimension(kts:kte) :: dz, rhoa
      real, intent(in) :: dt
      real, intent(inout), dimension(kts:kte) :: sed_n, sed_q
      real, intent(inout), dimension(k4,kts:kte) :: scr4n, scr4q
      real, intent(in), dimension(k4,kts:kte) :: vt
      real, intent(inout) :: prcp

!+---+ Local Vars

      integer ksed1, nzstep, k, kz, n
      real odzq, orho, onstep, vtm

!+---+

      ksed1 = 0
      nzstep = 0
      DO KZ = KTS, KTE
       DO K=1,K4
        if (SCR4Q(K,KZ) .gt. EPS) then
          ksed1 = MAX(ksed1, kz)
        endif
       ENDDO
      ENDDO
      if (ksed1 .eq. kte) ksed1 = kte-1

      DO K=1,K4
         DO KZ = ksed1, KTS, -1
            VTM = VT(K,KZ)*SQRT(ROA0/RHOA(KZ))
            if (VTM .gt. 1.E-5) nzstep = MAX(nzstep, INT(DT*VTM/DZ(KZ)+1.))
         ENDDO
      ENDDO

      onstep = 0.
      if (nzstep.gt.0) onstep = 1./REAL(nzstep)
      DO  N = 1,nzstep
       DO K=1,K4
         DO KZ = KTS, KTE
            VTM = VT(K,KZ)*SQRT(ROA0/RHOA(KZ))
            sed_n(KZ) = VTM*SCR4N(K,KZ)*RHOA(KZ)
            sed_q(KZ) = VTM*SCR4Q(K,KZ)*RHOA(KZ)
         ENDDO

!        Top of the model but is probably not needed.
         KZ = KTE
         odzq = 1./DZ(KZ)
         orho = 1./RHOA(KZ)
         SCR4N(K,KZ) = AMAX1(0.0, SCR4N(K,KZ) - sed_n(KZ)*odzq*DT*onstep)
         SCR4Q(K,KZ) = AMAX1(0.0, SCR4Q(K,KZ) - sed_q(KZ)*odzq*DT*onstep)

!        Going downward in column below where first microphysics are found.
         DO KZ = ksed1, KTS, -1
            odzq = 1./DZ(KZ)
            orho = 1./RHOA(KZ)
            SCR4N(K,KZ) = AMAX1(0.0, SCR4N(K,KZ) + (sed_n(KZ+1)-sed_n(KZ))*odzq*DT*onstep*orho)
            SCR4Q(K,KZ) = AMAX1(0.0, SCR4Q(K,KZ) + (sed_q(KZ+1)-sed_q(KZ))*odzq*DT*onstep*orho)
         ENDDO
!        accumulated rain prec. on the ground
         prcp = prcp + sed_q(KTS)*DT*onstep
       ENDDO
      ENDDO

      end subroutine sedimentation

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. Self-coagulation of droplets

      SUBROUTINE COAGS(K4,A,B,C,D,DNTC,DMTC,CC,CCC)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 A(K4),B(K4),C(K4),D(K4),DNTC(K4),DMTC(K4)
      REAL*8 CC(36,3),CCC(36,36,12)
      REAL*8 IN(36),IM(36)
      REAL*8 EPSN, SEG1,SEG2,SEG3
      REAL*8 SSIN1(36),SSIN2(36),SSIN3(36),SSIM1(36),SSIM2(36),         &
     &        SSIM3(36),SSIM4(36),SSINA1(36),SSINA2(36)
      INTEGER K,I,IBUG

!+---+-----------------------------------------------------------------+

!  calculates ssin1...ssin3 and ssim1...ssim4 for each category
!  at a given time
!
!  loop of categories
      do k=1,k4
       ssin1(K)=0.d0
       IF(k.le.2) go to 1
       do i=1,k-2
        ssin1(K)=ssin1(K)+a(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+     &
     &            b(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
       ENDDO
 1     CONTINUE
       ssin2(K)=0.d0
       IF(k.le.1) go to 2
       do i=1,k-1
        ssin2(K)=ssin2(K)+a(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+       &
     &            b(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
       ENDDO
 2     CONTINUE
       ssin3(K)=0.d0
       do i=k,k4
        ssin3(K)=ssin3(K)+a(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+      &
     &            b(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
       ENDDO
       ssim1(K)=0.d0
       IF(k.le.2) go to 4
       do i=1,k-2
        ssim1(K)=ssim1(K)+a(k-1)*(c(i)*ccc(k,i,1)+d(i)*ccc(k,i,3))+     &
     &                    b(k-1)*(c(i)*ccc(k,i,2)+d(i)*ccc(k,i,4))+     &
     &                    c(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+     &
     &                    d(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
       ENDDO
 4     CONTINUE
       ssim2(K)=0.d0
       IF(k.le.1) go to 5
       do i=1,k-1
        ssim2(K)=ssim2(K)+a(K)*(c(i)*ccc(k,i,5)+d(i)*ccc(k,i,7))+       &
     &                    b(K)*(c(i)*ccc(k,i,6)+d(i)*ccc(k,i,8))+       &
     &                    C(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+       &
     &                    d(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
       ENDDO
 5     CONTINUE
       ssim3(K)=0.d0
       do i=k,k4
        ssim3(K)=ssim3(K)+c(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+      &
     &                    d(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
       ENDDO
       ssim4(K)=0.d0
       IF(k.le.1) go to 7
       do i=1,k-1
        ssim4(K)=ssim4(K)+a(K)*(c(i)*ccc(k,i,9)+d(i)*ccc(k,i,11))+      &
     &                    b(K)*(c(i)*ccc(k,i,10)+d(i)*ccc(k,i,12))
       ENDDO
 7    CONTINUE
      ENDDO
!
!  end loop of categories
!
!
!  calculates in and im for each category at a given time
!

      DO K =1,k4
        in(K)=0.d0
        im(K)=0.d0
      ENDDO
!
!  loop of categories
!
      do k=2,k4
       in(K)=0.5d0*(a(k-1)*a(k-1)*cc(k,1)+ 2.d0*a(k-1)*b(k-1)*cc(k,2)+  &
     &             b(k-1)*b(k-1)*cc(k,3))
       im(K)=a(k-1)*c(k-1)*cc(k,1)+                                     &
     &     (a(k-1)*d(k-1)+b(k-1)*c(k-1))*cc(k,2)+b(k-1)*d(k-1)*cc(k,3)
      ENDDO
!
!  end loop of categories
!
      DO k=1,k4
         DNTC(K)=(ssin1(K)+in(K)-(ssin2(K)+ssin3(K)))
         DMTC(K)=((ssim1(K)+ssim4(K)+im(K))-(ssim2(K)+ssim3(K)))
      ENDDO
      RETURN
      END SUBROUTINE COAGS

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

!      SUBROUTINE BREAKUP(K4,DNTC,DMTC,CCCMEAN,DT)
      SUBROUTINE BREAKUP(K4,MTCT,NTCT,DNTC,DMTC,CCCMEAN,DT,ibug)

      IMPLICIT NONE
      INTEGER K4
!      REAL*8 DNTC(K4),DMTC(K4)
      REAL*8 NTCT(K4),MTCT(K4),DNTC(K4),DMTC(K4)
      REAL (KIND=R8SIZE) :: CCCMEAN(36,36)
      REAL*8 SEGNP1,SEGMP1,SEGNN1,SEGMN1,SEGNP2,SEGMP2,SEGNN2,SEGMN2,   &
     &       C1,SUMDNTC
      INTEGER I,K,J,KS,IMAX,ibug
      REAL DT        !modofied 04.27. by SN

!+---+

      ibug=0
      C1 = 3.d0/2.d0
      SUMDNTC =0.d0
      DO 100 K = 1, K4
       SEGNP1 = 0.d0
       SEGMP1 = 0.d0
       DO 200 I = 2,K4
        DO 300 J = 1, I - 1
         SEGNP1 = SEGNP1 +                                              &
     &     CCCMEAN(I,J)*QTN(I,J,K)*M(K)*(NTCT(I)*MTCT(J) + NTCT(J)*MTCT(I))
         SEGMP1 = SEGMP1 +                                              &
     &            C1*CCCMEAN(I,J)*QTN(I,J,K)*M(K)**2*                   &
     &                                 (NTCT(I)*MTCT(J) + NTCT(J)*MTCT(I))
 300    CONTINUE
 200   CONTINUE
       SEGNP2 = 0.d0
       SEGMP2 = 0.d0
       DO 400 I = 1, K4
        SEGNP2 = SEGNP2 + CCCMEAN(I,I)*QTN(I,I,K)*M(K)*NTCT(I)*MTCT(I)
        SEGMP2 = SEGMP2 +                                               &
     &              C1*CCCMEAN(I,I)*QTN(I,I,K)*M(K)**2*NTCT(I)*MTCT(I)
 400   CONTINUE
       SEGNN1 = 0.d0
       SEGMN1 = 0.d0
       DO 500 I = 1,K4
        DO 600 J = 1, K
         SEGNN1 = SEGNN1 +                                              &
     &          C1*CCCMEAN(J,K)*QTN(K,J,I)*M(I)**2*NTCT(J)*NTCT(K)
         SEGMN1 = SEGMN1 +                                              &
     &          C1*CCCMEAN(J,K)*QTN(K,J,I)*M(I)**2*NTCT(J)*MTCT(K)
 600    CONTINUE
 500   CONTINUE
       SEGNN2 = 0.d0
       SEGMN2 = 0.d0
       DO 700 I = 1,K4
        IF (K + 1 <= K4) THEN
         DO 800 J = K+1, K4
          SEGNN2 = SEGNN2 +                                             &
     &             C1*CCCMEAN(K,J)*QTN(J,K,I)*M(I)**2*NTCT(J)*NTCT(K)
          SEGMN2 = SEGMN2 +                                             &
     &             C1*CCCMEAN(K,J)*QTN(J,K,I)*M(I)**2*NTCT(J)*MTCT(K)
 800     CONTINUE
        ENDIF
 700   CONTINUE
!       DNTC(K) = SEGNP1 + SEGNP2 - SEGNN1 - SEGNN2
       DMTC(K) = SEGMP1 + SEGMP2 - SEGMN1 - SEGMN2
       IF (K.GE.33.AND.DMTC(K).GT.0.0) DMTC(K)=0.0
       DNTC(K) = DMTC(K)/(1.5*M(K))                                                 ! IG 15May2014
       SUMDNTC = SUMDNTC + DNTC(K)
       if (ibug > 0) then
         write(*,*) 'k,ntc,mtc,',k,ntc(k),mtc(k)
         write(*,*) 'segnp1,segnp2,segnn1,segnn2'
         write(*,*) segnp1,segnp2,segnn1,segnn2
       endif
 100      CONTINUE
      IF (SUMDNTC < 0.d0) THEN
         DO K =1, K4
          DNTC(K)=0.d0
          DMTC(K)=0.d0
         ENDDO
      ENDIF
!modified: 05.05.2013
!      KS = 26
!      DO K = K4, K4-3, -1
!        IF (MTC(K) .GT. 1.E-12) THEN
!           DNTC(K) = DNTC(K) - NTC(K)/DT
!           DMTC(K) = DMTC(K) - MTC(K)/DT
!           DNTC(KS) = DNTC(KS) + MTC(K)/M(KS)/DT
!           DMTC(KS) = DMTC(KS) + MTC(K)/DT
!        ENDIF
!      ENDDO
      RETURN
      END SUBROUTINE BREAKUP

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This  subroutine calculates the aggregation rate of the snow flakes
!.. and the effect of this process on the rimed particle concentration
!.. and rimed mass 

      SUBROUTINE COAGS1(K4,A,B,C,D,DNT,DMT,CC,CCC,FQ,DQRIME,FN,DNRIME) 

      IMPLICIT NONE
      INTEGER K4
      REAL*8 A(K4),B(K4),C(K4),D(K4),DNT(K4),DMT(K4)
      real*8 FN(K4),FQ(K4)
      REAL*8 DNRIME(K4),DQRIME(K4)
      REAL (KIND=R8SIZE) :: CC(36,3),CCC(36,36,12)

      REAL*8 IN(36),IM(36)
      REAL*8 ssin1(36),ssin2(36),ssin3(36),ssim1(36),ssim2(36),         &
     &       ssim3(36),ssim4(36)
      REAL*8 FNSUM1(36),FQSUM1(36),FNSUM2(36),                          &
     &       FQSUM2(36),FNSUM3(36),FQSUM3(36),FQSUM4(36),FNSUM5(36),    &
     &       FQSUM5(36),FNSUM6(36),FQSUM6(36)
      real*8 SEGN,SEGQ,SEGQ1,SEGQ2
      real*8 segn0,segn1,segn2,segn3,segn4,segn5,segn6,segq0,segq3,     &
     &       segq4,segq5,segq6
      integer k, i
!
!  calculates ssin1...ssin3 and ssim1...ssim4 for each category
!  at a given time
!
!
!  loop of categories
!       
      DO K =1,K4
       FNSUM1(K) = 0.d0
       FNSUM2(K) = 0.d0
       FNSUM3(K) = 0.d0
       FNSUM5(K) = 0.d0
       FNSUM6(K) = 0.d0
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
       FQSUM4(K) = 0.d0
       FQSUM5(K) = 0.d0
       FQSUM6(K) = 0.d0
      ENDDO
      do k=1,k4
       ssin1(K)=0.d0
       IF(k.le.2) go to 1
       do i=1,k-2
        SEGN=a(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+                  &
     &       b(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4)) 
        ssin1(K)=ssin1(K)+SEGN
        FNSUM1(K)=FNSUM1(K) + FN(I)*SEGN
        FNSUM2(K)=FNSUM2(K) + (1. - FN(I))*SEGN
       ENDDO
 1     CONTINUE
       ssin2(K)=0.d0
       IF(k.le.1) go to 2
       do i=1,k-1
         SEGN=a(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+                   &
     &        b(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
         ssin2(K)=ssin2(K)+SEGN
         FNSUM5(K)=FNSUM5(K) + SEGN
       ENDDO
 2     CONTINUE
       ssin3(K)=0.d0
       do i=k,k4
        SEGN = a(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+                 &
     &         b(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
        ssin3(K)=ssin3(K)+SEGN
        FNSUM6(K) = FNSUM6(K) + SEGN
       ENDDO
       ssim1(K)=0.d0
       IF(k.le.2) go to 4
       do i=1,k-2
        SEGQ=a(k-1)*(c(i)*ccc(k,i,1)+d(i)*ccc(k,i,3))+                  &
     &       b(k-1)*(c(i)*ccc(k,i,2)+d(i)*ccc(k,i,4))+                  &
     &       c(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+                  &
     &       d(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
        ssim1(K)=ssim1(K)+SEGQ
        SEGQ =a(i)*c(k-1)*ccc(k,i,1)+a(i)*d(k-1)*ccc(k,i,2)+            &
     &        b(i)*c(k-1)*ccc(k,i,3)+b(i)*d(k-1)*ccc(k,i,4)
        FQSUM1(K) = FQSUM1(K) + SEGQ
        SEGQ =c(i)*a(k-1)*ccc(k,i,1)+c(i)*b(k-1)*ccc(k,i,2)+            &
     &        d(i)*a(k-1)*ccc(k,i,3)+d(i)*b(k-1)*ccc(k,i,4) 
        FQSUM2(K) = FQSUM2(K) + FQ(I)*SEGQ
       ENDDO
 4     CONTINUE
       ssim2(K)=0.d0
       IF(k.le.1) go to 5
       do i=1,k-1
        SEGQ=a(K)*(c(i)*ccc(k,i,5)+d(i)*ccc(k,i,7))+                    &
     &       b(K)*(c(i)*ccc(k,i,6)+d(i)*ccc(k,i,8))+                    &
     &       c(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+                    &
     &       d(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
        ssim2(K)=ssim2(K)+SEGQ
        SEGQ =a(i)*c(k)*ccc(k,i,5)+a(i)*d(k)*ccc(k,i,6)+                &
     &        b(i)*c(k)*ccc(k,i,7)+b(i)*d(k)*ccc(k,i,8)
        FQSUM5(K) = FQSUM5(K) + SEGQ
       ENDDO
 5     CONTINUE
       ssim3(K)=0.d0
       do i=k,k4
        SEGQ=c(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+                   &
     &       d(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
        SSIM3(K) = SSIM3(K) + SEGQ
        FQSUM6(K) = FQSUM6(K) + SEGQ
       ENDDO
       ssim4(K)=0.d0
       IF(k.le.1) go to 7
       do i=1,k-1
         SEGQ=a(K)*(c(i)*ccc(k,i,9)+d(i)*ccc(k,i,11))+                  &
     &        b(K)*(c(i)*ccc(k,i,10)+d(i)*ccc(k,i,12))
         SSIM4(K) = SSIM4(K) + SEGQ
         SEGQ1 = a(k)*c(i)*ccc(k,i,5)+a(k)*d(i)*ccc(k,i,7)+             &
     &           b(k)*c(i)*ccc(k,i,6)+b(k)*d(i)*ccc(k,i,8)
         FQSUM4(K)= FQSUM4(K) + FQ(I)*(SEGQ-SEGQ1)
       ENDDO
 7     CONTINUE
      ENDDO
!
!  end loop of categories
!
!
!  calculates in and im for each category at a given time
!  
      DO K =1,k4
        in(K)=0.d0
        im(K)=0.d0
      ENDDO
!
!  loop of categories
!
      do k=2,k4
       in(K)=0.5d0*                                                     &
     &       (a(k-1)*a(k-1)*cc(k,1)+ 2.d0*a(k-1)*b(k-1)*cc(k,2)+        &
     &       b(k-1)*b(k-1)*cc(k,3))
       im(K)=                                                           &
     &   a(k-1)*c(k-1)*cc(k,1)+(a(k-1)*d(k-1)+b(k-1)*c(k-1))*cc(k,2)+   &
     &   b(k-1)*d(k-1)*cc(k,3)
      ENDDO
!
!  end loop of categories
!
      segn0=0.d0
      segn1=0.d0
      segn2=0.d0
      segn3=0.d0
      segn5=0.d0
      segn6=0.d0
      segq0=0.d0
      segq1=0.d0
      segq2=0.d0
      segq3=0.d0
      segq4=0.d0
      segq5=0.d0
      segq6=0.d0
      segn=0.d0
      segq=0.d0
      DO k=2,k4
       dnt(K)=(ssin1(K)+in(K)-(ssin2(K)+ssin3(K)))
       dmt(K)=((ssim1(K)+ssim4(K)+im(K))-(ssim2(K)+ssim3(K)))
       DNRIME(K)=FNSUM1(K) + FN(K-1)*FNSUM2(K) + FN(K-1)*IN(K)-         &
     &            FN(K)*(FNSUM5(K) + FNSUM6(K)) 
       DQRIME(K)=FQ(K-1)*FQSUM1(K)+FQSUM2(K) + FQSUM4(K)+               &
     &            FQ(K-1)*IM(K)-FQ(K)*(FQSUM5(K) + FQSUM6(K))
       segn=segn +dnt(k)
       segq=segq+dmt(k)
       segn0=segn0+dnrime(k)
       segn1=segn1+fnsum1(k)
       segn2=segn2+fn(k-1)*fnsum2(k)
       segn3=segn3+fn(k-1)*in(k)
       segn5=segn5+fn(k)*fnsum5(k)
       segn6=segn6+fn(k)*fnsum6(k)
       segq0=segq0+dqrime(k)
       segq1=segq1+fqsum1(k)
       segq2=segq2+fq(k-1)*fqsum2(k)
       segq3=segq3+fq(k-1)*im(k)
       segq4=segq4+fqsum4(k)
       segq5=segq5+fq(k)*fqsum5(k)
       segq6=segq6+fq(k)*fqsum6(k)                     
      ENDDO
      RETURN
      END SUBROUTINE COAGS1

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

      SUBROUTINE COAGS1M(K4,A,B,C,D,DNT,DMT,CC,CCC,FQMS,DMTSNOWM) 

      IMPLICIT NONE
      INTEGER K4
      REAL*8 A(K4),B(K4),C(K4),D(K4),DNT(K4),DMT(K4)
      real*8 FQMS(K4)
      REAL*8 DMTSNOWM(K4)
      REAL (KIND=R8SIZE) :: CC(36,3),CCC(36,36,12)

      REAL*8 IN(36),IM(36)
      REAL*8 ssin1(36),ssin2(36),ssin3(36),ssim1(36),ssim2(36),         &
     &       ssim3(36),ssim4(36)
      REAL*8 FQSUM1(36),FQSUM2(36),FQSUM3(36),FQSUM4(36),               &
     &       FQSUM5(36),FQSUM51(36),FQSUM6(36),SEGN,SEGQ,SEGQ1,SEGQ2
      real*8 segn0,segn1,segn2,segn3,segn4,segn5,segn6,segq0,segq3,     &
     &       segq4,segq5,segq6
      integer k, i
!
!  calculates ssin1...ssin3 and ssim1...ssim4 for each category
!  at a given time
!
!
!  loop of categories
!       
      DO K =1,K4
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
       FQSUM4(K) = 0.d0
       FQSUM5(K) = 0.d0
       FQSUM51(K) = 0.d0
       FQSUM6(K) = 0.d0
      ENDDO
      do k=1,k4
       ssin1(K)=0.d0
       IF(k.le.2) go to 1
       do i=1,k-2
        SEGN=a(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+                  &
     &       b(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4)) 
        ssin1(K)=ssin1(K)+SEGN
       ENDDO
 1     CONTINUE
       ssin2(K)=0.d0
       IF(k.le.1) go to 2
       do i=1,k-1
        SEGN=a(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+                    &
     &       b(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
        ssin2(K)=ssin2(K)+SEGN
       ENDDO        
 2     CONTINUE
       ssin3(K)=0.d0
       do i=k,k4
        SEGN = a(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+                 &
     &         b(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
        ssin3(K)=ssin3(K)+SEGN
       ENDDO

       ssim1(K)=0.d0
       IF(k.le.2) go to 4
       do i=1,k-2
        SEGQ=a(k-1)*(c(i)*ccc(k,i,1)+d(i)*ccc(k,i,3))+                  &
     &       b(k-1)*(c(i)*ccc(k,i,2)+d(i)*ccc(k,i,4))+                  &
     &       c(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+                  &
     &       d(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
        ssim1(K)=ssim1(K)+SEGQ
        SEGQ =a(i)*c(k-1)*ccc(k,i,1)+a(i)*d(k-1)*ccc(k,i,2)+            &
     &        b(i)*c(k-1)*ccc(k,i,3)+b(i)*d(k-1)*ccc(k,i,4)
        FQSUM1(K) = FQSUM1(K) + SEGQ
        SEGQ =c(i)*a(k-1)*ccc(k,i,1)+c(i)*b(k-1)*ccc(k,i,2)+            &
     &        d(i)*a(k-1)*ccc(k,i,3)+d(i)*b(k-1)*ccc(k,i,4) 
        FQSUM2(K) = FQSUM2(K) + FQMS(I)*SEGQ
       ENDDO

 4     CONTINUE
       ssim2(K)=0.d0
       IF(k.le.1) go to 5
       do i=1,k-1
        SEGQ=a(K)*(c(i)*ccc(k,i,5)+d(i)*ccc(k,i,7))+                    &
     &       b(K)*(c(i)*ccc(k,i,6)+d(i)*ccc(k,i,8))+                    &
     &       c(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+                    &
     &       d(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
        ssim2(K)=ssim2(K)+SEGQ
        SEGQ =a(i)*c(k)*ccc(k,i,5)+a(i)*d(k)*ccc(k,i,6)+                &
     &        b(i)*c(k)*ccc(k,i,7)+b(i)*d(k)*ccc(k,i,8)
        FQSUM5(K) = FQSUM5(K) + SEGQ
        SEGQ = a(K)*(c(i)*ccc(k,i,5)+d(i)*ccc(k,i,7))+                  &
     &         b(K)*(c(i)*ccc(k,i,6)+d(i)*ccc(k,i,8))
        FQSUM51(K) = FQSUM51(K) + FQMS(I)*SEGQ
       ENDDO
 5     CONTINUE
       ssim3(K)=0.d0
       do i=k,k4
        SEGQ=c(K)*(a(i)*ccc(k,i,9)+b(i)*ccc(k,i,11))+                   &
     &       d(K)*(a(i)*ccc(k,i,10)+b(i)*ccc(k,i,12))
        SSIM3(K) = SSIM3(K) + SEGQ
        FQSUM6(K) = FQSUM6(K) + SEGQ
       ENDDO
       ssim4(K)=0.d0
       IF(k.le.1) go to 7
       do i=1,k-1
         SEGQ=a(K)*(c(i)*ccc(k,i,9)+d(i)*ccc(k,i,11))+                  &
     &         b(K)*(c(i)*ccc(k,i,10)+d(i)*ccc(k,i,12))
         SSIM4(K) = SSIM4(K) + SEGQ
         FQSUM4(K)= FQSUM4(K) + FQMS(I)*SEGQ
       ENDDO
 7     CONTINUE
      ENDDO
!
!  end loop of categories
!
!
!  calculates in and im for each category at a given time
!  

      DO K =1,k4
        in(K)=0.d0
        im(K)=0.d0
      ENDDO
!
!  loop of categories
!
      do k=2,k4
       in(K)=                                                           &
     &    0.5d0*(a(k-1)*a(k-1)*cc(k,1)+ 2.d0*a(k-1)*b(k-1)*cc(k,2)+     &
     &    b(k-1)*b(k-1)*cc(k,3))
       im(K)=                                                           &
     &    a(k-1)*c(k-1)*cc(k,1)+(a(k-1)*d(k-1)+b(k-1)*c(k-1))*cc(k,2)+  &
     &    b(k-1)*d(k-1)*cc(k,3)
      ENDDO
!
!  end loop of categories
!

      segq0=0.d0
      segq1=0.d0
      segq2=0.d0
      segq3=0.d0
      segq4=0.d0
      segq5=0.d0
      segq6=0.d0
      segn=0.d0
      DO k=2,k4
         dnt(K)=(ssin1(K)+in(K)-(ssin2(K)+ssin3(K)))
         dmt(K)=((ssim1(K)+ssim4(K)+im(K))-(ssim2(K)+ssim3(K)))
         DMTSNOWM(K)=FQMS(K-1)*FQSUM1(K)+FQSUM2(K) + FQSUM4(K)+         &
     &               FQMS(K-1)*IM(K)-FQMS(K)*(FQSUM5(K) + FQSUM6(K))-   &
     &               FQSUM51(K)
        segn=segn+dmt(k)
        segq0=segq0+dmtsnowm(k)
        segq1=segq1+FQMS(k-1)*fqsum1(k)
        segq2=segq2+fqsum2(k)
        segq3=segq3+FQMS(k-1)*im(k)
        segq4=segq4+fqsum4(k)
        segq5=segq5 +FQMS(k)*fqsum5(k)
        segq6=segq6+FQMS(k)*fqsum6(k)    
      ENDDO
      RETURN
      END SUBROUTINE COAGS1M

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calculates the collisional coalesence rate between
!..  the pristine or rimed ice and graupel particles or pristine

      SUBROUTINE COAG3(k4,ac,bc,cc,dc,ah,bh,ch,dh,dmtc,dntc,dmth,       &
     &  dnth,cc1,ccc,cccv,c5v,FQ,DQRIME,FN,DNRIME)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 ac(k4),bc(k4),cc(k4),dc(k4),dntc(k4),dmtc(k4)
      REAL*8 ah(k4),bh(k4),ch(k4),dh(k4),dnth(k4),dmth(k4)
      real*8 FQ(k4),FN(k4)
      REAL*8 DQRIME(k4),DNRIME(k4)
      REAL (KIND=R8SIZE) :: cc1(36,4),ccc(36,36,12),cccv(36,36,4),      &
     &       c5v(36,36,4)

      REAL*8 ina(36,2),ima(36,2)
      REAL*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),               &
     &  ssina2(36),ssima2(36),ssina3(36),ssima3(36),ssima4(36),         &
     &  ssina5(36),ssima5(36),ssina6(36),ssima6(36)
      REAL*8 FNSUM1(36),FQSUM1(36),FNSUM2(36),                          &
     &       FQSUM2(36),FNSUM3(36),FQSUM3(36),FNSUM4(36),FQSUM4(36),    &
     &       FNSUM5(36),FQSUM5(36),FNSUM6(36),FQSUM6(36),FNSUM7(36),    &
     &       FQSUM7(36)
      real*8 segn1,segn2,segn3,segn4,segn5,segn6,segn7,segq1,segq2,     &
     &       segq3,segq4,segq5,segq6,segq7,segn8,segq8,segn9,segq9
      real*8 segn10,segq10
      integer k, i

!+---+
!
!  calculates ssinc1,ssina1...ssina6 and ssimc1,ssima1...ssim6 for each category at agiven time
!
!
!
!  Decrease of concentration of collected particles
!
      do 10 k=1,k4
      ssinc1(K)=0.d0
      do i=1,k4
      ssinc1(K)=ssinc1(K)+ac(K)*(ah(i)*ccc(i,k,9)+bh(i)*ccc(i,k,10))+   &
     &                     bc(K)*(ah(i)*ccc(i,k,11)+bh(i)*ccc(i,k,12))
      ENDDO
!
!  Decrease of mixing ratio of collected particles
!
      ssimc1(K)=0.d0
      do i=1,k4
      ssimc1(K)=ssimc1(K)+cc(K)*(ah(i)*ccc(i,k,9)+bh(i)*ccc(i,k,10))+   &
     &                     dc(K)*(ah(i)*ccc(i,k,11)+bh(i)*ccc(i,k,12))
      ENDDO
!
!    Decrease of concentration and mixing ratio of collector particles
!
      ssina1(K)=0.d0
      ssima1(K)=0.d0
      IF(k.le.1) go to 2
      do i=1,k-1
      ssina1(K)=ssina1(K)+ah(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+    &
     &                    bh(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
      ssima1(K)=ssima1(K)+(ac(i)*ch(K)+cc(i)*ah(K))*ccc(k,i,5)+         &
     &                     (bc(i)*ch(K)+dc(i)*ah(K))*ccc(k,i,7)+        &
     &                     (ac(i)*dh(K)+cc(i)*bh(K))*ccc(k,i,6)+        &
     &                     (bc(i)*dh(K)+dc(i)*bh(K))*ccc(k,i,8)
      ENDDO
 2    CONTINUE
      ssina2(K)=0.d0
      ssima2(K)=0.d0
      do i=k,k4
       ssina2(K)=ssina2(K)+ah(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+  &
     &                     bh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
       ssima2(K)=ssima2(K)+ch(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+  &
     &                     dh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ENDDO
!
! Increase of concentration and mixing ratio of collector (collectors are larger than collected)
!
      ssina3(K)=0.d0
      ssima3(K)=0.d0
      IF (k.le.2) GOTO 6
      do i=1,k-2
       ssina3(K)=ssina3(K)+ah(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+ &
     &                     bh(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
       ssima3(K)=ssima3(K)+(ch(k-1)*ac(i)+ah(k-1)*cc(i))*ccc(k,i,1)+    &
     &                     (dh(k-1)*ac(i)+bh(k-1)*cc(i))*ccc(k,i,2)+    &
     &                     (ch(k-1)*bc(i)+ah(k-1)*dc(i))*ccc(k,i,3)+    &
     &                     (dh(k-1)*bc(i)+bh(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      IF(k.le.1) GOTO 7
      do i=1,k-1
       ssima4(K)=ssima4(K)+ah(K)*(cc(i)*ccc(k,i,9)+dc(i)*ccc(k,i,11))+  &
     &                     bh(K)*(cc(i)*ccc(k,i,10)+dc(i)*ccc(k,i,12))
      ENDDO
 7    CONTINUE
!
! Increase of concentration and mixing ratio of collector (collected ones are larger than collectors)
!
      ssina5(K)=0.d0
      ssima5(K)=0.d0
      IF (k.le.2) GOTO 8
      do i=1,k-2
      ssina5(K)=ssina5(K)+ac(k-1)*(ah(i)*cccv(k,i,1)+bh(i)*cccv(k,i,3))+ &
     &                     bc(k-1)*(ah(i)*cccv(k,i,2)+bh(i)*cccv(k,i,4))
      ssima5(K)=ssima5(K)+(cc(k-1)*ah(i)+ac(k-1)*ch(i))*cccv(k,i,1)+    &
     &                     (dc(k-1)*ah(i)+bc(k-1)*ch(i))*cccv(k,i,2)+   &
     &                     (cc(k-1)*bh(i)+ac(k-1)*dh(i))*cccv(k,i,3)+   &
     &                     (dc(k-1)*bh(i)+bc(k-1)*dh(i))*cccv(k,i,4)
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9
      do i=1,k-1
       ssina6(K)=ssina6(K)+ac(K)*(ah(i)*c5v(k,i,1)+bh(i)*c5v(k,i,3))+   &
     &                     bc(K)*(ah(i)*c5v(k,i,2)+bh(i)*c5v(k,i,4))
       ssima6(K)=ssima6(K)+(cc(K)*ah(i)+ac(K)*ch(i))*c5v(k,i,1)+        &
     &                     (dc(K)*ah(i)+bc(K)*ch(i))*c5v(k,i,2)+        &
     &                     (cc(K)*bh(i)+ac(K)*dh(i))*c5v(k,i,3)+        &
     &                     (dc(K)*bh(i)+bc(K)*dh(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 10   CONTINUE
!
!  end loop of categories
!
!
!  calculates in(k,1), in(k,2) and im(k,1), im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
      DO i=1,2
         DO k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
         ENDDO
      ENDDO
!
!
!  loop of categories
      do 20 k=2,k4
!
!      Increase of concentration and mixing ratio of collectors (collectors are larger than collected  ones)
!
      ina(k,1)=0.5d0*(ah(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+      &
     &                  bh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
      ima(k,1)=ch(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+             &
     &          dh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of collectors (collected ones are larger than collectors)
!
      ina(k,2)=0.5d0*(ac(k-1)*(ah(k-1)*cc1(k,1)+bh(k-1)*cc1(k,2))+      &
     &                 bc(k-1)*(ah(k-1)*cc1(k,3)+bh(k-1)*cc1(k,4)))
      ima(k,2)=cc(k-1)*(ah(k-1)*cc1(k,1)+bh(k-1)*cc1(k,2))+             &
     &          dc(k-1)*(ah(k-1)*cc1(k,3)+bh(k-1)*cc1(k,4))
 20   CONTINUE
!
!  end loop of categories
!
      DO K = 1,K4
       FNSUM1(K) = 0.0
       FQSUM1(K) = 0.0
       FNSUM2(K) = 0.0
       FQSUM2(K) = 0.0
       FNSUM3(K) = 0.0
       FQSUM3(K) = 0.0
       FNSUM4(K) = 0.0
       FQSUM4(K) = 0.0
       FNSUM5(K) = 0.0
       FQSUM5(K) = 0.0
       FNSUM6(K) = 0.0
       FQSUM6(K) = 0.0
       FNSUM7(K) = 0.0
       FQSUM7(K) = 0.0
      ENDDO
      DO 50 K =1, K4
       IF (k.le.2) GOTO 50
       do i=1,k-2
         FNSUM1(K)=FNSUM1(K)+                                           &
     &             ah(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+         &
     &             bh(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
         FQSUM1(K)=FQSUM1(K)+                                           &
     &             ch(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+         &
     &             dh(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
        ENDDO
 50   CONTINUE      
      DO 60 k=2,k4
!
!      Increase of concentration and mixing ratio of collectors (collectors are larger than collected  ones)
!
       FNSUM2(K)=0.5d0*(ah(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+    &
     &                  bh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))) 
       FQSUM2(K)=0.5d0*(ch(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+    &
     &                  dh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))) 
 60   CONTINUE
      DO 65 K = 1, K4
       IF (k.le.2) GOTO 65
       do i=1,k-2
!   Increase of concentration and mixing ratio of collectors (collectors are larger than collected  ones)
        FNSUM5(K)=FNSUM5(K)+                                            &
     &          FN(I)*(ac(k-1)*(ah(i)*cccv(k,i,1)+bh(i)*cccv(k,i,3))+   &
     &          bc(k-1)*(ah(i)*cccv(k,i,2)+bh(i)*cccv(k,i,4)))
        FQSUM5(K)=FQSUM5(K)+                                            &
     &          FQ(I)*(ac(k-1)*(ch(i)*cccv(k,i,1)+dh(i)*cccv(k,i,3))+   &
     &          bc(k-1)*(ch(i)*cccv(k,i,2)+dh(i)*cccv(k,i,4)))
       ENDDO
 65   CONTINUE
!
!    Decrease of concentration and mixing ratio of collector particles
!
      DO 70 K = 1,K4                           
       IF(k.le.1) goto 70
       DO i=1,k-1
        FNSUM3(K)=FNSUM3(K)+ah(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+  &
     &                      bh(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
        FQSUM3(K)=FQSUM3(K)+ch(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+  &
     &                      dh(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
       ENDDO
 70   CONTINUE
      DO 80 K =1,K4
       DO I=K,K4
        FNSUM4(K)=FNSUM4(K)+ah(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+ &
     &                      bh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))     
        FQSUM4(K)=FQSUM4(K)+ch(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+ &
     &                      dh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
       ENDDO
 80   CONTINUE
      DO K= 2,K4
        FNSUM6(K)=0.5d0*(ac(k-1)*(ah(k-1)*cc1(k,1)+bh(k-1)*cc1(k,2))+   &
     &            bc(k-1)*(ah(k-1)*cc1(k,3)+bh(k-1)*cc1(k,4))) 
        FQSUM6(K)=0.5*(ac(k-1)*(ch(k-1)*cc1(k,1)+dh(k-1)*cc1(k,2))+     &
     &            bc(k-1)*(ch(k-1)*cc1(k,3)+dh(k-1)*cc1(k,4)))  
      ENDDO
      DO 90 K = 1, K4
       IF (K.LE.1) GOTO 90                                 
       DO i=1,k-1
        FNSUM7(K)=FNSUM7(K)+                                            &
     &            FN(I)*(ac(K)*(ah(i)*c5v(k,i,1)+bh(i)*c5v(k,i,3))+     &
     &            bc(K)*(ah(i)*c5v(k,i,2)+bh(i)*c5v(k,i,4)))
        FQSUM7(K)=FQSUM7(K)+                                            &
     &            FQ(I)*(ac(K)*ch(i)*c5v(k,i,1)+ac(K)*dh(i)*c5v(k,i,3)+ &
     &            bc(K)*ch(i)*c5v(k,i,2)+bc(K)*dh(i)*c5v(k,i,4))
       ENDDO
 90   CONTINUE
      segn1=0.d0
      segn2=0.d0
      segn3=0.d0
      segn4=0.d0
      segn5=0.d0
      segn6=0.d0
      segq1=0.d0
      segq2=0.d0
      segq3=0.d0
      segq4=0.d0
      segq5=0.d0
      segq6=0.d0
      segn7=0.d0
      segq7=0.d0
      segn8=0.d0
      segq8=0.d0
      segn9=0.d0
      segq9=0.d0
      segn10=0.d0
      segq10=0.d0      
      DO K=1,K4
       dntc(K)=-ssinc1(K)
       dmtc(K)=-ssimc1(K)
      ENDDO
      DO K = 2,K4
       dnth(K)=-(ssina1(K)+ssina2(K))+ ssina3(K)+ssina5(K)+ssina6(K)+   &
     &          ina(k,1)+ina(k,2)
       dmth(K)=-(ssima1(K)+ssima2(K))+ssima3(K)+ssima4(K)+ssima5(K)+    &
     &           ssima6(K)+ima(k,1)+ima(k,2)
       DNRIME(K)=FN(K-1)*(FNSUM1(K)+FNSUM2(K))-                         &
     &            FN(K)*(FNSUM3(K)+FNSUM4(K))+                          &
     &            FNSUM5(K)+FN(K-1)*FNSUM6(K)+FNSUM7(K)
       DQRIME(K)=FQ(K-1)*(FQSUM1(K) + FQSUM2(K))-                       &
     &           FQ(K)*(FQSUM3(K)+FQSUM4(K))+                           &
     &           FQSUM5(K)+FQ(K-1)*FQSUM6(K)+FQSUM7(K)
       segn1=segn1 + fn(k-1)*fnsum1(k)
       segn2=segn2 + fn(k-1)*fnsum2(K)
       segn3=segn3 + Fn(K)*fnsum3(k)
       segn4=segn4 + Fn(K)*fnsum4(k)
       segq1=segq1 + fq(k-1)*fqsum1(k)
       segq2=segq2 + fq(k-1)*fqsum2(K)
       segq3=segq3 + fq(k)*fqsum3(K)
       segq4=segq4 + fq(k)*fqsum4(K)
       segn5=segn5 + dnrime(k)
       segq5=segq5 + dqrime(k)
       segn7=segn7 + ina(k,2)
       segq7=segq7 + ima(k,2)
       segn8=segn8 + fnsum5(k)
       segq8=segq8 + fqsum5(k)
       segn9=segn9 + fn(k-1)*fnsum6(k)
       segq9=segq9 + fq(k-1)*fqsum6(K)
       segn10=segn10+fnsum7(k)
       segq10=segq10+fqsum7(k)         
      ENDDO
      RETURN
      END SUBROUTINE COAG3

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calculates the collisional coalesence rate between
!.. the drops and graupel particles and production of the ice fragments

      SUBROUTINE coag31(k4,ac,bc,cc,dc,ah,bh,ch,dh,dmtc,dntc,dmth,      &
     &            dnth,cc1,ccc,cccv,c5v,cicem,dsntci6, TK)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 ac(k4),bc(k4),cc(k4),dc(k4),dntc(k4),dmtc(k4)
      REAL*8 ah(k4),bh(k4),ch(k4),dh(k4),dnth(k4),dmth(k4)
      REAL (KIND=R8SIZE) :: cc1(36,4),ccc(36,36,12),cccv(36,36,4),      &
     &       c5v(36,36,4),cicem(36,36,2)
      REAL dsntci6, tk

      REAL*8 ina(36,2),ima(36,2)
      REAL*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),ssina2(36),    &
     &       ssima2(36),ssina3(36),ssima3(36),ssima4(36),ssina5(36),    &
     &       ssima5(36),ssina6(36),ssima6(36),icemul(36)
      REAL*8 funcg(36),seg1,seg2
      INTEGER I,K
!
! Precalculation for the ice multiplication formula
!
        seg1=0.d0
        seg2=0.d0
        do i=1,k4
         funcg(i)=0.d0
         icemul(i)=0.d0
        ENDDO
        IF (tk.LT.270.15.and.tk.gt.265.15) THEN
         DO i=10,k4                                                     ! r(10)=12.5 um
          DO k=1,7                                                      ! r(7)=6.25 um
           seg1=seg1+ac(K)*cicem(k,i,1)+bc(K)*cicem(k,i,2)
          ENDDO
          seg2=seg1
          DO k=8,k4
           seg2=seg2+ac(K)*cicem(k,i,1)+bc(K)*cicem(k,i,2)
          ENDDO
          IF (seg2.LT.1.d-50) THEN
           funcg(i)=0.d0
          else
           funcg(i)=seg1/seg2
          ENDIF
         ENDDO
        ENDIF
!
!  calculates ssinc1,ssina1...ssina6 and ssimc1,ssima1...ssim6 for each category at a given time
!
!
!
!  Decrease of concentration of water drops
!
      do 10 k=1,k4
      ssinc1(K)=0.d0
      do i=1,k4
       ssinc1(K)=ssinc1(K)+ac(K)*(ah(i)*ccc(i,k,9)+bh(i)*ccc(i,k,10))+  &
     &                     bc(K)*(ah(i)*ccc(i,k,11)+bh(i)*ccc(i,k,12))
       IF (tk.LT.270.15.and.tk.gt.265.15) THEN
        IF (i.ge.10.and.k.ge.10) THEN
          icemul(K)=icemul(K)+                                          &
     &           (ac(K)*(ah(i)*ccc(i,k,9)+bh(i)*ccc(i,k,10))+           &
     &           bc(K)*(ah(i)*ccc(i,k,11)+bh(i)*ccc(i,k,12)))*funcg(i)
        ENDIF
       ENDIF
      ENDDO
!
!  Decrease of mixing ratio of water drops
!
      ssimc1(K)=0.d0
      do i=1,k4
      ssimc1(K)=ssimc1(K)+cc(K)*(ah(i)*ccc(i,k,9)+bh(i)*ccc(i,k,10))+   &
     &                    dc(K)*(ah(i)*ccc(i,k,11)+bh(i)*ccc(i,k,12))
      ENDDO
!
!    Decrease of concentration and mixing ratio of hail/graupel particles
!
      ssina1(K)=0.d0
      ssima1(K)=0.d0
      IF(k.le.1) go to 2
      do i=1,k-1
       ssina1(K)=ssina1(K)+ah(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+   &
     &                     bh(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
       ssima1(K)=ssima1(K)+(ac(i)*ch(K)+cc(i)*ah(K))*ccc(k,i,5)+        &
     &                     (bc(i)*ch(K)+dc(i)*ah(K))*ccc(k,i,7)+        &
     &                     (ac(i)*dh(K)+cc(i)*bh(K))*ccc(k,i,6)+        &
     &                     (bc(i)*dh(K)+dc(i)*bh(K))*ccc(k,i,8)
      ENDDO
 2    CONTINUE
      ssina2(K)=0.d0
      ssima2(K)=0.d0
      do i=k,k4
       ssina2(K)=ssina2(K)+ah(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+  &
     &                     bh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
       ssima2(K)=ssima2(K)+ch(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+  &
     &                     dh(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ENDDO
!
! Increase of concentration and mixing ratio of hail/graupel (hail/graupels are larger than water drops)
!
      ssina3(K)=0.d0
      ssima3(K)=0.d0
      IF (k.le.2) GOTO 6
      do i=1,k-2
      ssina3(K)=ssina3(K)+ah(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+  &
     &                     bh(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
      ssima3(K)=ssima3(K)+(ch(k-1)*ac(i)+ah(k-1)*cc(i))*ccc(k,i,1)+     &
     &                     (dh(k-1)*ac(i)+bh(k-1)*cc(i))*ccc(k,i,2)+    &
     &                     (ch(k-1)*bc(i)+ah(k-1)*dc(i))*ccc(k,i,3)+    &
     &                     (dh(k-1)*bc(i)+bh(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      IF(k.le.1) GOTO 7
      do i=1,k-1
      ssima4(K)=ssima4(K)+ah(K)*(cc(i)*ccc(k,i,9)+dc(i)*ccc(k,i,11))+   &
     &                    bh(K)*(cc(i)*ccc(k,i,10)+dc(i)*ccc(k,i,12))
      ENDDO
 7    CONTINUE
!
! Increase of concentration and mixing ratio of hail/graupel (water drops are larger than hail/graupels)
!
      ssina5(K)=0.d0
      ssima5(K)=0.d0
      IF (k.le.2) GOTO 8
      do i=1,k-2
      ssina5(K)=ssina5(K)+ac(k-1)*(ah(i)*cccv(k,i,1)+bh(i)*cccv(k,i,3))+ &
     &                     bc(k-1)*(ah(i)*cccv(k,i,2)+bh(i)*cccv(k,i,4))
      ssima5(K)=ssima5(K)+(cc(k-1)*ah(i)+ac(k-1)*ch(i))*cccv(k,i,1)+    &
     &                     (dc(k-1)*ah(i)+bc(k-1)*ch(i))*cccv(k,i,2)+   &
     &                     (cc(k-1)*bh(i)+ac(k-1)*dh(i))*cccv(k,i,3)+   &
     &                     (dc(k-1)*bh(i)+bc(k-1)*dh(i))*cccv(k,i,4)
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9
      do i=1,k-1
      ssina6(K)=ssina6(K)+ac(K)*(ah(i)*c5v(k,i,1)+bh(i)*c5v(k,i,3))+    &
     &                    bc(K)*(ah(i)*c5v(k,i,2)+bh(i)*c5v(k,i,4))
      ssima6(K)=ssima6(K)+(cc(K)*ah(i)+ac(K)*ch(i))*c5v(k,i,1)+         &
     &                     (dc(K)*ah(i)+bc(K)*ch(i))*c5v(k,i,2)+        &
     &                     (cc(K)*bh(i)+ac(K)*dh(i))*c5v(k,i,3)+        &
     &                     (dc(K)*bh(i)+bc(K)*dh(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 10   CONTINUE
!
!  end loop of categories
!
!
!   calculates in(k,1), in(k,2) and im(k,1), im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
!
      DO i=1,2
        DO k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
        ENDDO
      ENDDO
!
!  loop of categories
!
      do 20 k=2,k4
!
!      Increase of concentration and mixing ratio of hail/graupels (hail/graupels are larger than clear ones)
!
      ina(k,1)=0.5d0*(ah(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+      &
     &                  bh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
      ima(k,1)=ch(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+             &
     &          dh(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of hail/graupels (drops are larger than hail/graupels)
!
      ina(k,2)=0.5d0*(ac(k-1)*(ah(k-1)*cc1(k,1)+bh(k-1)*cc1(k,2))+      &
     &                bc(k-1)*(ah(k-1)*cc1(k,3)+bh(k-1)*cc1(k,4)))
      ima(k,2)=cc(k-1)*(ah(k-1)*cc1(k,1)+bh(k-1)*cc1(k,2))+             &
     &         dc(k-1)*(ah(k-1)*cc1(k,3)+bh(k-1)*cc1(k,4))
 20   CONTINUE
!
!  end loop of categories
!
      dsntci6=0.0
      do k=1,k4
         dntc(K)=-ssinc1(K)
         dmtc(K)=-ssimc1(K)
         dnth(K)=-(ssina1(K)+ssina2(K))+ssina3(K)+ssina5(K)+ssina6(K)+  &
     &            ina(k,1)+ina(k,2)
         dmth(K)=-(ssima1(K)+ssima2(K))+ssima3(K)+ssima4(K)+ssima5(K)+  &
     &            ssima6(K)+ima(k,1)+ima(k,2)
         dsntci6=dsntci6+icemul(K)
      ENDDO
      RETURN
      END SUBROUTINE coag31

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calculates the collision between snow flakes and
!.. water drops if the tempereture is larger than 0 C. The fraction of
!.. the melted water is tracked

      SUBROUTINE COAG5M (K4,AC,BC,CC,DC,ACIR,BCIR,CCIR,DCIR,            &
     &      DMTC,DNTC,DMTCIR,DNTCIR,CC1,CCC,CCCV,C5V,FQ,DMTSNOWM0,      &
     &      DMTCIRV,DNTCIRV,IBUG)              

      IMPLICIT NONE
      INTEGER K4
      REAL*8 ac(K4),bc(K4),cc(K4),dc(K4),DNTC(K4),dmtc(K4)
      REAL*8 ACIR(K4),BCIR(K4),CCIR(K4),DCIR(K4),DNTCIR(K4),DMTCIR(K4), &
     &       DMTSNOWM0(K4),DNTCIRV(K4),DMTCIRV(K4)      
      real*8 FQ(K4)
      REAL (KIND=R8SIZE) :: cc1(36,4),ccc(36,36,12),cccv(36,36,4),      &
     &       c5v(36,36,4)

      REAL*8 ina(36,2),ima(36,2)
      REAL*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),ssina2(36),    &
     &       ssima2(36),ssina3(36),ssima3(36),ssima4(36),ssina5(36),    &
     &       ssima5(36),ssina6(36),ssima6(36),icemul(36),               &
     &       ssnown,ssnowm,smeltwm,swatn,swatm,segn(36),segm(36),       &
     &       seg1,seg2,seg3,seg4,seg5,seg6,seg7,seg8,seg9,seg10,seg11,  &
     &       sn1,sn2,sn3,sn4,sn5,sn6,sn7,sm1,sm2,sm3,sm4,sm5,sm6,sm7,sm8  
      REAL*8 FQSUM1(36),FQSUM2(36),FQSUM3(36),FQSUM4(36),FQSUM5(36),    &
     &       FQSUM6(36),FQSUM7(36),FQSUM8(36),FQSUM9(36),FQSUM10(36),   &
     &       FQSUM11(36),FNSUM3(36),FNSUM4(36),FNSUM5(36),              &
     &       FNSUM9(36),FNSUM11(36)
      INTEGER IBUG,K,I 
!      ibug=0
!
!  Decrease of concentration of water drops
!
      do 10 k=1,k4
      ssinc1(K)=0.d0
      do i=1,k4
       ssinc1(K)=ssinc1(K)+                                             &
     &           ac(K)*(ACIR(I)*ccc(i,k,9)+BCIR(I)*ccc(i,k,10))+        &
     &           bc(K)*(ACIR(i)*ccc(i,k,11)+BCIR(i)*ccc(i,k,12))
      ENDDO

!
!  Decrease of mixing ratio of water drops
!
      ssimc1(K)=0.d0
      do i=1,k4
        ssimc1(K)=ssimc1(K)+                                            &
     &             cc(K)*(ACIR(i)*ccc(i,k,9)+BCIR(i)*ccc(i,k,10))+      &   
     &             dc(K)*(ACIR(i)*ccc(i,k,11)+BCIR(i)*ccc(i,k,12))
      ENDDO

!
!    Decrease of concentration and mixing ratio of snow flakes particles
!
      ssina1(K)=0.d0
      ssima1(K)=0.d0
      IF(k.le.1) go to 2
      do i=1,k-1
       ssina1(K)=ssina1(K)+                                             &
     &           ACIR(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+           &
     &           BCIR(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
       ssima1(K)=ssima1(K)+                                             &
     &           (ac(i)*CCIR(K)+cc(i)*ACIR(K))*ccc(k,i,5)+              &
     &           (bc(i)*CCIR(K)+dc(i)*ACIR(K))*ccc(k,i,7)+              &
     &           (ac(i)*DCIR(K)+cc(i)*BCIR(K))*ccc(k,i,6)+              &
     &           (bc(i)*DCIR(K)+dc(i)*BCIR(K))*ccc(k,i,8)
      ENDDO
 2    CONTINUE
      ssina2(K)=0.d0
      ssima2(K)=0.d0
      do i=k,k4
       ssina2(K)=ssina2(K)+                                             &
     &           ACIR(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+          &
     &           BCIR(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
       ssima2(K)=ssima2(K)+                                             &
     &           CCIR(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+          &
     &           DCIR(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ENDDO
!
! Increase of concentration and mixing ratio of snow flakes (snow flakes are larger than water drops)
!
      ssina3(K)=0.d0
      ssima3(K)=0.d0
      IF (k.le.2) GOTO 6
      do i=1,k-2
       ssina3(K)=ssina3(K)+                                             &
     &           ACIR(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+         &
     &           BCIR(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
       ssima3(K)=ssima3(K)+                                             &
     &           (CCIR(k-1)*ac(i)+ACIR(k-1)*cc(i))*ccc(k,i,1)+          &
     &           (DCIR(k-1)*ac(i)+BCIR(k-1)*cc(i))*ccc(k,i,2)+          &
     &           (CCIR(k-1)*bc(i)+ACIR(k-1)*dc(i))*ccc(k,i,3)+          &
     &           (DCIR(k-1)*bc(i)+BCIR(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      IF(k.le.1) GOTO 7
      do i=1,k-1
       ssima4(K)=ssima4(K)+                                             &
     &           ACIR(K)*(cc(i)*ccc(k,i,9)+dc(i)*ccc(k,i,11))+          &
     &           BCIR(K)*(cc(i)*ccc(k,i,10)+dc(i)*ccc(k,i,12))
      ENDDO
 7    CONTINUE
!
! Increase of concentration and mixing ratio of snow flakes (water drops are larger than snow flakes)
!
      ssina5(K)=0.d0
      ssima5(K)=0.d0
      IF (k.le.2) GOTO 8
      do i=1,k-2
       ssina5(K)=ssina5(K)+                                             &
     &           ac(k-1)*(ACIR(I)*cccv(k,i,1)+BCIR(I)*cccv(k,i,3))+     &
     &           bc(k-1)*(ACIR(I)*cccv(k,i,2)+BCIR(I)*cccv(k,i,4))
       ssima5(K)=ssima5(K)+                                             &
     &           (cc(k-1)*ACIR(i)+ac(k-1)*CCIR(i))*cccv(k,i,1)+         &
     &           (dc(k-1)*ACIR(i)+bc(k-1)*CCIR(i))*cccv(k,i,2)+         &
     &           (cc(k-1)*BCIR(i)+ac(k-1)*DCIR(i))*cccv(k,i,3)+         &
     &           (dc(k-1)*BCIR(i)+bc(k-1)*DCIR(i))*cccv(k,i,4)
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9
      do i=1,k-1
       ssina6(K)=ssina6(K)+                                             &
     &           ac(K)*(ACIR(i)*c5v(k,i,1)+BCIR(i)*c5v(k,i,3))+         &
     &           bc(K)*(ACIR(i)*c5v(k,i,2)+BCIR(i)*c5v(k,i,4))
       ssima6(K)=ssima6(K)+                                             &
     &           (cc(K)*ACIR(i)+ac(K)*CCIR(i))*c5v(k,i,1)+              &
     &           (dc(K)*ACIR(i)+bc(K)*CCIR(i))*c5v(k,i,2)+              &
     &           (cc(K)*BCIR(i)+ac(K)*DCIR(i))*c5v(k,i,3)+              &
     &           (dc(K)*BCIR(i)+bc(K)*DCIR(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 10   CONTINUE
!
!   calculates in(k,1), in(k,2) and im(k,1), im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
!
      DO i=1,2
        DO k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
        ENDDO
      ENDDO
!
!  loop of categories
!
      do 20 k=2,k4
!
!      Increase of concentration and mixing ratio of snow flakes (snow flakes are larger than water drops)
!
      ina(k,1)=0.5d0*(ACIR(K-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+    &
     &                BCIR(K-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
      ima(k,1)=CCIR(K-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+           &
     &          DCIR(K-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of snow flakes (drops are larger than snow flakes)
!
      ina(k,2)=0.5d0*(ac(k-1)*(ACIR(k-1)*cc1(k,1)+BCIR(k-1)*cc1(k,2))+  &
     &                 bc(k-1)*(ACIR(k-1)*cc1(k,3)+BCIR(k-1)*cc1(k,4)))
      ima(k,2)=cc(k-1)*(ACIR(k-1)*cc1(k,1)+BCIR(k-1)*cc1(k,2))+         &
     &          dc(k-1)*(ACIR(k-1)*cc1(k,3)+BCIR(k-1)*cc1(k,4))
 20   CONTINUE
!
!  start to calculate the change of the melt water fraction due to collision
!
      DO K = 1, K4
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
       FQSUM4(K) = 0.d0
       FQSUM5(K) = 0.d0
       FQSUM6(K) = 0.d0
       FQSUM7(K) = 0.d0
       FQSUM8(K) = 0.d0
       FQSUM9(K) = 0.d0
       FQSUM10(K)= 0.d0
       FQSUM11(K)=0.0
       FNSUM3(K) = 0.d0
       FNSUM4(K) = 0.d0
       FNSUM5(K) = 0.d0
       FNSUM9(K) = 0.d0
       FNSUM11(K) = 0.d0
      ENDDO
      DO 100 K = 3, K4
       DO 110 I = 1, K - 2
        FQSUM1(K) = FQSUM1(K) +                                         &
     &               CCIR(K-1)*(AC(I)*CCC(K,I,1) + BC(I)*CCC(K,I,3)) +  &
     &               DCIR(K-1)*(AC(I)*CCC(K,I,2) + BC(I)*CCC(K,I,4))
        FQSUM8(K)=FQSUM8(K) +                                           &
     &        FQ(I)*CCIR(I)*(AC(K-1)*CCCV(K,I,1)+BC(K-1)*CCCV(K,I,2))+  &  
     &        FQ(I)*DCIR(I)*(AC(K-1)*CCCV(K,I,3)+BC(K-1)*CCCV(K,I,4))
 110   CONTINUE
 100  CONTINUE
      DO 120 K = 2, K4
       FQSUM2(K)=(CCIR(K-1)*(AC(K-1)*CC1(K,1)+BC(K-1)*CC1(K,3))+        &
     &           DCIR(K-1)*(AC(K-1)*CC1(K,2) + BC(K-1)*CC1(K,4)))
       FQSUM4(K)=(CC(K-1)*(ACIR(K-1)*CC1(K,1) + BCIR(K-1)*CC1(K,2))+    &
     &           DC(K-1)*(ACIR(K-1)*CC1(K,3) + BCIR(K-1)*CC1(K,4)))
       FNSUM4(K)=(AC(K-1)*(ACIR(K-1)*CC1(K,1) + BCIR(K-1)*CC1(K,2))+    &
     &           AC(K-1)*(ACIR(K-1)*CC1(K,3) + BCIR(K-1)*CC1(K,4)))

 120  CONTINUE
      DO 130 K = 2, K4
       DO 140 I = 1, K-1
          FQSUM3(K) = FQSUM3(K) +                                       &
     &                ACIR(K)*(CC(I)*CCC(K,I,9) + DC(I)*CCC(K,I,11)) +  & 
     &                BCIR(K)*(CC(I)*CCC(K,I,10) + DC(I)*CCC(K,I,12))
          FQSUM3(K) = FQSUM3(K) -                                       &
     &                ACIR(K)*(CC(I)*CCC(K,I,5) + DC(I)*CCC(K,I,7)) -   &
     &                BCIR(K)*(CC(I)*CCC(K,I,6) + DC(I)*CCC(K,I,8))
          FNSUM3(K) = FNSUM3(K) +                                       &
     &                ACIR(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +  &
     &                BCIR(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
          FNSUM3(K) = FNSUM3(K) -                                       &
     &                ACIR(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) -   &
     &                BCIR(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
          FQSUM9(K) = FQSUM9(K) +                                       &
     &                ACIR(I)*(CC(K)*C5V(K,I,1) + DC(K)*C5V(K,I,2)) +   &  
     &                BCIR(I)*(CC(K)*C5V(K,I,3) + DC(K)*C5V(K,I,4))
          FNSUM9(K) = FNSUM9(K) +                                       &
     &                ACIR(I)*(AC(K)*C5V(K,I,1) + BC(K)*C5V(K,I,2)) +   &
     &                BCIR(I)*(AC(K)*C5V(K,I,3) + BC(K)*C5V(K,I,4))          
          FQSUM10(K)= FQSUM10(K) +                                      &
     &                FQ(I)*CCIR(I)*(AC(K)*C5V(K,I,1)+BC(K)*C5V(K,I,2))+ &
     &                FQ(I)*DCIR(I)*(AC(K)*C5V(K,I,3)+BC(K)*C5V(K,I,4))
 140   CONTINUE
 130  CONTINUE
      DO 150 K = 3, K4
!       DO 160 I = K-2, K4
       DO 160 I = 1, K-2
         FQSUM5(K)=FQSUM5(K) +                                          &
     &             ACIR(K-1)*(CC(I)*CCC(K,I,1)+DC(I)*CCC(K,I,3))+       &
     &             BCIR(K-1)*(CC(I)*CCC(K,I,2)+DC(I)*CCC(K,I,4))   
         FNSUM5(K)=FNSUM5(K) +                                          &
     &             ACIR(K-1)*(AC(I)*CCC(K,I,1)+BC(I)*CCC(K,I,3))+       &
     &             BCIR(K-1)*(AC(I)*CCC(K,I,2)+BC(I)*CCC(K,I,4))      
         FQSUM11(K)=FQSUM11(K) +                                        &
     &              ACIR(I)*(CC(K-1)*CCCV(K,I,1)+DC(K-1)*CCCV(K,I,2))+  &
     &              BCIR(I)*(CC(K-1)*CCCV(K,I,3)+DC(K-1)*CCCV(K,I,4))
         FNSUM11(K)=FNSUM11(K) +                                        &
     &              ACIR(I)*(AC(K-1)*CCCV(K,I,1)+BC(K-1)*CCCV(K,I,2))+  &
     &              BCIR(I)*(AC(K-1)*CCCV(K,I,3)+BC(K-1)*CCCV(K,I,4))

 160   CONTINUE
 150  CONTINUE
      DO 170 K = 2, K4
       DO 180 I = 1, K-1
        FQSUM6(K) = FQSUM6(K) +                                         &
     &              CCIR(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) +     &
     &              DCIR(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
 180   CONTINUE
 170  CONTINUE
      DO 190 K =1, K4
       DO 200 I = K, K4
         FQSUM7(K) = FQSUM7(K) +                                        &
     &               CCIR(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +   &
     &               DCIR(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
 200   CONTINUE
 190  CONTINUE
      seg1=0.0
      seg2=0.0
      seg3=0.0
      seg4=0.0
      seg5=0.0
      seg6=0.0
      seg7=0.0
      seg8=0.0
      seg9=0.0
      seg10=0.0
      sm1=0.0
      sm2=0.0
      DO K=1,k4
       dntc(K)=-ssinc1(K)
       dmtc(K)=-ssimc1(K)
       DNTCIR(K)=-(ssina1(K)+ssina2(K))+ssina3(K)+ssina5(K)+ssina6(K)+  &
     &            ina(k,1)+ina(k,2)
       DMTCIR(K)=-(ssima1(K)+ssima2(K))+ssima3(K)+ssima4(K)+ssima5(K)+  &
     &            ssima6(K)+ima(k,1)+ima(k,2)
       seg1=seg1+dntc(k)
       seg2=seg2+dmtc(k)
       seg3=seg3+dntcir(k)
       seg4=seg4+dmtcir(k)
       seg5=seg5+ssima1(k)
       seg6=seg6+ssima2(k)
       seg7=seg7+ssima3(k)
       seg8=seg8+ssima4(k)
       seg9=seg9+ssima5(k)
       seg10=seg10+ssima6(k)
       sm1=sm1+ima(k,1)
       sm2=sm2+ima(k,2)
       IF (K.GT.1) THEN
        DMTSNOWM0(K) = FQ(K-1)*(FQSUM1(K) + FQSUM2(K)) + FQSUM3(K) +    &
     &          FQSUM4(K) + FQSUM5(K) - FQ(K)*(FQSUM6(K) + FQSUM7(K)) + &
     &          FQSUM8(K) + FQSUM9(K) + FQSUM10(K) + FQSUM11(K)
        DMTCIRV(K)=FQSUM3(K)+FQSUM4(K)+FQSUM5(K)+FQSUM9(K)+FQSUM11(K)
        DNTCIRV(K)=FNSUM3(K)+FNSUM4(K)+FNSUM5(K)+FNSUM9(K)+FNSUM11(K)
       ENDIF
      ENDDO
      if (ibug.eq.1) then
       write(98,*) 'dsntc,dsmtc,dsntcir,dmstcir'
       write(98,*) seg1,seg2,seg3,seg4
       write(98,*) 'seg5,seg6,seg7,seg8,seg9,seg10,sm1,sm2'
       write(98,*) seg5,seg6,seg7,seg8,seg9,seg10,sm1,sm2
      endif
      RETURN
      END SUBROUTINE COAG5M

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

!      SUBROUTINE COAG5M1 (K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,           &
!     &      DMTC,DNTC,DMTCS,DNTCS,DMTGRA,DNTGRA,CC1,CCC,                &
!     &      CCCV,C5V,FQ,DMTGRAM0,DMTGRAV,DNTGRAV,DT,ibug,ii,kz,times)
      SUBROUTINE COAG5M1(K4,AC,BC,CC,DC,AGRA,BGRA,CGRA,DGRA,           &
     &    NTGRAT,MTGRAT,MTGRAMT,                                       &
     &    DMTC,DNTC,DMTCS,DNTCS,DMTGRA,DNTGRA,CC1,CCC,                 &
     &    CCCV,C5V,FQ,DMTGRAM0,DMTGRAV,DNTGRAV,DT,CONST1,              &
     &    ibug,ii,kz,times)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 ac(K4),bc(K4),cc(K4),dc(K4),DNTC(K4),DMTC(K4),DMTCS(K4),  &
     &       DNTCS(K4)
      REAL*8 AGRA(K4),BGRA(K4),CGRA(K4),DGRA(K4),DNTGRA(K4),DMTGRA(K4),&
     &       DMTGRAM0(K4),DNTGRAV(K4),DMTGRAV(K4),                     &
     &       NTGRAT(36),MTGRAT(36),MTGRAMT(36)
      REAL*8 FQ(K4),FQNEW,CONST1
      REAL   DT,TIMES
      REAL (KIND=R8SIZE) :: cc1(36,4),ccc(36,36,12),cccv(36,36,4),      &
     &       c5v(36,36,4)
 
      REAL*8 ina(36,2),ima(36,2)
      REAL*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),ssina2(36),    &
     &       ssima2(36),ssina3(36),ssima3(36),ssima4(36),ssina5(36),    &
     &       ssima5(36),ssina6(36),ssima6(36),icemul(36)
      REAL*8 FQSUM1(36),FQSUM2(36),FQSUM3(36),FQSUM4(36),FQSUM5(36),    &
     &       FQSUM6(36),FQSUM7(36),FQSUM8(36),FQSUM9(36),FQSUM10(36),   &
     &       FQSUM11(36),FNSUM3(36),FNSUM4(36),FNSUM5(36),              &
     &       FNSUM9(36),FNSUM11(36)
      INTEGER K,I,ibug,ii,kz
 
! variables fo rcalculation of the shedding
 
      REAL*8 NTGR1(36),MTGR1(36),MTGRM1(36),MTGR2(36),NTGR2(36),       &
     &       MTGRM2(36),DSHED(36),MSHED(36),NSHED(36),NTGRNEW(36),     &
     &       MTGRNEW(36),MTGRMNEW(36),MMEAN,DELTAM(36)
      INTEGER ISHED
      REAL*8 AX0,BK0,X0,X01,X1,X2,XSTAR,DELM,FX1,FX2,SEGX1,SEGX3,      &
     &       MTNEW,CT1,QT1,QTM1,MNEW(37)
      INTEGER JSTART,J1,J10,J3,J30,J4,JJ,JJMIN,JJMAX
!
!  variables for redistribution of the shedded water
!
      REAL*8 M1,M2,MASS1,F1,F2,F3,SSM1,SSM2,CORR
      REAL*4 CM1,CM2,SIGMA

      SIGMA =1.2
 
!
!  Decrease of concentration of water drops
!
      do 10 k=1,k4
      ssinc1(K)=0.d0
      do i=1,k4
       ssinc1(K)=ssinc1(K)+                                             &
     &           ac(K)*(AGRA(I)*ccc(i,k,9)+BGRA(I)*ccc(i,k,10))+        &
     &           bc(K)*(AGRA(i)*ccc(i,k,11)+BGRA(i)*ccc(i,k,12))
      ENDDO
 
!
!  Decrease of mixing ratio of water drops
!
      ssimc1(K)=0.d0
      do i=1,k4
        ssimc1(K)=ssimc1(K)+                                            &
     &             cc(K)*(AGRA(i)*ccc(i,k,9)+BGRA(i)*ccc(i,k,10))+      &
     &             dc(K)*(AGRA(i)*ccc(i,k,11)+BGRA(i)*ccc(i,k,12))
      ENDDO
 
!
!    Decrease of concentration and mixing ratio of snow flakes particles
!
      ssina1(K)=0.d0
      ssima1(K)=0.d0
      IF(k.le.1) go to 2
      do i=1,k-1
       ssina1(K)=ssina1(K)+                                             &
     &           AGRA(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+           &
     &           BGRA(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
       ssima1(K)=ssima1(K)+                                             &
     &           (ac(i)*CGRA(K)+cc(i)*AGRA(K))*ccc(k,i,5)+              &
     &           (bc(i)*CGRA(K)+dc(i)*AGRA(K))*ccc(k,i,7)+              &
     &           (ac(i)*DGRA(K)+cc(i)*BGRA(K))*ccc(k,i,6)+              &
     &           (bc(i)*DGRA(K)+dc(i)*BGRA(K))*ccc(k,i,8)
      ENDDO
 2             CONTINUE
      ssina2(K)=0.d0
      ssima2(K)=0.d0
      do i=k,k4
       ssina2(K)=ssina2(K)+                                             &
     &           AGRA(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+          &
     &           BGRA(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
       ssima2(K)=ssima2(K)+                                             &
     &           CGRA(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+          &
     &           DGRA(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ENDDO
!
! Increase of concentration and mixing ratio of snow flakes (snow flakes are larger than water drops)
!
      ssina3(K)=0.d0
      ssima3(K)=0.d0
      IF (k.le.2) GOTO 6
      do i=1,k-2
       ssina3(K)=ssina3(K)+                                             &
     &           AGRA(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+         &
     &           BGRA(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
       ssima3(K)=ssima3(K)+                                             &
     &           (CGRA(k-1)*ac(i)+AGRA(k-1)*cc(i))*ccc(k,i,1)+          &
     &           (DGRA(k-1)*ac(i)+BGRA(k-1)*cc(i))*ccc(k,i,2)+          &
     &           (CGRA(k-1)*bc(i)+AGRA(k-1)*dc(i))*ccc(k,i,3)+          &
     &           (DGRA(k-1)*bc(i)+BGRA(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      IF(k.le.1) GOTO 7
      do i=1,k-1
       ssima4(K)=ssima4(K)+                                             &
     &           AGRA(K)*(cc(i)*ccc(k,i,9)+dc(i)*ccc(k,i,11))+          &
     &           BGRA(K)*(cc(i)*ccc(k,i,10)+dc(i)*ccc(k,i,12))
      ENDDO
 7    CONTINUE
!
! Increase of concentration and mixing ratio of snow flakes (water drops are larger than snow flakes)
!
      ssina5(K)=0.d0
      ssima5(K)=0.d0
      IF (k.le.2) GOTO 8
      do i=1,k-2
       ssina5(K)=ssina5(K)+                                             &
     &           ac(k-1)*(AGRA(I)*cccv(k,i,1)+BGRA(I)*cccv(k,i,3))+     &
     &           bc(k-1)*(AGRA(I)*cccv(k,i,2)+BGRA(I)*cccv(k,i,4))
       ssima5(K)=ssima5(K)+                                             &
     &           (cc(k-1)*AGRA(i)+ac(k-1)*CGRA(i))*cccv(k,i,1)+         &
     &           (dc(k-1)*AGRA(i)+bc(k-1)*CGRA(i))*cccv(k,i,2)+         &
     &           (cc(k-1)*BGRA(i)+ac(k-1)*DGRA(i))*cccv(k,i,3)+         &
     &           (dc(k-1)*BGRA(i)+bc(k-1)*DGRA(i))*cccv(k,i,4)
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9
      do i=1,k-1
       ssina6(K)=ssina6(K)+                                             &
     &           ac(K)*(AGRA(i)*c5v(k,i,1)+BGRA(i)*c5v(k,i,3))+         &
     &           bc(K)*(AGRA(i)*c5v(k,i,2)+BGRA(i)*c5v(k,i,4))
       ssima6(K)=ssima6(K)+                                             &
     &           (cc(K)*AGRA(i)+ac(K)*CGRA(i))*c5v(k,i,1)+              &
     &           (dc(K)*AGRA(i)+bc(K)*CGRA(i))*c5v(k,i,2)+              &
     &           (cc(K)*BGRA(i)+ac(K)*DGRA(i))*c5v(k,i,3)+              &
     &           (dc(K)*BGRA(i)+bc(K)*DGRA(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 10   CONTINUE
!
!   calculates in(k,1), in(k,2) and im(k,1), im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
!
      DO i=1,2
        DO k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
        ENDDO
      ENDDO
!
!  loop of categories
!
      do 20 k=2,k4
!
!      Increase of concentration and mixing ratio of snow flakes (snow flakes are larger than water drops)
!
      ina(k,1)=0.5d0*(AGRA(K-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+    &
     &                BGRA(K-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
      ima(k,1)=CGRA(K-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+           &
     &          DGRA(K-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of snow flakes (drops are larger than snow flakes)
!
      ina(k,2)=0.5d0*(ac(k-1)*(AGRA(k-1)*cc1(k,1)+BGRA(k-1)*cc1(k,2))+  &
     &                 bc(k-1)*(AGRA(k-1)*cc1(k,3)+BGRA(k-1)*cc1(k,4)))
      ima(k,2)=cc(k-1)*(AGRA(k-1)*cc1(k,1)+BGRA(k-1)*cc1(k,2))+         &
     &          dc(k-1)*(AGRA(k-1)*cc1(k,3)+BGRA(k-1)*cc1(k,4))
 20   CONTINUE
!
!  start to calculate the change of the melt water fraction due to collision
!
      DO K = 1, K4
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
       FQSUM4(K) = 0.d0
       FQSUM5(K) = 0.d0
       FQSUM6(K) = 0.d0
       FQSUM7(K) = 0.d0
       FQSUM8(K) = 0.d0
       FQSUM9(K) = 0.d0
       FQSUM10(K)= 0.d0
       FQSUM11(K)=0.0
       FNSUM3(K) = 0.d0
       FNSUM4(K) = 0.d0
       FNSUM5(K) = 0.d0
       FNSUM9(K) = 0.d0
       FNSUM11(K) = 0.d0
      ENDDO
      DO 100 K = 3, K4
       DO 110 I = 1, K - 2
        FQSUM1(K) = FQSUM1(K) +                                         &
     &               CGRA(K-1)*(AC(I)*CCC(K,I,1) + BC(I)*CCC(K,I,3)) +  &
     &               DGRA(K-1)*(AC(I)*CCC(K,I,2) + BC(I)*CCC(K,I,4))
        FQSUM8(K)=FQSUM8(K) +                                           &
     &        FQ(I)*CGRA(I)*(AC(K-1)*CCCV(K,I,1)+BC(K-1)*CCCV(K,I,2))+  &
     &        FQ(I)*DGRA(I)*(AC(K-1)*CCCV(K,I,3)+BC(K-1)*CCCV(K,I,4))
 110   CONTINUE
 100  CONTINUE
      DO 120 K = 2, K4
       FQSUM2(K)=(CGRA(K-1)*(AC(K-1)*CC1(K,1)+BC(K-1)*CC1(K,3))+        &
     &           DGRA(K-1)*(AC(K-1)*CC1(K,2) + BC(K-1)*CC1(K,4)))
       FQSUM4(K)=(CC(K-1)*(AGRA(K-1)*CC1(K,1) + BGRA(K-1)*CC1(K,2))+    &
     &           DC(K-1)*(AGRA(K-1)*CC1(K,3) + BGRA(K-1)*CC1(K,4)))
       FNSUM4(K)=(AC(K-1)*(AGRA(K-1)*CC1(K,1) + BGRA(K-1)*CC1(K,2))+    &
     &           AC(K-1)*(AGRA(K-1)*CC1(K,3) + BGRA(K-1)*CC1(K,4)))
 
 120  CONTINUE
      DO 130 K = 2, K4
       DO 140 I = 1, K-1
          FQSUM3(K) = FQSUM3(K) +                                       &
     &                AGRA(K)*(CC(I)*CCC(K,I,9) + DC(I)*CCC(K,I,11)) +  &
     &                BGRA(K)*(CC(I)*CCC(K,I,10) + DC(I)*CCC(K,I,12))
          FQSUM3(K) = FQSUM3(K) -                                       &
     &                AGRA(K)*(CC(I)*CCC(K,I,5) + DC(I)*CCC(K,I,7)) -   &
     &                BGRA(K)*(CC(I)*CCC(K,I,6) + DC(I)*CCC(K,I,8))
          FNSUM3(K) = FNSUM3(K) +                                       &
     &                AGRA(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +  &
     &                BGRA(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
          FNSUM3(K) = FNSUM3(K) -                                       &
     &                AGRA(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) -   &
     &                BGRA(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
          FQSUM9(K) = FQSUM9(K) +                                       &
     &                AGRA(I)*(CC(K)*C5V(K,I,1) + DC(K)*C5V(K,I,2)) +   &
     &                BGRA(I)*(CC(K)*C5V(K,I,3) + DC(K)*C5V(K,I,4))
          FNSUM9(K) = FNSUM9(K) +                                       &
     &                AGRA(I)*(AC(K)*C5V(K,I,1) + BC(K)*C5V(K,I,2)) +   &
     &                BGRA(I)*(AC(K)*C5V(K,I,3) + BC(K)*C5V(K,I,4))
          FQSUM10(K)= FQSUM10(K) +                                      &
     &                FQ(I)*CGRA(I)*(AC(K)*C5V(K,I,1)+BC(K)*C5V(K,I,2))+ &
     &                FQ(I)*DGRA(I)*(AC(K)*C5V(K,I,3)+BC(K)*C5V(K,I,4))
 140          CONTINUE
 130             CONTINUE
      DO 150 K = 3, K4
!       DO 160 I = K-2, K4
       DO 160 I = 1, K-2
         FQSUM5(K)=FQSUM5(K) +                                          &
     &             AGRA(K-1)*(CC(I)*CCC(K,I,1)+DC(I)*CCC(K,I,3))+       &
     &             BGRA(K-1)*(CC(I)*CCC(K,I,2)+DC(I)*CCC(K,I,4))
         FNSUM5(K)=FNSUM5(K) +                                          &
     &             AGRA(K-1)*(AC(I)*CCC(K,I,1)+BC(I)*CCC(K,I,3))+       &
     &             BGRA(K-1)*(AC(I)*CCC(K,I,2)+BC(I)*CCC(K,I,4))
         FQSUM11(K)=FQSUM11(K) +                                        &
     &              AGRA(I)*(CC(K-1)*CCCV(K,I,1)+DC(K-1)*CCCV(K,I,2))+  &
     &              BGRA(I)*(CC(K-1)*CCCV(K,I,3)+DC(K-1)*CCCV(K,I,4))
         FNSUM11(K)=FNSUM11(K) +                                        &
     &              AGRA(I)*(AC(K-1)*CCCV(K,I,1)+BC(K-1)*CCCV(K,I,2))+  &
     &              BGRA(I)*(AC(K-1)*CCCV(K,I,3)+BC(K-1)*CCCV(K,I,4))
 
 160   CONTINUE
 150  CONTINUE
      DO 170 K = 2, K4
       DO 180 I = 1, K-1
        FQSUM6(K) = FQSUM6(K) +                                          &
     &              CGRA(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) +      &
     &              DGRA(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
 180   CONTINUE
 170  CONTINUE
      DO 190 K =1, K4
       DO 200 I = K, K4
         FQSUM7(K) = FQSUM7(K) +                                        &
     &               CGRA(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +   &
     &               DGRA(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
 200   CONTINUE
 190  CONTINUE
      DO K=1,k4
       dntc(K)=-ssinc1(K)
       dmtc(K)=-ssimc1(K)
       DNTGRA(K)=-(ssina1(K)+ssina2(K))+ssina3(K)+ssina5(K)+ssina6(K)+  &
     &            ina(k,1)+ina(k,2)
       DMTGRA(K)=-(ssima1(K)+ssima2(K))+ssima3(K)+ssima4(K)+ssima5(K)+  &
     &            ssima6(K)+ima(k,1)+ima(k,2)
       IF (K.GT.1) THEN
        DMTGRAM0(K) = FQ(K-1)*(FQSUM1(K) + FQSUM2(K)) + FQSUM3(K) +    &
     &          FQSUM4(K) + FQSUM5(K) - FQ(K)*(FQSUM6(K) + FQSUM7(K)) + &
     &          FQSUM8(K) + FQSUM9(K) + FQSUM10(K) + FQSUM11(K)
        DMTGRAV(K)=FQSUM3(K)+FQSUM4(K)+FQSUM5(K)+FQSUM9(K)+FQSUM11(K)
        DNTGRAV(K)=FNSUM3(K)+FNSUM4(K)+FNSUM5(K)+FNSUM9(K)+FNSUM11(K)
        DMTGRAM0(K)=DMAX1(0.d0,DMTGRAM0(K))
        DMTGRAV(K)=DMAX1(0.d0,DMTGRAV(K))
        DNTGRAV(K)=DMAX1(0.d0,DNTGRAV(K))
       ENDIF
       NTGR1(K)=NTGRAT(K) + DNTGRA(k)*CONST1
       MTGR1(K)=MTGRAT(K) + DMTGRA(K)*CONST1
       MTGRM1(K)=MTGRAMT(K)+DMTGRAM0(K)*CONST1
       NTGR2(K)=NTGR1(K)
       MTGR2(K)=MTGR1(K)
       MTGRM2(K)=MTGRM1(K)
      ENDDO
!      RETURN            ! return in the case of  no collison induce sehedding          
!                                                                                                                                                                                                     
!    calculation of shedding due to the collison of melted garupel an dwater drops      
!
      MNEW(1) = M(1) 
      DSHED(1)=0.0
      MSHED(1)=0.d0
      NSHED(1)=0.d0
      DELTAM(1)=0.d0
      DNTCS(1)=0.d0
      DMTCS(1)=0.d0
      NTGRNEW(1)=0.d0
      MTGRNEW(1)=0.d0
      MTGRMNEW(1)=0.d0
      DO K =2,K4
       DSHED(K)=0.0
       MSHED(K)=0.d0
       NSHED(K)=0.d0
       DELTAM(K)=0.d0
       DNTCS(K)=0.d0
       DMTCS(K)=0.d0
       NTGRNEW(K)=0.d0
       MTGRNEW(K)=0.d0
       MTGRMNEW(K)=0.d0
       FQNEW = 0.0
       MNEW(K)=M(K)
       IF (NTGR2(K).GT.0.d0) THEN
        MMEAN=MTGR2(K)/NTGR2(K)
       ELSE
        MMEAN=1.5*M(K)
       ENDIF
       IF (DNTGRAV(K).GT.0.0) THEN
        IF (MTGR1(K).GT.0.0) THEN
         FQNEW =MTGRM1(K)/MTGR1(K)
        ENDIF
        NTGR1(K)=NTGR2(K)-CONST1*DNTGRAV(K)
        NTGR1(K)=DMAX1(0.d0,NTGR1(K))
        MTGR1(K)=MMEAN*NTGR1(K)
        NTGRNEW(K)=NTGR2(K)-NTGR1(K)
        MTGRNEW(K)=MTGR2(K)-MTGR1(K)
        ISHED=0
        IF (FQNEW.LE.0.25) THEN
         DSHED(K)=0
         ISHED=0
        ELSE IF (FQNEW.GT.0.25.AND.FQNEW.LT.0.30) THEN
         DSHED(K)=CONST1*DMTGRAV(K)
         ISHED=1
        ELSE
         DSHED(K)=(FQNEW-0.25)*MMEAN*NTGRNEW(K)
         DSHED(K)=DMAX1(CONST1*DMTGRAV(K),DSHED(K))
         ISHED=2
        ENDIF
        IF (DSHED(K).GT.0.d0) THEN
         FQNEW=MTGRM2(K)/MTGR2(K)
         MTGRMNEW(K)=FQNEW*MMEAN*NTGRNEW(K)-DSHED(K)
         IF (MTGRMNEW(K).LT.0.d0) THEN
           DSHED(K)=FQNEW*MMEAN*NTGRNEW(K)
           MTGRMNEW(K)=0.d0
         ENDIF
         MTGRMNEW(K)=DMAX1(0.d0,MTGRMNEW(K))
         MTGRNEW(K)=MTGRNEW(K)-DSHED(K)
         MTGRM1(K)= MTGRM2(K)-FQNEW*MMEAN*NTGRNEW(K)
         MTGRM1(K)=DMAX1(0.d0,MTGRM1(K))
        ELSE
         NTGR1(K)=NTGR2(K)
         MTGR1(K)=MTGR2(K)
         MTGRM1(K)= MTGRM2(K)
         NTGRNEW(K)=0.d0
         MTGRNEW(K)=0.d0
         MTGRMNEW(K)=0.d0
        ENDIF
        IF (NTGRNEW(K).LE.0.0.OR.MTGRNEW(K).LE.0.d0) THEN
          DELTAM(K)=0.d0
          NTGR1(K)=NTGR2(K)
          MTGR1(K)=MTGR2(K)
          MTGRM1(K)= MTGRM2(K)
          DSHED(K)= 0.d0
          ISHED=0
        ELSE
          DELTAM(K)=MTGR2(K)/NTGR2(K)-MTGRNEW(K)/NTGRNEW(K)
        ENDIF
        MNEW(K)=M(K)-DELTAM(K)
        IF (MNEW(K).LE.MNEW(K-1)) THEN
          MNEW(K)=1.001*MNEW(K-1)
          NTGRNEW(K)=MTGRNEW(K)/(1.001*MNEW(K))
        ENDIF
 
!                                                                      
!    the number  of the drops formed from the shed water              
!                                                                                                                                                                                                     
        IF (ISHED.EQ.1) THEN          ! only one drop form due to the shedding                                                                                                                        
         MSHED(K)=DSHED(K)
         NSHED(K)=DMAX1(0.d0,NTGRNEW(K)) !DNTGRAV(K)
        ENDIF
        IF (ISHED.EQ.2) THEN          ! 2 drops with equal mass form 
         MSHED(K)=DSHED(K)
         NSHED(K)=2.d0*DMAX1(0.d0,NTGRNEW(K)) !5*DNTGRAV(K)
        ENDIF
       ENDIF
      ENDDO
      MNEW(K4+1)=M(K4+1)
      IF (NTGRNEW(K4).GT.0.0) THEN
       MNEW(K4+1)=M(K4+1)-DELTAM(K4)
       IF (MNEW(K4+1).LE.MNEW(K4)) THEN
        MNEW(K4+1)=1.1*MNEW(K4)
       ENDIF
      ENDIF
      if (ibug.eq.1) then
       do k=1,k4
        write(98,*)'k,ntgr1,ntgr2,ntgrnew',k,ntgr1(k),ntgr2(k),ntgrnew(k)
        write(98,*)'k,mtgr1,mtgr2,mtgrnew',k,mtgr1(k),mtgr2(k),mtgrnew(k)
        write(98,*)'k,mtgrm1,mtgrm2,mtgrmnew',k,mtgrm1(k),mtgrm2(k),mtgrmnew(k)
        write(98,*)'k,dshed,nshed,dntgrav',k,dshed(k),nshed(k),dntgrav(k)
       enddo
       write(98,*)
       do k=1,k4
        write(98,*) 'k,deltam,mnew,m',k,deltam(k),mnew(k),m(k)
       enddo
      endif
 
 
!   redistribution of the shedded water                                                                                                                                                               
!      DO 250 K =2,K4
!        IF (NSHED(K).GT.0d0) THEN
!         MMEAN=MSHED(K)/NSHED(K)
!         IF (MMEAN.LT.1.5d0*M(2)) THEN
!           NSHED(K)=MSHED(K)/(1.5d0*M(2))
!           MMEAN = 1.5d0*M(2)
!         ENDIF
!         IF (MMEAN.GT.1.5d0*M(K4-2)) THEN
!           NSHED(K)=MSHED(K)/(1.5d0*M(K4-2))
!           MMEAN = 1.5d0*M(K4-2)
!         ENDIF
!        ELSE
!         GOTO 250
!        ENDIF
!        I=1
!260     I=I+1
!        IF (I.GT.K4) THEN
!         WRITE(*,*) 'mass of the sheded drop is too large'
!         write(*,*) 'ii,kz,times',ii,kz,times
!         write(*,*) 'k,mshed,nshed,dntgrav',k,mshed(k),nshed(k),dntgrav(k)
!         STOP
!        ENDIF
!        IF (M(I).LT.MMEAN) GOTO 260
!        I=I-1
!        DNTCS(I)=DNTCS(I)+NSHED(K)
!        DMTCS(I)=DMTCS(I)+MSHED(K)
!250   CONTINUE
        CM2=2.d0*(LOG(SIGMA))**2.0
        DO 250 K =2,K4
         IF (NSHED(K).GT.0d0) THEN
          MMEAN=MSHED(K)/NSHED(K)
          IF (MMEAN.LT.1.5d0*M(2)) THEN
           NSHED(K)=MSHED(K)/(1.5d0*M(2))
           MMEAN = 1.5d0*M(2)
          ENDIF
          IF (MMEAN.GT.1.5d0*M(K4-2)) THEN
           NSHED(K)=MSHED(K)/(1.5d0*M(K4-2))
           MMEAN = 1.5d0*M(K4-2)
          ENDIF
         ELSE
          GOTO 250
         ENDIF
         CM1=MSHED(K)/SQRT(2.*PI)/LOG(SIGMA)
         DO I=1,K4
          M1=M(I)
          M2=M(I+1)
          DELM=M2-M1
          F1=CM1/(3.*M1)*EXP(-(0.3333*LOG(M1/MMEAN))**2./CM2)
          F2=CM1/(3.*M2)*EXP(-(0.3333*LOG(M2/MMEAN))**2./CM2)
          F3=CM1/(3.*0.5*(M1+M2))*                                     &
                  EXP(-(0.3333*LOG(0.5*(M1+M2)/MMEAN))**2./CM2) 
          DMTCS(I)=DMTCS(I)+(F1+4.d0*F3+F2)*DELM/6.d0
         ENDDO
250     CONTINUE
        SSM1=0.d0
        SSM2=0.d0
        DO K=1,K4
         SSM1=SSM1+MSHED(K)
         SSM2=SSM2+DMTCS(K)
        ENDDO
        CORR=1.d0
        IF (SSM2.GT.0.d0) CORR=SSM1/SSM2
        DO K=1,K4
         DMTCS(K)=CORR*DMTCS(K)
         DNTCS(K)=DMTCS(K)/(1.5*M(K))
        ENDDO

       if (ibug.eq.1) then
         do k=1,k4
          write(98,*) 'k,dntcs,dmtcs',k,dntcs(k),dmtcs(k)
         enddo
       endif
!
!     redistribution  graupel paticles lost mass by shedding
      DO 300 K = 2,K4
       IF (DSHED(K).LE.0.0) GOTO 300
       MTNEW =MTGRNEW(K)
       MMEAN= MTNEW/NTGRNEW(K)
       JSTART=1
       J1 = JSTART
310    J1 = J1 + 1
       IF (M(J1).LE.MNEW(K)) GOTO 310
       J10 = J1-1
       J3 = J10
315    J3 = J3 + 1
       IF (M(J3).LT.MNEW(K+1)) GOTO 315
       J30 = J3 - 1
       IF (J10.EQ.J30) THEN
        NTGR1(J10) = NTGR1(J10) + NTGRNEW(K)
        MTGR1(J10) = MTGR1(J10) + MTNEW
        MTGRM1(J10) = MTGRM1(J10) + MTGRMNEW(K)
        GOTO 300
       ENDIF
       IF (MMEAN.LT.MNEW(K)) THEN
        NTGR1(J10) = NTGR1(J10) + NTGRNEW(K)
        MTGR1(J10) = MTGR1(J10) + MTNEW
        MTGRM1(J10) = MTGRM1(J10) + MTGRMNEW(K)
        GOTO 300
       ENDIF
       IF (MMEAN.GT.MNEW(K+1)) THEN
        NTGR1(J30) = NTGR1(J30) + NTGRNEW(K)
        MTGR1(J30) = MTGR1(J30) + MTNEW
        MTGRM1(J30) = MTGRM1(J30) + MTGRMNEW(K)
        GOTO 300
       ENDIF
       DELM = MNEW(K+1) - MNEW(K)
       AX0 = NTGRNEW(K)/DELM
       X0 = 0.5d0*(MNEW(K) + MNEW(K+1))
       BK0 = 12.d0*(MTNEW - X0*NTGRNEW(K))/DELM**3.d0
       FX1 = AX0 + BK0*(MNEW(K) - X0)
       FX2 = AX0 + BK0*(MNEW(K +1) - X0)
       X01 = X0
       IF (FX1.LT.0.d0) THEN
        AX0 = 0.d0
        XSTAR = 3.d0*MMEAN - 2.d0*MNEW(K+1)
!        BK0 = 2.d0*NTH2(K)/(MNEW(K) - XSTAR)**2.d0                                                                                                                                                   
        BK0 = 2.d0*NTGRNEW(K)/(MNEW(K+1) - XSTAR)**2.d0
        X01 = XSTAR
       ENDIF
       IF (FX2.LT.0.d0) THEN
        AX0 = 0.d0
        XSTAR = 3.d0*MMEAN - 2.d0*MNEW(K)
        BK0 = -2.d0*NTGRNEW(K)/(MNEW(K) - XSTAR)**2.d0
        X01 = XSTAR
       ENDIF
       IF (FX1.LT.0.d0) THEN
        IF (XSTAR.GE.M(J10+1)) THEN
         CT1 = 0.d0
         QT1 = 0.d0
         GOTO 320
        ENDIF
         X1 = XSTAR
         X2 = M(J10+1)
         GOTO 325
       ENDIF
       IF (FX2.LT.0.d0) THEN
        IF (XSTAR.GE.M(J10+1)) THEN
         X1 = MNEW(K)
         X2 = M(J10+1)
        ELSE
         CT1 = NTGRNEW(K)
         QT1 = MTNEW
         QTM1= MTGRMNEW(K)
         GOTO 340
        ENDIF
        GOTO 325
       ENDIF
       X1 = MNEW(K)
       X2 = M(J10 +1)
325    SEGX1 = (X2 - X1)
       SEGX3 = (X2 + X1)
       CT1 = SEGX1*(AX0 - BK0*(X01 - 0.5d0*SEGX3))
       QT1=AX0*0.5d0*SEGX1*SEGX3 +                                        &
     &     BK0*(0.33333d0*(X2**3.d0 - X1**3.d0)                           &
     &                               -0.5d0*X01*SEGX1*SEGX3)
340    NTGR1(J10) = NTGR1(J10) + CT1
       MTGR1(J10) = MTGR1(J10) + QT1
       MTGRM1(J10)= MTGRM1(J10)+ MTGRMNEW(K)/MTNEW*QT1
320    IF (FX2.LT.0.d0) THEN
        IF (XSTAR.LE.M(J30)) THEN
         CT1 = 0.d0
         QT1 = 0.d0
         QTM1 = 0.d0
         GOTO 330
        ENDIF
        X1 = M(J30)
        X2 = XSTAR
        GOTO 335
       ENDIF
       IF (FX1.LT.0.d0) THEN
        IF (XSTAR.LT.M(J30)) THEN
         X1 = M(J30)
         X2 = MNEW(K+1)
        ELSE
         CT1 = NTGRNEW(K)
         QT1 = MTNEW
         QTM1= MTGRMNEW(K)
         GOTO 345
        ENDIF
        GOTO 335
       ENDIF
       X1 = M(J30)
       X2 = MNEW(K+1)
335    SEGX1 = (X2-X1)
       SEGX3 = (X2+X1)
       CT1 = SEGX1*(AX0 - BK0*(X01 - 0.5d0*SEGX3))
       QT1 = AX0*0.5d0*SEGX1*SEGX3 +                                       &
     &       BK0*SEGX1*(0.333333d0*(X2**2.d0+X2*X1+X1**2.d0)-              &
     &      0.5d0*X01*SEGX3)
345    NTGR1(J30) = NTGR1(J30) + CT1
       MTGR1(J30) = MTGR1(J30) + QT1
       MTGRM1(J30)= MTGRM1(J30)+ MTGRMNEW(K)/MTNEW*QT1
330    IF (J30.GT.J10+1) THEN
        JJMIN = J10 + 1
        JJMAX = J30 - 1
        IF (FX1.LT.0.d0.OR.FX2.LT.0.d0) THEN
         J4 = J10
350      J4 = J4 + 1
         IF (XSTAR.GT.M(J4)) GOTO 350
         J4 = J4 - 1
         IF (FX1.LT.0.d0) THEN
          JJMIN = MAX(J4,J10+1)
         ENDIF
         IF (FX2.LT.0.d0) THEN
          JJMAX = MIN(J4,J30-1)
         ENDIF
        ENDIF
        DO JJ = JJMIN, JJMAX
          X1= M(JJ)
          X2 = M(JJ+1)
          IF (FX1.LT.0.d0.AND.JJ.EQ.JJMIN) THEN
           X1 = DMAX1(XSTAR,M(JJ))
           X2 = M(JJ+1)
          ENDIF
          IF (FX2.LT.0.d0.AND.JJ.EQ.JJMAX) THEN
           X1 = M(JJ)
           X2 = DMIN1(XSTAR,M(JJ+1))
          ENDIF
          SEGX1 = (X2 - X1)
          SEGX3 = (X2 + X1)
          CT1 = SEGX1*(AX0 - BK0*(X01 - 0.5d0*SEGX3))
          QT1 = AX0*0.5d0*SEGX1*SEGX3 +                                &
     &          BK0*SEGX1*(0.33333d0*(X2**2.d0+X2*X1+X1**2.d0) -       &
     &         0.5d0*X01*SEGX3)
          NTGR1(JJ)= NTGR1(JJ) + CT1
          MTGR1(JJ)= MTGR1(JJ) + QT1
          MTGRM1(JJ)= MTGRM1(JJ)+ MTGRMNEW(K)/MTNEW*QT1
        ENDDO
       ENDIF
300   CONTINUE
      DO K = 1, K4
       DNTGRA(K)=(NTGR1(K)-NTGRAT(K))/CONST1
       DMTGRA(K)=(MTGR1(K)-MTGRAT(K))/CONST1
       DMTGRAM0(K)=(MTGRM1(K)-MTGRAMT(K))/CONST1
       DNTCS(K)=DNTCS(K)/CONST1
       DMTCS(K)=DMTCS(K)/CONST1
       if (ibug.eq.1) then
        write(98,*)'k,ntgr1,ntgra',k,ntgr1(k),ntgra(k)
        write(98,*)'k,mtgr1,mtgra',k,mtgr1(k),mtgra(k)
        write(98,*)'k,mtgrm1,mtgram',k,mtgrm1(k),mtgram(k)
       endif
      ENDDO
      RETURN
      END SUBROUTINE COAG5M1

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subrutine calculates the riming of the pristine ice and the
!.. change of the rimed particle and rimed water mass due to this
!.. process

      SUBROUTINE COAG40(K4,ACI,BCI,CCI,DCI,AC,BC,CC,DC,DMTCI1,DNTCI1,   &
     &          DMTC,DNTC,DMTS1,DNTS1,DMTG,DNTG,CC1,CCC,C5,CCCV,C5V,    &
     &          DQRIME,DNRIME)

      IMPLICIT NONE
      integer K4
      real*8 ACI(K4),BCI(K4),cci(K4),dci(K4),ac(K4),bc(K4),cc(K4),      &
     &    DC(K4),DMTCI1(K4),DNTCI1(K4),dntc(K4),dmtc(K4),DNTS1(K4),     &
     &    DMTS1(K4),DNTG(K4),DMTG(K4),DQRIME(K4),DNRIME(K4)
      REAL (KIND=R8SIZE) :: CC1(36,4),CCC(36,36,8),C5(36,36,4),         &
     &       CCCV(36,36,4),C5V(36,36,4)

      REAL FQSUM1(36),FQSUM2(36),FQSUM3(36)
      real*8 ina(36,2),ima(36,2)
      real*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),               &
     &       ssina3(36),ssima3(36),ssina4(36),ssima4(36),ssina5(36),    &
     &       ssima5(36),ssina6(36),ssima6(36)
      INTEGER K,I,I1
      real*8 segn1,segn2,segn3,segn4,segn5,segn6,segq1,segq2,segq3,     &
     &       segq4,segq5,segq6,seqq7
!
!  calculates ssinc1,ssina1...ssina6 and ssimc1,ssima1...ssim6 for each category at a given time
!
!  Decrease of concentration of water drops
!
      do 10 k=1,k4
       ssinc1(K)=0.d0
       do i=1,k4
       ssinc1(K)=ssinc1(K)+                                             &
     &    ac(K)*(aci(i)*ccc(i,k,5)+bci(i)*ccc(i,k,6))+                  &
     &    bc(K)*(aci(i)*ccc(i,k,7)+bci(i)*ccc(i,k,8))
       ENDDO
!
!  Decrease of mixing ratio of water drops
!
       ssimc1(K)=0.d0
       do i=1,k4
       ssimc1(K)=ssimc1(K)+                                             &
     &     cc(K)*(aci(i)*ccc(i,k,5)+bci(i)*ccc(i,k,6))+                 &
     &     dc(K)*(aci(i)*ccc(i,k,7)+bci(i)*ccc(i,k,8))
       ENDDO
 10   CONTINUE
!
!    Decrease of concentration and mixing ratio of ice crystals
!
      do 15 k=1,k4
      ssina1(K)=0.d0
      ssima1(K)=0.d0                             ! first term
      do i=1,k4
      ssina1(K)=ssina1(K)+                                              &
     &          aci(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+             &
     &          bci(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
      ssima1(K)=ssima1(K)+                                              &
     &          cci(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+             &
     &          dci(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
      ENDDO
 15   CONTINUE
!
!
! Increase of concentration and mixing ratio of pristine ice crystal (ice crystals are larger than water drops)
!
      do 16 k=1,k4
      ssina3(K)=0.d0
      ssima3(K)=0.d0                                    ! first term
      IF (k.le.2) GOTO 6
      do i=1,k-2
      ssina3(K)=ssina3(K)+                                              &
     &          aci(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+           &
     &          bci(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
      ssima3(K)=ssima3(K)+                                              &
     &          (cci(k-1)*ac(i)+aci(k-1)*cc(i))*ccc(k,i,1)+             &
     &          (dci(k-1)*ac(i)+bci(k-1)*cc(i))*ccc(k,i,2)+             &
     &          (cci(k-1)*bc(i)+aci(k-1)*dc(i))*ccc(k,i,3)+             &
     &          (dci(k-1)*bc(i)+bci(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      ssina4(K)=0.d0
      IF(k.le.1) GOTO 7
      do i=1,k-1                                           ! second term
      ssina4(K)=ssina4(K)+                                              &
     &          aci(K)*(ac(i)*c5(k,i,1)+bc(i)*c5(k,i,3))+               &
     &          bci(K)*(ac(i)*c5(k,i,2)+bc(i)*c5(k,i,4))
      ssima4(K)=ssima4(K)+                                              &
     &          c5(k,i,1)*(cci(K)*ac(i)+aci(K)*cc(i))+                  &
     &          c5(k,i,2)*(dci(K)*ac(i)+bci(K)*cc(i))+                  &
     &          c5(k,i,3)*(cci(K)*bc(i)+aci(K)*dc(i))+                  &
     &          c5(k,i,4)*(dci(K)*bc(i)+bci(K)*dc(i))
      ENDDO
 7    CONTINUE
 16   CONTINUE
!
! Increase of concentration and mixing ratio of frozen drop embryos (water drops are larger than ice crystals)
!
      do 18 k=1,k4
      ssina5(K)=0.d0
      ssima5(K)=0.d0                                    ! first term
      IF (k.le.2) GOTO 8
      do i=1,k-2
      ssina5(K)=ssina5(K)+                                              &
     &          ac(k-1)*(aci(i)*cccv(k,i,1)+bci(i)*cccv(k,i,3))+        &
     &          bc(k-1)*(aci(i)*cccv(k,i,2)+bci(i)*cccv(k,i,4))
      ssima5(K)=ssima5(K)+                                              &
     &          (cc(k-1)*aci(i)+ac(k-1)*cci(i))*cccv(k,i,1)+            &
     &          (dc(k-1)*aci(i)+bc(k-1)*cci(i))*cccv(k,i,2)+            &
     &          (cc(k-1)*bci(i)+ac(k-1)*dci(i))*cccv(k,i,3)+            &
     &          (dc(k-1)*bci(i)+bc(k-1)*dci(i))*cccv(k,i,4)
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9                              ! second terms
      do i=1,k-1
      ssina6(K)=ssina6(K)+                                              &
     &          ac(K)*(aci(i)*c5v(k,i,1)+bci(i)*c5v(k,i,3))+            &
     &          bc(K)*(aci(i)*c5v(k,i,2)+bci(i)*c5v(k,i,4))
      ssima6(K)=ssima6(K)+                                              &
     &          (cc(K)*aci(i)+ac(K)*cci(i))*c5v(k,i,1)+                 &
     &          (dc(K)*aci(i)+bc(K)*cci(i))*c5v(k,i,2)+                 &
     &          (cc(K)*bci(i)+ac(K)*dci(i))*c5v(k,i,3)+                 &
     &          (dc(K)*bci(i)+bc(K)*dci(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 18   CONTINUE
!
!  end loop of categories
!
!
!  calculates in(k,1),in(k,2) and im(k,1),im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
      do i=1,2
         do k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
         ENDDO
      ENDDO
!
!  loop of categories
      do 30 k=2,k4
!
!      Increase of concentration and mixing ratio of rimed ice crystal (ice crystals are larger than clear ones)
!
        ina(k,1)=0.5d0*                                                 &
     &           (aci(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+         &
     &           bci(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
        ima(k,1)=cci(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+          &
     &           dci(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of frozen drops (drops are larger than ice crystals)
!
        ina(k,2)=0.5d0*                                                 &
     &           (ac(k-1)*(aci(k-1)*cc1(k,1)+bci(k-1)*cc1(k,2))+        &
     &           bc(k-1)*(aci(k-1)*cc1(k,3)+bci(k-1)*cc1(k,4)))
        ima(k,2)=cc(k-1)*(aci(k-1)*cc1(k,1)+bci(k-1)*cc1(k,2))+         &
     &           dc(k-1)*(aci(k-1)*cc1(k,3)+bci(k-1)*cc1(k,4))
 30   CONTINUE
      DO K = 1,K4
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
      ENDDO
      DO 50 K=1,K4
       IF (k.le.2) GOTO 56
       DO I=1,K-2
        FQSUM1(K) = FQSUM1(K) +                                         &
     &        aci(k-1)*(cc(i)*ccc(k,i,1)+dc(i)*ccc(k,i,3))+             &
     &        bci(k-1)*(cc(i)*ccc(k,i,2)+dc(i)*ccc(k,i,4))
       ENDDO
 56    CONTINUE
       IF(k.le.1) GOTO 57
       do i=1,k-1                                           ! second term
       FQSUM2(K)=FQSUM2(K)+                                             &
     &        aci(K)*(cc(i)*c5(k,i,1)+dc(i)*c5(k,i,3))+                 &
     &        bci(K)*(cc(i)*c5(k,i,2)+dc(i)*c5(k,i,4))
       ENDDO
 57    CONTINUE
 50    CONTINUE  
      do 60 k=2,k4
!
!      Increase of concentration and mixing ratio of rimed ice crystal (ice crystals are larger than clear ones)
!
        FQSUM3(K) =  0.5*                                               &
     &         (aci(k-1)*(cc(k-1)*cc1(k,1)+dc(k-1)*cc1(k,3))+           &
     &         bci(k-1)*(cc(k-1)*cc1(k,2)+dc(k-1)*cc1(k,4)))
 60   CONTINUE

!  end loop of categories
!
      segq1=0.0
      segq2=0.0
      segq3=0.0
      segq4=0.0
      segq5=0.0
      segq6=0.0
      DO K=1,K4
         dntc(K)=-ssinc1(K)
         dmtc(K)=-ssimc1(K)
         DNTCI1(K)=-ssina1(K)
         DMTCI1(K)=-ssima1(K)
         DNTS1(K)=(ssina3(K)+ssina4(K)+ina(k,1))
         DMTS1(K)=(ssima3(K)+ssima4(K)+ima(k,1))
         DNTG(K)=(ssina5(K)+ssina6(K)+ina(k,2))
         DMTG(K)=(ssima5(K)+ssima6(K)+ima(k,2))
         DNRIME(K)=DNTS1(K)
         DQRIME(K)=FQSUM1(K)+FQSUM2(K)+FQSUM3(K)
         segq1=segq1+dmtc(k)
         segq2=segq2+dqrime(k)
         segq3=segq3+fqsum1(k)
         segq4=segq4+fqsum2(k)
         segq5=segq5+fqsum3(k)
         segq6=segq6+dmtg(k)
      ENDDO
      RETURN
      END SUBROUTINE COAG40

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calculates the collisional coalesence rate between
!.. the water drops and rimed ice crystals.

      SUBROUTINE coag5 (k4,ac,bc,cc,dc,acir,bcir,ccir,dcir,dmtc,dntc,   &
     &                 dmtcir,dntcir,dmth,dnth,cc1,ccc,cccv,c5v,FQ,     &
     &                 DQRIME,FN,DNRIME)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 ac(K4),bc(K4),cc(K4),dc(K4),dntc(K4),dmtc(K4)
      REAL*8 acir(K4),bcir(K4),ccir(K4),dcir(K4),dntcir(K4),dmtcir(K4), &
     &       dmth(K4),dnth(K4),DQRIME(K4),DNRIME(K4)
      real*8 FQ(K4),FN(K4)
      REAL (KIND=R8SIZE) :: cc1(36,4),ccc(36,36,12),cccv(36,36,4),      &
     &       c5v(36,36,4)

      REAL*8 ina(36,2),ima(36,2),IMA1(36)
      REAL*8 ssinc1(36),ssimc1(36),ssina1(36),ssima1(36),ssina2(36),    &
     &       ssima2(36),ssina3(36),ssima3(36),ssima4(36),ssina5(36),    &
     &       ssima5(36),ssina6(36),ssima6(36)
      REAL*8 FNSUM1(36),FNSUM2(36),FNSUM3(36),FNSUM6(36),FNSUM7(36),    &    
     &       FQSUM1(36),FQSUM2(36),FQSUM3(36),FQSUM4(36),FQSUM5(36),    &  
     &       FQSUM6(36),FQSUM7(36)
      double precision dsegq11, dsegn11, dsegq10, dsegn10, dsegq1,      &
     &     dsegq2, dsegn1, dsegn2, dsegq3, dsegn3,                      &
     &     sfqsum1, sfqsum2, sfqsum3, sfqsum4, sfqsum5, sfqsum6,        &
     &     sfqsum8, sfnsum1, sfnsum2, sfnsum3, sfnsum6, sfnsum7, sfqsum7
      integer k, i, IBUG
!
!  calculates ssinc1,ssina1...ssina6 and ssimc1,ssima1...ssim6 for each category at a given time
!
!
!  Decrease of concentration of water drops in the k-th interval
!
      ibug=0
      do 10 k=1,k4
      ssinc1(K)=0.d0
      do i=1,k4
      ssinc1(K)=ssinc1(K)+                                              &
     &          ac(K)*(acir(i)*ccc(i,k,9)+bcir(i)*ccc(i,k,10))+         &
     &          bc(K)*(acir(i)*ccc(i,k,11)+bcir(i)*ccc(i,k,12))
      ENDDO
!
!  Decrease of mixing ratio of water drops in the k-th interval
!
      ssimc1(K)=0.d0
      do i=1,k4
      ssimc1(K)=ssimc1(K)+                                              &
     &          cc(K)*(acir(i)*ccc(i,k,9)+bcir(i)*ccc(i,k,10))+         &
     &          dc(K)*(acir(i)*ccc(i,k,11)+bcir(i)*ccc(i,k,12))
      ENDDO
 10   CONTINUE
!
!Decrease of concentration and mixing ratio of rimed ice crystal in the k-th interval
!
      do 15 k=1,k4
      ssina1(K)=0.d0
      ssima1(K)=0.d0
      IF(k.le.1) go to 2
      do i=1,k-1
      ssina1(K)=ssina1(K)+acir(K)*(ac(i)*ccc(k,i,5)+bc(i)*ccc(k,i,7))+  &
     &                    bcir(K)*(ac(i)*ccc(k,i,6)+bc(i)*ccc(k,i,8))
      ssima1(K)=ssima1(K)+(ac(i)*ccir(K)+cc(i)*acir(K))*ccc(k,i,5)+     &
     &                    (bc(i)*ccir(K)+dc(i)*acir(K))*ccc(k,i,7)+     &
     &                    (ac(i)*dcir(K)+cc(i)*bcir(K))*ccc(k,i,6)+     &
     &                    (bc(i)*dcir(K)+dc(i)*bcir(K))*ccc(k,i,8)
      ENDDO
 2    CONTINUE
      ssina2(K)=0.d0
      ssima2(K)=0.d0
      do i=k,k4
      ssina2(K)=ssina2(K)+                                              &
     &          acir(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+           &
     &          bcir(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ssima2(K)=ssima2(K)+                                              &
     &          ccir(K)*(ac(i)*ccc(k,i,9)+bc(i)*ccc(k,i,11))+           &
     &          dcir(K)*(ac(i)*ccc(k,i,10)+bc(i)*ccc(k,i,12))
      ENDDO
15    CONTINUE
!
! Increase of concentration and mixing ratio of rimed ice crystals (ice crystals are larger than water drops)
!
      do 20 k=1,k4
      ssina3(K)=0.d0
      ssima3(K)=0.d0
      IF (k.le.2) GOTO 6
      do i=1,k-2
      ssina3(K)=ssina3(K)+                                              &
     &          acir(k-1)*(ac(i)*ccc(k,i,1)+bc(i)*ccc(k,i,3))+          &
     &          bcir(k-1)*(ac(i)*ccc(k,i,2)+bc(i)*ccc(k,i,4))
      ssima3(K)=ssima3(K)+                                              &
     &          (ccir(k-1)*ac(i)+acir(k-1)*cc(i))*ccc(k,i,1)+           &
     &          (dcir(k-1)*ac(i)+bcir(k-1)*cc(i))*ccc(k,i,2)+           &
     &          (ccir(k-1)*bc(i)+acir(k-1)*dc(i))*ccc(k,i,3)+           &
     &          (dcir(k-1)*bc(i)+bcir(k-1)*dc(i))*ccc(k,i,4)
      ENDDO
 6    CONTINUE
      ssima4(K)=0.d0
      IF(k.le.1) GOTO 20
      do i=1,k-1
      ssima4(K)=ssima4(K)+                                              &
     &          acir(K)*(cc(i)*ccc(k,i,9)+dc(i)*ccc(k,i,11))+           &
     &          bcir(K)*(cc(i)*ccc(k,i,10)+dc(i)*ccc(k,i,12))
      ENDDO
 20   CONTINUE
!
! Increase of concentration and mixing ratio of hail/graupel (water drops are larger than rimed ice crystals)
!
      do 30 k=1,k4
      ssina5(K)=0.d0
      ssima5(K)=0.d0
      IF (k.le.2) GOTO 8
      do i=1,k-2
      ssina5(K)=ssina5(K)+                                              &
     &          ac(k-1)*(acir(i)*cccv(k,i,1)+bcir(i)*cccv(k,i,3))+      &
     &          bc(k-1)*(acir(i)*cccv(k,i,2)+bcir(i)*cccv(k,i,4))
      ssima5(K)=ssima5(K)+                                              &
     &          (cc(k-1)*acir(i)+ac(k-1)*ccir(i))*cccv(k,i,1)+          &
     &          (dc(k-1)*acir(i)+bc(k-1)*ccir(i))*cccv(k,i,2)+          &
     &          (cc(k-1)*bcir(i)+ac(k-1)*dcir(i))*cccv(k,i,3)+          &
     &          (dc(k-1)*bcir(i)+bc(k-1)*dcir(i))*cccv(k,i,4) 
      ENDDO
 8    CONTINUE
      ssima6(K)=0.d0
      ssina6(K)=0.d0
      IF(k.le.1) GOTO 9
      do i=1,k-1
      ssina6(K)=ssina6(K)+                                              &
     &          ac(K)*(acir(i)*c5v(k,i,1)+bcir(i)*c5v(k,i,3))+          &
     &          bc(K)*(acir(i)*c5v(k,i,2)+bcir(i)*c5v(k,i,4))
      ssima6(K)=ssima6(K)+                                              &
     &          (cc(K)*acir(i)+ac(K)*ccir(i))*c5v(k,i,1)+               &
     &          (dc(K)*acir(i)+bc(K)*ccir(i))*c5v(k,i,2)+               &
     &          (cc(K)*bcir(i)+ac(K)*dcir(i))*c5v(k,i,3)+               &
     &          (dc(K)*bcir(i)+bc(K)*dcir(i))*c5v(k,i,4)
      ENDDO
 9    CONTINUE
 30   CONTINUE
!
!  end loop of categories
!
!  calculates in(k,1),in(k,2) and im(k,1),im(k,2) for each category at a given time
!
!
!  cleaning the matrixes
      do i=1,2
        do k=1,k4
         ina(k,i)=0.d0
         ima(k,i)=0.d0
        ENDDO
      ENDDO
      DO K=1,K4
       IMA1(K) = 0.0
      ENDDO
!
!   loop of categories
!
      do  50 k=2,k4
!
!      Increase of concentration and mixing ratio of rimed ice crystals (rimed ice crystals are larger than drops)
!
      ina(k,1)=0.5d0*(acir(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+    &
     &               bcir(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4)))
      ima(k,1)=ccir(k-1)*(ac(k-1)*cc1(k,1)+bc(k-1)*cc1(k,3))+           &
     &         dcir(k-1)*(ac(k-1)*cc1(k,2)+bc(k-1)*cc1(k,4))
!
!      Increase of concentration and mixing ratio of hail/graupels (drops are larger than rimed crystals)
!
      ina(k,2)=                                                         &
     &     0.5d0*(ac(k-1)*(acir(k-1)*cc1(k,1)+bcir(k-1)*cc1(k,2))+      &
     &     bc(k-1)*(acir(k-1)*cc1(k,3)+bcir(k-1)*cc1(k,4)))
      ima(k,2)=cc(k-1)*(acir(k-1)*cc1(k,1)+bcir(k-1)*cc1(k,2))+         &
     &          dc(k-1)*(acir(k-1)*cc1(k,3)+bcir(k-1)*cc1(k,4))

 50   CONTINUE
      DO K = 1, K4
       FNSUM1(K) = 0.d0
       FNSUM2(K) = 0.d0
       FNSUM3(K) = 0.d0
       FNSUM6(K) = 0.d0
       FNSUM7(K) = 0.d0
       FQSUM1(K) = 0.d0
       FQSUM2(K) = 0.d0
       FQSUM3(K) = 0.d0
       FQSUM4(K) = 0.d0
       FQSUM5(K) = 0.d0
       FQSUM6(K) = 0.d0
       FQSUM7(K) = 0.d0
      ENDDO
      DO 100 K = 3, K4
       DO 110 I = 1, K - 2
        FNSUM1(K) = FNSUM1(K) +                                         &
     &              ACIR(K-1)*(AC(I)*CCC(K,I,1) + BC(I)*CCC(K,I,3)) +   &
     &              BCIR(K-1)*(AC(I)*CCC(K,I,2) + BC(I)*CCC(K,I,4))
        FQSUM1(K) = FQSUM1(K) +                                         &
     &              CCIR(K-1)*(AC(I)*CCC(K,I,1) + BC(I)*CCC(K,I,3)) +   &
     &              DCIR(K-1)*(AC(I)*CCC(K,I,2) + BC(I)*CCC(K,I,4))
 110   CONTINUE
 100  CONTINUE
      DO 120 K = 2, K4
       FNSUM2(K) = 0.5*(ACIR(K-1)*(AC(K-1)*CC1(K,1) + BC(K-1)*CC1(K,3))+ &
     &                  BCIR(K-1)*(AC(K-1)*CC1(K,2) + BC(K-1)*CC1(K,4)))
       FQSUM2(K) = 0.5*(CCIR(K-1)*(AC(K-1)*CC1(K,1) + BC(K-1)*CC1(K,3))+ &  
     &                  DCIR(K-1)*(AC(K-1)*CC1(K,2) + BC(K-1)*CC1(K,4)))
       FQSUM4(K)=0.5*(CC(K-1)*(ACIR(K-1)*CC1(K,1) + BCIR(K-1)*CC1(K,2))+ & 
     &                DC(K-1)*(ACIR(K-1)*CC1(K,3) + BCIR(K-1)*CC1(K,4))) 
 120  CONTINUE
      DO 130 K = 2, K4
       DO 140 I = 1, K-1
          FNSUM3(K) = FNSUM3(K) +                                       &
     &                ACIR(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +  &
     &                BCIR(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
          FQSUM3(K) = FQSUM3(K) +                                       &
     &                ACIR(K)*(CC(I)*CCC(K,I,9) + DC(I)*CCC(K,I,11)) +  &
     &                BCIR(K)*(CC(I)*CCC(K,I,10) + DC(I)*CCC(K,I,12))
          FNSUM3(K) = FNSUM3(K) -                                       &
     &                ACIR(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) -   &
     &                BCIR(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
          FQSUM3(K) = FQSUM3(K) -                                       &
     &                ACIR(K)*(CC(I)*CCC(K,I,5) + DC(I)*CCC(K,I,7)) -   &
     &                BCIR(K)*(CC(I)*CCC(K,I,6) + DC(I)*CCC(K,I,8))
 140   CONTINUE
 130  CONTINUE
      DO 150 K = 3, K4
       DO 160 I = K-2, K4
         FQSUM5(K) = FQSUM5(K) +                                        &
     &               ACIR(K-1)*(CC(I)*CCC(K,I,1) + DC(I)*CCC(K,I,3)) +  &
     &               BCIR(K-1)*(CC(I)*CCC(K,I,2) + DC(I)*CCC(K,I,4))
 160   CONTINUE
 150  CONTINUE 
      DO 170 K = 2, K4
        DO 180 I = 1, K-1
          FNSUM6(K) = FNSUM6(K) +                                       &
     &                ACIR(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) +   &
     &                BCIR(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
          FQSUM6(K) = FQSUM6(K) +                                       &
     &                CCIR(K)*(AC(I)*CCC(K,I,5) + BC(I)*CCC(K,I,7)) +   &
     &                DCIR(K)*(AC(I)*CCC(K,I,6) + BC(I)*CCC(K,I,8))
 180    CONTINUE
 170  CONTINUE
      DO 190 K =1, K4
       DO 200 I = K, K4
         FNSUM7(K) = FNSUM7(K) +                                        &
     &               ACIR(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +   &
     &               BCIR(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
         FQSUM7(K) = FQSUM7(K) +                                        &
     &               CCIR(K)*(AC(I)*CCC(K,I,9) + BC(I)*CCC(K,I,11)) +   &
     &               DCIR(K)*(AC(I)*CCC(K,I,10) + BC(I)*CCC(K,I,12))
 200   CONTINUE
 190  CONTINUE 
!
!  end loop of categories
!
      dsegq11=0.0
      dsegn11=0.0
      dsegq10=0.0
      dsegn10=0.0
      dsegq1=0.0
      dsegq2=0.0
      dsegn1=0.0
      dsegn2=0.0
      dsegq3=0.0
      dsegn3=0.0
      sfqsum1=0.0
      sfqsum2=0.0
      sfqsum3=0.0
      sfqsum4=0.0
      sfqsum5=0.0
      sfqsum6=0.0
      sfqsum7=0.0
      sfqsum8=0.0
      sfnsum1=0.0
      sfnsum2=0.0
      sfnsum3=0.0
      sfnsum6=0.0
      sfnsum7=0.0
      do k=1,k4
       dntc(K)=-ssinc1(K)
       dmtc(K)=-ssimc1(K)
       dntcir(K)=-(ssina1(K)+ssina2(K))+ssina3(K)+ina(k,1)
       dmtcir(K)=-(ssima1(K)+ssima2(K))+ssima3(K)+ssima4(K)+ima(k,1)
       
       dnth(K)=(ssina5(K)+ssina6(K)+ina(k,2))
       dmth(K)=(ssima5(K)+ssima6(K)+ima(k,2))
       
       IF (K.GT.1) THEN
         DNRIME(K) = FNSUM1(K) + FNSUM2(K) +                            &
     &    (1.0 - FN(K))*FNSUM3(K) - FN(K)*(FNSUM6(K) + FNSUM7(K))
         DQRIME(K) = FQ(K-1)*(FQSUM1(K) + FQSUM2(K)) + FQSUM3(K) +      &
     &     FQSUM4(K) + FQSUM5(K) - FQ(K)*(FQSUM6(K) + FQSUM7(K))
       ENDIF
       dsegq11=dsegq11+ssimc1(K)
       dsegn11=dsegn11+ssinc1(K)
       dsegq10=dsegq10+ssima3(K)
       dsegn10=dsegn10+ssina3(K)
       dsegq1=dsegq1+dmtcir(k)
       dsegq2=dsegq2+dmth(k)
       dsegn1=dsegn1+dntcir(k)
       dsegn2=dsegn2+dnth(k)
       sfqsum4= sfqsum4+ima1(k)
       sfqsum5= sfqsum5+dmtc(k)
       sfqsum6= sfqsum6+fqsum6(k)
       sfqsum7= sfqsum7+fqsum7(k)
       sfnsum1=sfnsum1 + fnsum1(k)
       sfnsum2=sfnsum2 + fnsum2(k)
       sfnsum3=sfnsum3 + fnsum3(k)
       sfnsum6=sfnsum6 + fnsum6(6)
       sfnsum7=sfnsum7 + fnsum7(k)
       dsegq3=dsegq3+dqrime(k)
       dsegn3=dsegn3+dnrime(k)
      ENDDO
      RETURN
      END SUBROUTINE coag5

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calculates the formation of snow flake by
!.. aggregation of  pristine ice crystals

      SUBROUTINE coag6 (k4,a,b,c,d,dmt,dnt,DMTSNOW,DNTSNOW,cc,ccc,c5)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 a(K4),b(K4),c(K4),d(K4),dmt(K4),dnt(K4),DMTSNOW(K4),       &
     &       DNTSNOW(K4)
      REAL (KIND=R8SIZE) :: cc(36,4),ccc(36,36,8),c5(36,36,4)
      REAL*8 in(36),im(36)
      REAL*8 ssin1(36),ssin2(36),ssin3(36),ssim1(36),ssim2(36),         &
     &       ssim3(36)
      INTEGER K,I
!
!  calculates ssin1...ssin3 and ssim1...ssim4 for each category at a given time
!
!
!  loop of categories
!
      do k=1,k4
      ssin1(K)=0.d0
      ssim1(K)=0.d0
      IF(k.le.2) go to 1
      do i=1,k-2
      ssin1(K)=ssin1(K)+a(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+       &
     &                  b(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
      ssim1(K)=ssim1(K)+a(k-1)*(c(i)*ccc(k,i,1)+d(i)*ccc(k,i,3))+       &
     &                  b(k-1)*(c(i)*ccc(k,i,2)+d(i)*ccc(k,i,4))+       &
     &                  c(k-1)*(a(i)*ccc(k,i,1)+b(i)*ccc(k,i,3))+       &
     &                  d(k-1)*(a(i)*ccc(k,i,2)+b(i)*ccc(k,i,4))
      ENDDO
 1    CONTINUE
      ssin3(K)=0.d0
      ssim3(K)=0.d0
      do i=1,k4
      ssin3(K)=ssin3(K)+a(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+         &
     &                  b(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
      ssim3(K)=ssim3(K)+c(K)*(a(i)*ccc(k,i,5)+b(i)*ccc(k,i,7))+         &
     &                  d(K)*(a(i)*ccc(k,i,6)+b(i)*ccc(k,i,8))
      ENDDO
      ssin2(K)=0.d0
      ssim2(K)=0.d0
      IF(k.le.1) go to 7
      do i=1,k-1
      ssin2(K)=ssin2(K)+a(K)*(a(i)*c5(k,i,1)+b(i)*c5(k,i,3))+           &
     &                  b(K)*(a(i)*c5(k,i,2)+b(i)*c5(k,i,4))
      ssim2(K)=ssim2(K)+(c(K)*a(i)+a(K)*c(i))*c5(k,i,1)+                &
     &                  (d(K)*a(i)+b(K)*c(i))*c5(k,i,2)+                &
     &                  (c(K)*b(i)+a(K)*d(i))*c5(k,i,3)+                &
     &                  (d(K)*b(i)+b(K)*d(i))*c5(k,i,4)
      ENDDO
 7    CONTINUE
      ENDDO
!
!  end loop of categories
!
!  calculates in(K)...
!
         in(1)=0.d0
         im(1)=0.d0

!  loop of categories
      do k=2,k4
      in(K)=                                                            &
     &  0.5d0*(a(k-1)*a(k-1)*cc(k,1)+2.d0*a(k-1)*b(k-1)*cc(k,2)+        &
     &  b(k-1)*b(k-1)*cc(k,4))
      im(K)=a(k-1)*c(k-1)*cc(k,1)+                                      &
     &      (a(k-1)*d(k-1)+b(k-1)*c(k-1))*cc(k,2)+                      &
     &       b(k-1)*d(k-1)*cc(k,4)
      ENDDO
!
!  end loop of categories
!
      do k=1,k4
         DNTSNOW(K)=(ssin1(K)+ssin2(K)+in(K))
         dnt(K)=-ssin3(K)
         DMTSNOW(K)=(ssim1(K)+ssim2(K)+im(K))
         dmt(K)=-ssim3(K)
      ENDDO
      RETURN
      END SUBROUTINE coag6

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. Vapor deposition activation of ice crystals
!..    jump=1, Myers' formula
!..    jump=2, Cooper's curve, as implemented in Thompson et al 2008

      SUBROUTINE DEPACT(K4,dntci0,dmtci0,nicdep,nicdepten,DT,           &
     &        P, TK, QV, RO)

      IMPLICIT NONE
      INTEGER K4
      DOUBLE PRECISION dntci0(K4),dmtci0(K4)
      REAL NICDEP,NICDEPTEN,DT
      REAL P, TK, QV, RO

      REAL NID,DCNCI, eis,ev,satsi,SSI, ews,qws,satsw,eps1
      INTEGER k, JUMP

!+---+

      JUMP = 2
      nid = 0.0
      eps1 = 1.0 + 1.E-15

!      EIS = EXP((28.2890*TK-6024.330)/(TK-7.660))
      EIS = EXP(23.33086-6111.72784/tk+0.15215*log(tk))*100.
      EV = QV*P/(0.622+QV)
      satsi=ev/eis
      ssi=satsi*100.-100.
!      EWS=EXP((23.684*TK-4947.34)/(TK-35.86))
      EWS=EXP(53.67957-6743.769/tk-4.8451*log(tk))*100.
      QWS = 0.622*EWS/P
      satsw=qv/qws

      IF (JUMP .eq. 1) THEN
        IF (SATSI .lt. 1.0) THEN
          RETURN
        ENDIF
        NID = EXP(-0.639+0.1296*SSI)*1000./RO
      ELSEIF (JUMP .eq. 2) THEN
        if (satsi.gt.1.25 .or. (satsw.gt.eps1 .and. TK.lt.268.15)) then
           NID = MIN(250.E3, 5.0*EXP(0.304*(273.15-TK))) / RO
        else
          return
        endif
      ENDIF

!     if (ipt.eq.63.and.jpt.eq.1) &
!    &print*, ' DEBUG HERE in DEPACT ', ipt,kpt,TK-273.15,P*0.01,RO,satsi,NID*0.001, NICDEP,NICDEPTEN

      DCNCI = MAX(0., NID-NICDEP)
      DNTCI0(2) = DCNCI/DT
!        xci0 is the mass of pristine ice crystals formed by deposition or condensation - freezing
      DMTCI0(2)=DCNCI*1.5d0*M(2)/DT
      NICDEPTEN = NICDEPTEN + DCNCI/DT

      RETURN
      END SUBROUTINE DEPACT

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!
!.. This subroutine calcultes the melting of the snow flakes, no
!.. shedding occurs the melt water remains on the surface of the snow
!.. Water drops are formed if the snow flakes are completly melted

!modified: mtsnowI, mtsnowi1!!!   2013Aug12
      SUBROUTINE MELTSNOW (K4,NTCIR1,MTCIR1,MTSNOWI1,DMTSNOWM1,FQ,      &
     &     DNTCIR2V,DMTCIR2V,DQSHC,AI,BI,CI,DI,ROA1,DT,                 &
     &     RHO,P,TK,QV,DIFF,KG,VISC,LD,IBUG1,KZ)

      IMPLICIT NONE
      INTEGER K4, IBUG1, KZ
      REAL*8 DNTC(K4),DMTC(K4),DNTI(K4),DMTI(K4),NTCIR1(K4),MTCIR1(K4), &
     &     AI(K4),BI(K4),CI(K4),DI(K4),MTSNOWI1(K4),DMTSNOWM1(K4),       &
     &     DNTCIR2V(K4),DMTCIR2V(K4)
      REAL*8 FQ(K4)
      REAL*8 DQSHC,MTSNOWM1   ! MTSNOWM is added by IG 04. 17. 2012.
      REAL ROA1, RHO, P, TK, QV, DT, DIFF, KG, LD, VISC

      REAL MMEAN,DMEAN,CONSTV,CONSTH,CONST,CONST1,EWS
      REAL EW,CAPAC,OMEGA,CAPAC0,EPSILON,VTSNOW,KHI,FV,FS,PKER
      REAL REYN
      REAL*8 SEG, DMDT, DMDT1
      INTEGER K
!
!      variables to calculate the snow mass dependent density
!

      EW=QV/0.622*P 
!      EWS = EXP((23.684*TK-4947.34)/(TK-35.86))
      EWS=EXP(53.67957-6743.769/tk-4.8451*log(tk))*100.
      consth=KG*(TK-T0)
      constv=LV0*DIFF*(EW/TK-EWS0/T0)/RGV
      CONST=4*PI*(CONSTH + CONSTV)/LF0
      const1 = 4*PI*LD*(EW/EWS-1.)                                      &
     &       / (LD/KG/TK*(LD/RGV/TK-1.)+RGV*TK/DIFF/EWS)
      if (ibug1.eq.1 .and. debug_flag) then
        WRITE (mp_debug,*) '     in MELTSNOW (TK,KG,LV0,DIFF,RGV,LF0,EW,consth,constv,const) ', kz,tk,KG,LV0,DIFF,RGV,LF0,ew,consth,constv,const
        CALL wrf_debug(150, mp_debug)
      endif

!'
!  calculation of the melted water fraction
!

      DO 10 K=1,K4
       DMDT=0.d0
       DMDT1=0.d0
       DMTSNOWM1(K)=DMDT 
       IF (MTSNOWI1(K).LE.0.0) GOTO 10
       IF (NTCIR1(K).LT.1d-20) THEN
         GOTO 10
       ELSE
         mmean=MTCIR1(K)/NTCIR1(K)
       ENDIF
       MTSNOWM1=max(0.0d0,MTCIR1(K)-MTSNOWI1(K))   ! added by IG 04. 17. 2012., modified 25.06.2013. SN
       IF (MMEAN.GT.M(K+1)) MMEAN=M(K+1)
       IF (MMEAN.LT.M(K)) MMEAN=M(K)

       IF (MMEAN.LE.MSNOW100) THEN
           RSNOW=RSNOW0
           ROSNOW=ROSNOW0
           DMEAN=16.28*SQRT(MMEAN)
       ENDIF
       IF (MMEAN.GE.MSNOW500) THEN
           RSNOW=RSNOW1
           DMEAN=SQRT(6.*MMEAN/PI/0.17)
           ROSNOW=0.17/DMEAN
           if (rosnow .lt. 20.0) rosnow=20.0
           DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333
       ENDIF
       IF (MMEAN.GT.MSNOW100.AND.MMEAN.LT.MSNOW500) THEN
           A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
           B1=RSNOW1-A1*ALOG10(MSNOW500)
           A2=(ROSNOW1-ROSNOW0)/ALOG10(MSNOW500/MSNOW100)
           B2=ROSNOW1-A2*ALOG10(MSNOW500)
           RSNOW=A1*DLOG10(DBLE(MMEAN))+B1
           ROSNOW=A2*DLOG10(DBLE(MMEAN))+B2
           DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333
        ENDIF
        RSNOW=FQ(K) + (1-FQ(K))*RSNOW
        ROSNOW = FQ(K)*1000 + (1-FQ(K))*ROSNOW 
        DMEAN=(6.0*MMEAN/PI/RSNOW/ROSNOW)**0.33333333 
        IF (RSNOW.GT.0.99d0) THEN
         CAPAC0=0.5d0
         OMEGA=PI*DMEAN*DMEAN
        ELSE
         EPSILON=DSQRT(1.d0-RSNOW*RSNOW)
         CAPAC0=EPSILON/2.d0/ASIN(EPSILON)
         IF (CAPAC0.gt.0.5d0) CAPAC0=0.5d0
         OMEGA=0.5*PI*DMEAN*DMEAN*(1.d0+                                &
     &    RSNOW*RSNOW*DLOG((1.d0+EPSILON)/(1.d0-EPSILON))/2.d0/EPSILON)
        ENDIF
        CAPAC = FQ(K)*CAPAC0 + (1 - FQ(K))*0.8*CAPAC0
        if (dmean .lt. 80.7E-6) then
           vtsnow=2757.d0*dmean
        elseif (dmean .lt. 7.E-3) then
           vtsnow=40.0*dmean**0.55 * exp(-100.0*dmean)
        else
           vtsnow=1.32
        endif
!-GT    IF (MMEAN.LT.MSNOWTV) THEN
!-GT      VTSNOW=1250.d0*DMEAN*SQRT(1.2/RHO)
!-GT    ELSE
!-GT      VTSNOW=4.84d0*DMEAN**0.25d0*SQRT(1.2/RHO)
!-GT    ENDIF
        FS=0.01195*exp(4.411*FQ(K))     ! this equation based on the lab. observation of Mitra et. al, 1990
        VTSNOW=VTSNOW*SQRT(1.2/RHO)
        VTSNOW=FS*VTC(K)+(1 - FS)*VTSNOW    
        PKER=DMEAN*PI
        REYN=OMEGA/PKER*VTSNOW*RHO/VISC
        KHI=NSCH1*SQRT(REYN)
        IF (KHI.LT.1.d0) THEN
         FV=1.d0+0.14d0*KHI*KHI
        ELSE
         FV=0.86d0+0.28d0*KHI
        ENDIF
        DNTCIR2V(K)=DMIN1(DNTCIR2V(K),NTCIR1(K))
        SEG=CAPAC*FV*CONST*DMEAN
        if (debug_flag .and. ibug1.eq.1 .and. seg*NTCIR1(K).ge.MTSNOWI1(K)/DT) then
           write(*,*) '    able to MELT ALL SNOW in this bin ', K
        elseif (debug_flag .and. ibug1.eq.1) then
           WRITE (mp_debug,*) '  partially MELTING SNOW (bin, percent) ', K, SEG*NTCIR1(K)*DT/MTSNOWI1(K)*100., '  falling ', VTSNOW, ' m/s,  FV,CAPAC,DMEAN = ', FV, CAPAC, DMEAN
           CALL wrf_debug(150, mp_debug)
        endif
!        DMDT=SEG*(NTCIR1(K)-DNTCIR2V(K))    ! melting rate of the snow flakes did not collected any drop
! this simple equation is used for dmdt  because  the mass - size relation is given by a complicated function
         DMDT = SEG*NTCIR1(K)
! this correction is necessary if the temperature is over 0C, but due to evaporation no melting but refreezing occur 
         IF(DMDT*DT+MTSNOWM1.LT.0.0) THEN 
           DMDT=-MTSNOWM1/DT                                       ! 
           DQSHC = DQSHC - CAPAC*FV*CONST1*DMEAN*NTCIR1(K)
         ELSE
           DQSHC = DQSHC + 4*PI*CAPAC*FV*CONSTH*DMEAN*NTCIR1(K)      ! modositva 2011.11.10
!           DQSHC = DQSHC + 4*PI*CAPAC*FV*CONST*DMEAN*NTCIR1(K)      ! xue test new heat transfer
         ENDIF
!        DMDT1=DMDT*DNTCIR2V(K)+CW*(TK-T0)*DMTCIR2V(K) 
! melting rate of the snow flakes enhanced by the heat transfer from the collected drops
        DMDT1=CW*(TK-T0)*DMTCIR2V(K)/LF0 ! fontos modositas 2011. 02. 25.
!        DMDT=DMDT     ! + DMDT1
! 04. 17. 2012 modified by IG, the effect of colleted water is taken into consideration
         DMDT=DMDT  + DMDT1
!        IF (DMDT1*DT.GT.MTSNOWI1(K)*DNTCIR2V(K)/NTCIR1(K)) THEN
!          DMDT1 = MTSNOWI1(K)*DNTCIR2V(K)/NTCIR1(K)/DT
!        ENDIF
!        IF (DMDT*DT.GT.MTSNOWI1(K)*(1.0-DNTCIR2V(K)/NTCIR1(K))) THEN
!          DMDT = MTSNOWI1(K)*(1.0-DNTCIR2V(K)/NTCIR1(K))/DT
!        ENDIF
        IF (DMDT*DT.GT.MTSNOWI1(K)) THEN
          DMDT = MTSNOWI1(K)/DT
        ENDIF
        DMTSNOWM1(K)=DMDT 
10    CONTINUE

      RETURN
      END SUBROUTINE MELTSNOW

!----+-----------------------------------------------------------------+
!----+-----------------------------------------------------------------+
!
!.. This subroutine calcultes the melting of the graupel particles, no
!.. shedding occurs the melt water remains on the surface of the
!.. graupel particles.  Water drops are formed if the graupel particles
!.. are completly melted.

      SUBROUTINE MELTGRA (K4,NTGRA1,MTGRA1,MTGRAI1,DMTGRAM1,FQ,DNTGRA3V,  &
     &    DMTGRA3V,DQGRHC,AI,BI,CI,DI,DT,RHOA,P,TK,QV,DIFF,KG,VISC,LD,ibug)

      IMPLICIT NONE
      INTEGER K4, ibug
      REAL*8 NTGRA1(K4),MTGRA1(K4),MTGRAI1(K4),DMTGRAM1(K4),              &
     &       AI(K4),BI(K4),CI(K4),DI(K4),DNTGRA3V(K4),DMTGRA3V(K4) 
      REAL*8 FQ(K4)
      REAL RHOA, P, TK, QV, DT, DIFF, KG, VISC, LD

      REAL MMEAN,DMEAN,EW,EWS,CONSTV,CONSTH,CONST,RHOGRA,VGRA,REYGRA,FV,&
           FH,const1
      REAL*8 SEG,SEG0,DMDTV,DMDT,DMDT1,DMDT1V  !modified 05.05.2013. by SN
      REAL*8 seg0v, DQGRHC,MTGRAM1    ! MTGRAM is added by IG 04. 17. 2012.
      INTEGER K,KMAX0

!----+
      if (ibug.eq.1) then
       write(98,*) 'in meltgra'
       write(98,*) 'k,ntgra,mtgra,mtgrai'
       do k =1,k4
        write(98,*) k,ntgra1(k),mtgra1(k),mtgrai1(k)
       enddo
      endif
      EW=QV/0.622*P
      EWS=EXP(53.67957-6743.769/tk-4.8451*log(tk))*100.
      consth=KG*(TK-T0)
      constv=LV0*DIFF*(EW/TK-EWS0/T0)/RGV
! xue change 2pi to 4pi
      CONST=4*PI*(CONSTH + CONSTV)/LF0
      const1 = 4*PI*LD*(EW/EWS-1.)                                      &
     &       / (LD/KG/TK*(LD/RGV/TK-1.)+RGV*TK/DIFF/EWS)
!
!  calculation of the melted water fraction
!
      DO 10 K=1,K4
       DMDT=0.d0
       DMDT1=0.d0
       IF (MTGRAI1(K).LE. 0.0) GOTO 10
       IF (NTGRA1(K).LT.1d-20) THEN
         GOTO 10
       ELSE
         mmean=MTGRA1(K)/NTGRA1(K)
       ENDIF
       MTGRAM1=MAX(0.0D0, MTGRA1(K)-MTGRAI1(K))
       IF (MMEAN.GT.M(K+1)) MMEAN=M(K+1)
       IF (MMEAN.LT.M(K)) MMEAN=M(K)
       RHOGRA = FQ(K)*RHOW + (1-FQ(K))*RHOI
       SEG0=(6.0/PI/RHOGRA)**0.33333
!       DMEAN=(6.0*MMEAN/PI/RHOGRA)**0.33333333
       DMEAN =SEG0*MMEAN**0.333333 
       VGRA=FQ(K)*VTC(K)+(1 - FQ(K))*VTGRA(K)      
       REYGRA=DMEAN*VGRA*RHOA/VISC
       FV=0.78+0.308*NSCH1*SQRT(REYGRA)       
       FH = FV      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       DNTGRA3V(K)=DMIN1(DNTGRA3V(K),NTGRA1(K))
!       SEG=0.5*FV*CONST*DMEAN
       SEG=0.5*FV*CONST*SEG0
!       DMDTV=0.5*FV*CONST*DMEAN*NTGRA1(K)       ! melting rate of the graupel particles did not collected any water drops
       DMDT=SEG*(0.75*AI(K)*(M(K+1)**1.33333-M(K)**1.33333)+3./7.*BI(K)* &
     &      (M(K+1)**2.33333-M(K)**2.33333))
! added by IG, if the temperature is over 0C, but due to evaporation no melting occur
! xue why the refreezing of snow is considered but not considered for graupel?
       IF(DMDT*DT+MTGRAM1.LT.0.0) THEN
        DMDT=-MTGRAM1/DT
        DQGRHC = DQGRHC - 0.5*FV*CONST1*SEG0*                       &  ! modositva 2011.11.10.
     &         (0.75*AI(K)*(M(K+1)**1.33333-M(K)**1.33333)+3./7.*BI(K)* &
     &         (M(K+1)**2.33333-M(K)**2.33333))
       ELSE
        DQGRHC = DQGRHC + 4*PI*0.5*FV*CONSTH*SEG0*                       &  ! modositva 2011.11.10.
     &         (0.75*AI(K)*(M(K+1)**1.33333-M(K)**1.33333)+3./7.*BI(K)* &
     &         (M(K+1)**2.33333-M(K)**2.33333))
!        DQGRHC = DQGRHC + 4*PI*0.5*FV*CONST*SEG0*                       &  ! xue test new heat transfer
!     &         (0.75*AI(K)*(M(K+1)**1.33333-M(K)**1.33333)+3./7.*BI(K)* &
!     &         (M(K+1)**2.33333-M(K)**2.33333))
       ENDIF
       DMDTV=SEG*DMEAN*(NTGRA1(K)-DNTGRA3V(K))/seg0
!       DMDT1=DMDT*DNTGRA3V(K)+CW*(TK-T0)*DMTGRA3V(K)
!
!    melting rate of  graupel particles enhanced by the heat transport from the collected water drops
!
       DMDT1=CW*(TK-T0)*DMTGRA3V(K)/LF0    ! fontos modositas 2011. 02. 25.-en
       DMDT1V=SEG*DMEAN*DNTGRA3V(K)/LF0 + DMDT1
!       DMDT=DMDT   !  + DMDT1
! 04. 17. 2012 modified by IG, the effect of colleted water is taken into consideration
       DMDT=DMDT + DMDT1  
       DMDT=MAX(0.0D0,DMDT)
!       DMDT1=AMAX1(0.0,DMDT1)
       IF (DMDT1V*DT .GT. MTGRAI1(K)*DNTGRA3V(K)/NTGRA1(K)) THEN
          DMDT1V = MTGRAI1(K)*DNTGRA3V(K)/NTGRA1(K)/DT
       ENDIF
       IF (DMDTV*DT.GT.MTGRAI1(K)*(1.0-DNTGRA3V(K)/NTGRA1(K)))THEN
          DMDTV = MTGRAI1(K)*(1.0-DNTGRA3V(K)/NTGRA1(K))/DT
       ENDIF
        IF (DMDT*DT.GT.MTGRAI1(K)) THEN
          DMDT = MTGRAI1(K)/DT
        ENDIF

       if (ibug.eq.1) then
         write(99,*) 'k,dmdt,dmdt1',k,dmdt,dmdt1
         write(99,*) '  dmdtv,dmdt1v',dmdtv,dmdt1v
         write(99,*) 'dntgra3v,dmtgra3v,ntgra,vgra',dntgra3v(k),        &
     &               dmtgra3v(k),ntgra1(k),vgra
       endif
 
      DMTGRAM1(K)=DMDT
 10   CONTINUE
      RETURN
      END SUBROUTINE MELTGRA

!----+-----------------------------------------------------------------+
!----+-----------------------------------------------------------------+
!
!.. Calculates the condensation or evaporation of the droplets

      SUBROUTINE COND(K4,DSNTC,DSMTC,DSNTCI,DSMTCI,DSNTSNOW,DSMTSNOW,   &
     &    DTIME,ERRORQ,SCOND,ERRORQCI,SDEP,                             &
!     &    NTC1,MTC1,NTCI1,MTCI1,NTCIR1,MTCIR1,                          &
     &    TK1,QV1,CCN1,DNID1,TENQV,TENTEMP,KTOP,ibug0,                  & !Interim updated T1,qv1,ccn1 after advection; T11,qv11 before advection
!     &    TK1,QV1,TK11,QV11,CCN1,DNID1,TENQV,TENTEMP,KTOP,ibug0,          & ! Interim updated T1,qv1,ccn1 after advection; T11,qv11 before advection
     &    times,kz,errseg0,P,TK,QV,RHOA,LV,LD,LF,KG,VISC,DIFF)            ! Non-updated values of T,qv

      IMPLICIT NONE
      INTEGER K4, kz, ibug0, ktop
!      REAL*8 TK1,QV1,TK11,QV11,DMTTW,DMTTI,DSNTC,DSMTC,DSNTCI,DSMTCI,DSNTSNOW,DSMTSNOW
      REAL*8 TK1,QV1,DMTTW,DMTTI,DSNTC,DSMTC,DSNTCI,DSMTCI,DSNTSNOW,DSMTSNOW
      REAL DTIME,ERRORQ,SCOND,ERRORQCI,SDEP,TIMES,CCN1,DNID1,TENQV,    &
     &      TENTEMP
!      REAL*8 NTC1(36),MTC1(36),NTCI1(36),MTCI1(36),NTCIR1(36),MTCIR1(36), &
!     &       NTC0(36),MTC0(36),NTCI0(36),MTCI0(36),NTCIR0(36),MTCIR0(36)
!      REAL*8 ERRORWN,ERRORWQ,ERRORCIN,ERRORCIQ,ERRORSNOWN,ERRORSNOWQ
      REAL*8 errseg0
      REAL P,TK,QV,RHOA,RHO1,LV,LF,LD,KG,VISC,DIFF

!----+  Local variables

      REAL DNID2,DNID3,errdep,errdep1
      REAL*8 FQSM(36),FN(36),FQ(36)
      REAL SSUMNC4,SSUMMC4,SSUMNCI4,SSUMMCI4,SSUMNSNOW4,SSUMMSNOW4
      REAL*8 SSUMNC,SSUMMC,SSUMNCI,SSUMMCI,SSUMNSNOW,SSUMMSNOW,           &
             SSUM2,SSUM1,SSUMCI2,SSUMSNOW2,                             &    
     &       DELTANC,DELTAMC,DELTANCI,DELTAMCI,DELTANSNOW,DELTAMSNOW
      REAL*8 TAU(40),TAU1(40),TAUCI(40),TAUSN(40),TAUW,TAUI,            & 
     &       Y(40),AC(36),BC(36),CC(36),DC(36),KSZI,KSZI2,              &   
     &       MMEAN,MMEAN1,M2,CWATER,CICE,ADVW,ADVI,AWPT,AIPT,BWPT,BIPT, &
     &       PPI,PPW,RRI,RRW,QRI,QRW,SEG,SEG1,SEG2,SEGI,SEGW,SEGW0,SEGW1,SS11,      &
     &       SATI,SATS,SATW,SATNEW,SATNEWI,DTIMEV,DTIMEW,DTIMEI,STIME
      REAL EWS,EIS,QWS1,QIS1,EV,CPT1,CONST1,CONSTR,              &
     &     CONST1I,CONSTLI,CONST2,CONST3,CONST4,CONST44,CONST44I,CPTI1, &
     &     CPTI2,CORR,CAPAC,EPSILON,V,VCI,VSNOW,REYCI,FALFA,FV,FVI,FVS, &
     &     KHI,LSTAR,LSTARI,OMEGA,PKER,REYSNOW,RMEAN,REY,RSTAR,SEXP,QRAD, &
           RGVT
      PARAMETER (CONST3=0.062,CPT1=0.7796,CPTI1=12.5636)
!
!    CONST3 : constant for diff. growth of water drops, CONST3= (3/(4*pi*rhow))**0.33333
!    CPT1 : CPT1 = 4*pi*CONST3
!    CPTI1 : diff growth of pristine ice, CPTI1 = 4*pi
!
      REAL HCI,RAXI,RHOSNOW,RHOSNOW0,RHOSNOW1,RSNOW,CDMEAN,DMEAN,FS !A1,A2,B1,B2,FS
!      PARAMETER( MSNOW100=3.773e-11,MSNOW500=2.22529e-8,                         &
!     &       MSNOWTV=3.2906e-8,RHOSNOW0=900.,RHOSNOW1=340.,RSNOW0=0.08,          &
!     &       RSNOW1=1.0)
      PARAMETER(RHOSNOW0=900.,RHOSNOW1=340)
!
!      MSNOW100:  mass of snowflakes at diameter of 100 um
!      MSNOW500:  mass of snowflakes at diameter of 500 um
!      MSNOWTV:   mass where the formula for terminal velocity is changed
!      RHOSNOW0:  density of snow flake at mass m100
!      RHOSNOW1:  density of snow flake at mass m500
!      RSNOW0:    axis ratio of snow flake at mass of m100 (near hexagonal plate)
!      RSNOW1:    axis ratio of snow flake at mass of m500 (near sphere)
!
      REAL QMAX,BETA,RSEG1
      REAL*8 EPS1,EPS2
      PARAMETER (EPS1=1d-10,EPS2=1d-20)
!      INTEGER IX,KZ,K4,K,KTOP,IBUG0,ISTEP
      INTEGER IX,K,ISTEP

      QMAX=KTOP*1.18
      BETA=0.28d6
!      RSEG1=-.15*TK11**4*5.67d-8
      RSEG1=-.15*TK1**4*5.67d-8
!
      KSZI=0.968130959d0           !   0.950d0     0.984065478d0       ! p=2 and delta=1/3
      KSZI2=0.9682458368d0            ! 0.984122918d0                   ! p=2  and delta=0.5
      DTIMEV=DTIME
      STIME = 0.0
!      TC=TK-T0
      RHO1 = SQRT(1.2/RHOA)        ! correction for terminal velocities


!----+
!
!     start of calculation of dmttw and dmtti
!     if during the time step dtime the supersaturation would change sign
!     the calculations below are repeted



!      ibug0 = 0
!      TC=TK-T0
!      if (TC .lt. 0.) then
!         LD = LF + LV
!      else
!         LD = LV
!      endif
      ISTEP = 0
1     ISTEP = ISTEP + 1
!      EWS=DEXP((23.684d0*TK11-4947.34d0)/(TK11-35.86d0))
!      EIS=DEXP((28.289d0*TK11-6024.33d0)/(TK11-7.66d0))
!      IF (TK11.GT.T0) THEN
!      EWS=DEXP((23.684d0*TK1-4947.34d0)/(TK1-35.86d0))
!      RHOSNOW0=ROSNOW0
!      RHOSNOW1=ROSNOW1
      EWS=EXP(53.67957-6743.769/tk1-4.8451*log(tk1))*100.
!      EIS=DEXP((28.289d0*TK1-6024.33d0)/(TK1-7.66d0))
      EIS = EXP(23.33086-6111.72784/tk1+0.15215*log(tk1))*100.
      IF (TK1.GT.T0) THEN
        EIS=610.24d0
      ENDIF
      QWS1 = 0.622*EWS/P
      QIS1 = 0.622*EIS/P
!      SATW = QV11 - QWS1
!      SATI = QV11 - QIS1
!      EV = QV11*P/0.622
!      SATS = QV11/QWS1
!      RGVT = RGV*TK11
!      CONST1 = LV/(TK11*KG)*(LV/RGVT-1.0)
      SATW = QV1 - QWS1
      SATI = QV1 - QIS1
      EV = QV1*P/0.622
      SATS = QV1/QWS1
      RGVT = RGV*TK1
      CONST1 = LV/(TK1*KG)*(LV/RGVT-1.0)
      CONSTR = CONST1/LV
!      CONST1I = LD/(TK11*KG)*(LD/RGVT-1.0)
      CONST1I = LD/(TK1*KG)*(LD/RGVT-1.0)
      CONST2 = 0.5*DIFF*SQRT(2.0*PI/RGVT)
      CONST44 = RGVT/DIFF/EWS
      CONST44I = RGVT/DIFF/EIS
      LSTAR = 2.*CONST2/(2.*ALFA/(2.0-ALFA))
      LSTARI = 2.*CONST2/(2.*ALFAI/(2.0-ALFAI))
      SS11   = 0.622/(RGVT*TK1*CP*P)
      AWPT = 1.d0 + SS11*LV*LV*EWS
      AIPT = 1.d0 + SS11*LV*LD*EIS
      BWPT = 1.d0 + SS11*LD*LV*EWS
      BIPT = 1.d0 + SS11*LD*LD*EIS
!      CPTI2 = CPTI1/QIS1/(RGVT/DIFF/EIS + LD/(TK11*KG)*(LD/RGVT-1.0))       ! for snow flakes supposing D ~ M**0.3333
      CPTI2 = CPTI1/QIS1/(RGVT/DIFF/EIS + LD/(TK1*KG)*(LD/RGVT-1.0))       ! for snow flakes supposing D ~ M**0.3333
!     restart of the calculation if the saturation was reached during a time step
       
      ssumnc=0.d0
      ssummc=0.d0
      ssumnci=0.d0
      ssummci=0.d0
      SSUMNSNOW=0.d0
      SSUMMSNOW=0.d0
      do k=1,k4
       ssumnc=ssumnc+ntc(K)
       ssummc=ssummc+mtc(K)
       SSUMNSNOW = SSUMNSNOW + ntcir(K)
       SSUMMSNOW = SSUMMSNOW + mtcir(K)
       ssumnci=ssumnci+ntci(K)
       ssummci=ssummci+mtci(K)
!        NTC0(K)=NTC(K)
!        MTC0(K)=MTC(K)
!        NTCI0(K)=NTCI(K)
!        MTCI0(K)=MTCI(K)
!        NTCIR0(K)=NTCIR(K)
!        MTCIR0(K)=MTCIR(K)
      ENDDO
      ssummc4=ssummc
      ssummci4=ssummci
      SSUMMSNOW4 = SSUMMSNOW
      ssumnc4=ssumnc
      ssumnci4=ssumnci
      SSUMNSNOW4=SSUMNSNOW
      SSUM2 =0.d0
      SSUM1 = 0.d0
      SSUMCI2 = 0.d0
      SSUMSNOW2 = 0.d0
      DO 100 K =1,K4
       TAUCI(K)=0.0
       TAUSN(K) =0.d0
       TAU(K) =0.d0
       TAU1(K) =0.d0
       FQSM(K) = 0.0
       IF (SSUMNCI.LT.EPS1) GOTO 110
! calculation of the tauv parameter for the diffusional growth of hexagonal plate
!       IF (NTCI(K).GT.EPS1) THEN
!        MMEAN =MTCI(K)/NTCI(K)
!       ELSE
!        MMEAN=1.5*M(K)
!       ENDIF
!       IF (MMEAN.LT.M(K)) MMEAN = M(K)
!       IF (MMEAN.GT.M(K+1)) MMEAN = M(K+1)
       IF (NTCI(K).GT.EPS) THEN
        MMEAN1 =MTCI(K)/NTCI(K) 
       ELSE 
        MMEAN1=1.5*M(K)
       ENDIF 
       IF (MMEAN1.LT.0.d0) MMEAN1 = 0.d0
       MMEAN=M(K)

       If (MMEAN.LT.MV) THEN
        CORR = 2.0/(4*MMEAN)**0.166667/(PI*RHOI)**0.33333
        DMEAN = (4*MMEAN/PI/RHOI)**0.333333
        HCI = DMEAN
       ELSE
        CORR = 16.28
        DMEAN = CORR*DSQRT(MMEAN)
        HCI =HCI0
       ENDIF
       RAXI = HCI/DMEAN
       IF (RAXI.GT.0.99) THEN
        CAPAC=0.5
       ELSE
        EPSILON = SQRT(1.- RAXI*RAXI)
        CAPAC = EPSILON/2./ASIN(EPSILON)
        CAPAC = 3.*CAPAC  ! increase the prisine ice capacity due to its irregular shape
       ENDIF
       VCI =304.*DMEAN*RHO1
       REYCI = (0.5*DMEAN + HCI)*VCI*RHOA/VISC
       FALFA = 1.0
       IF (DMEAN.LT.1d-4) THEN
        FALFA = DMEAN/(DMEAN +2*LSTARI)
       ENDIF
       CONST4 = CONST44I/FALFA
       KHI = NSCH1*SQRT(REYCI)
       IF (KHI.LT.1.0) THEN
        FV = 1.0 + 0.14*KHI*KHI
       ELSE
        FV = 0.86 + 0.28*KHI
       ENDIF
       TAUCI(K) = CPTI1*CORR*CAPAC/QIS1/(CONST4 + CONST1I)*FV
!       SSUMCI2 = SSUMCI2 + TAUCI(K)*MMEAN**0.5d0*NTCI(K)
       SSUMCI2 = SSUMCI2 + TAUCI(K)*MMEAN1**0.5d0*NTCI(K)
       if (ibug0.eq.1) then
        write(95,*) 'k,ssumci2(k)',k,                           &
!                             TAUCI(K)*MMEAN**0.5d0*NTCI(K)
                             TAUCI(K)*MMEAN1**0.5d0*NTCI(K)
       endif
!     calculation of the variable TAUV for the diffusional growth of snowflakes
110    CONTINUE
!       TAUSN(K) =0.d0
!       FQSM(K) = 0.0
       IF (SSUMNSNOW.LT.EPS1) GOTO 120
       IF (NTCIR(K).GT.EPS1) THEN
        MMEAN1 =MTCIR(K)/NTCIR(K)
       ELSE
        MMEAN1 =1.5d0*M(K)
       ENDIF
       IF (MMEAN1.LT.0.d0) MMEAN1 = 0.d0       
       MMEAN = M(K)
       IF(MTCIR(K).GT.0.0) THEN
          FQSM(K) = MAX(0.0d0, MIN(MTSNOWM(K)/MTCIR(K), 1.0d0))
       ENDIF
       IF (MMEAN.LE.MSNOW100) THEN
          RSNOW=RSNOW0
          RHOSNOW=RHOSNOW0
          DMEAN=16.28*DSQRT(MMEAN)
          CDMEAN=(6.0/PI/RSNOW/RHOSNOW)**0.33333333
       ENDIF
       IF (MMEAN.GE.MSNOW500) THEN
          RSNOW=RSNOW1
          DMEAN=SQRT(6*MMEAN/PI/0.17)
          RHOSNOW=0.17/DMEAN
          CDMEAN=(6.0*DMEAN/PI/0.17)**0.3333333
       ENDIF
       IF (MMEAN.GT.MSNOW100.AND.MMEAN.LT.MSNOW500) THEN
          A1=(RSNOW1-RSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B1=RSNOW1-A1*ALOG10(MSNOW500)
          A2=(RHOSNOW1-RHOSNOW0)/ALOG10(MSNOW500/MSNOW100)
          B2=RHOSNOW1-A2*ALOG10(MSNOW500)
          RSNOW=A1*DLOG10(MMEAN)+B1
          RHOSNOW=A2*DLOG10(MMEAN)+B2
          DMEAN=(6.0*MMEAN/PI/RSNOW/RHOSNOW)**0.3333333
          CDMEAN=(6.0/PI/RSNOW/RHOSNOW)**0.33333333
       ENDIF
       IF (TK .GT. T0) THEN
         RSNOW = FQSM(K) + (1.0 - FQSM(K))*RSNOW
         RHOSNOW = FQSM(K)*1000. + (1.0 - FQSM(K))*RHOSNOW
         DMEAN = (6.0*MMEAN/PI/RSNOW/RHOSNOW)**0.33333
       ENDIF
       IF (RSNOW.GT.0.999) THEN
         CAPAC=0.5d0
         OMEGA=PI*DMEAN*DMEAN
       ELSE
        EPSILON=DSQRT(1.d0-RSNOW*RSNOW)
        CAPAC=EPSILON/2.d0/ASIN(EPSILON)
        OMEGA=0.5*PI*DMEAN*DMEAN*(1.d0+                        &
             RSNOW*RSNOW*DLOG((1.d0+EPSILON)/(1.d0-EPSILON))/ &
             2.d0/EPSILON)
       ENDIF
       IF (TK .GT. T0) THEN
        CAPAC = FQSM(K)*CAPAC + (1 - FQSM(K))*0.8*CAPAC
       ELSE
        CAPAC = 3.*CAPAC !10.*CAPAC         !increase of capacity due to the irregular surface of dry snow flakes
       ENDIF
       IF (MMEAN.LT.MSNOWTV) THEN
        VSNOW=1250.d0*DMEAN*RHO1
       ELSE
        VSNOW=4.84d0*DMEAN**0.25d0*RHO1
       ENDIF
       IF (TK.GT.T0) THEN
        FS = 0.01195*EXP(4.411*FQSM(K))
        VSNOW = FS*VTC(K)*RHO1 + (1.0 - FS)*VSNOW
       ENDIF
       PKER=DMEAN*PI
       REYSNOW = OMEGA/PKER*VSNOW*RHOA/VISC
       KHI = NSCH1*SQRT(REYSNOW)
       IF (KHI.LT.1.d0) THEN
        FV = 1.0 + 0.14*KHI*KHI
       ELSE
        FV = 0.86 + 0.28*KHI
       ENDIF
!       V = VTC(K)*RHO1
!       IF (KHI.LT.1.4) THEN
!        FV = 1.0 + 0.108*KHI*KHI
!       ELSE
!        FV = 0.78 + 0.308*KHI
!       ENDIF
       FVS =       FV           !  FQSM(K)*FV + (1.0 - FQSM(K))*FVS
       TAUSN(K) = CDMEAN*CPTI2*CAPAC*FVS
       SSUMSNOW2 = SSUMSNOW2 + TAUSN(K)*MMEAN1**0.33333*NTCIR(K)
       if (ibug0.eq.1) then
        write(95,*) 'k,ssumsnow2(k)',k,                               &
                              TAUSN(K)*MMEAN1**0.33333*NTCIR(K)
        write(95,*)'cdmean,cpti2,capac,fvs',cdmean,cpti2,capac,fvs
        write(95,*)'mmean1,ntsnow', mmean1,ntcir(k)
        write(95,*)'fv,reycir,fqsm',fv,reysnow,fqsm(k)
        write(95,*) 'vtc,vsnow',vtc(k),vsnow
        write(95,*) 'rsnow,rhosnow',rsnow,rhosnow
       endif
      
!   calculation of the TAUV variable for the diffusional growth of the water drops
120    CONTINUE
!       TAU(K) =0.d0
!       TAU1(K) =0.d0
       IF (SSUMNC.LT.EPS1) GOTO 100
       IF (NTC(K).GT.EPS1) THEN
        MMEAN = MTC(K)/NTC(K)
       ELSE
        MMEAN = 1.5*M(K)
       ENDIF
       IF (MMEAN.LT.M(K)) MMEAN = M(K)
       IF (MMEAN.GT.M(K+1)) MMEAN = M(K+1)
       RMEAN = CONST3*MMEAN**0.33333
       V=VTC(K)*RHO1
       REY=2.d0*RMEAN*V*RHOA/VISC
       FALFA=1.0
       IF (RMEAN.LT.2.0d-5) THEN
        RSTAR=RMEAN + CONST2
        FALFA = RSTAR/(RSTAR + LSTAR)
       ENDIF
!       falfa=1.d0
       CONST4=CONST44/FALFA
       KHI=NSCH1*SQRT(REY)
       IF (KHI.LE.1.4d0) THEN
        FV=1.0+0.108*KHI*KHI
       ELSE
        FV=0.780+0.308d0*KHI
       ENDIF
!  These terms involve the radiative cooling
       SEXP=BETA*RMEAN
       IF (SEXP.LT.10.0) THEN
        QRAD=RSEG1*QMAX*(1.0-EXP(-SEXP))
       ELSE
        QRAD=RSEG1*QMAX
       ENDIF
! xue question: should FV be applied to TAU1 or TAU?
       TAU1(K) = CPT1*CONSTR*RMEAN*QRAD/(CONST4+CONST1)*FV ! xue modified
!       SSUM1=SSUM1 + TAU1(K)*MMEAN*0.33333*NTC(K)
       SSUM1=SSUM1 + TAU1(K)*MMEAN**0.33333*NTC(K)
       TAU(K) = CPT1/QWS1/(CONST4 + CONST1)*FV ! xue modified
       SSUM2 = SSUM2 + TAU(K)*MMEAN**0.33333*NTC(K)
       if (ibug0.eq.1) then
        write(95,*) 'k,rmean,mmean,qrad,const4,const1,tau',k,rmean,mmean,  &
                        qrad,const4,const1,tau(k)
       endif
100   CONTINUE
      RRW = KSZI*AWPT*SSUM2
      RRI = BIPT*(KSZI2*SSUMCI2 + KSZI*SSUMSNOW2)
      PPW = KSZI*AIPT*SSUM2
      PPI = BWPT*(KSZI2*SSUMCI2 + KSZI*SSUMSNOW2)
      QRW = AWPT*KSZI*SSUM1
      QRI = BWPT*KSZI*SSUM1
      M2= RRW + RRI
      if (ibug0.eq.1) then
       write(95,*) 'ssum2,ssum1,ssumci2,ssumsnow2'
       write(95,*) ssum2,ssum1,ssumci2,ssumsnow2
       write(95,*)'tenqv,tentemp',tenqv,tentemp
      endif
!      IF ((SSUMMC + SSUMMCI + SSUMMSNOW).LT.EPS) THEN
      IF ((SSUMNC + SSUMNCI + SSUMNSNOW).LT.EPS) THEN
       DO K = 1, K4
        NTC(K) = 0.d0
        MTC(K) = 0.d0
        NTCI(K)= 0.d0
        MTCI(K)= 0.d0
        NTCIR(K) = 0.d0
        MTCIR(K) = 0.d0
        NTSNOWR(K) = 0.d0
        MTSNOWR(K) = 0.d0
        MTSNOWM(K) = 0.d0
       ENDDO
!       QV1 = QV1 + SSUMMC + SSUMMCI + SSUMMSNOW
       QV1 = QV1 + TENQV*DTIMEV + SSUMMC + SSUMMCI + SSUMMSNOW
!       TK1=TK1+TENTEMP*DTIMEV+(LV*SSUMMC+LD*(SSUMMCI+SSUMMSNOW))/CP
       TK1=TK1+TENTEMP*DTIMEV-(LV*SSUMMC+LD*(SSUMMCI+SSUMMSNOW))/CP
       RETURN
      ENDIF
      DTIMEW= 10.*DTIMEV
      DTIMEI= 10.*DTIMEV
!      ADVW = -TENQV + 0.622*LV*EWS/RGVT/TK11**2/P*TENTEMP        ! le kell ellenorizni TK**2?
!      ADVI = -TENQV + 0.622*LD*EIS/RGVT/TK11**2/P*TENTEMP
      ADVW = -TENQV + 0.622*LV*EWS/RGVT/TK1**2/P*TENTEMP        ! le kell ellenorizni TK**2?
      ADVI = -TENQV + 0.622*LD*EIS/RGVT/TK1**2/P*TENTEMP

!      ADVW =0.0
!      ADVI =0.0

      CWATER = (RRW*SATW + PPI*SATI)/M2 +                  &
               ((QRW + ADVW)*RRW + (QRI + ADVI)*PPI)/M2/M2
      segw0 = (RRW*SATW + PPI*SATI)/M2
      segw1 = ((QRW + ADVW)*RRW + (QRI + ADVI)*PPI)/M2/M2
      CICE = (RRI*SATI + PPW*SATW)/M2 +                    &
               ((QRW + ADVW)*PPW + (QRI + ADVI)*RRI)/M2/M2

      if (ibug0.eq.1) then
        write(95,*) 'ssummc,ssummci',ssummc,ssummci
        write(95,*) 'ssummsnow',ssummsnow
!        write(95,*) 'segw,segi',segw,segi
!        write(95,*) 'dtimew,dtimei,dtimev',dtimew,dtimei,dtimev
        write(95,*) 'cwater,cice',cwater,cice
        write(95,*) 'sati,advw,advi',sati,advw,advi
        write(95,*) 'rrw,rri,m2',rrw,rri,m2
        write(95,*) 'ppw,ppi',ppw,ppi
        write(95,*) 'segw0,segw1',segw0,segw1
      endif
! reduce of the time step if it is neccesary
 
!      SEG = M2*DTIMEV
!      IF (SEG.LT.1d-5) THEN
!        SEG1 = SEG -0.5d0*SEG**2+1.d0/6.d0*SEG**3-1.d0/24.d0*SEG**4
!      ELSE
!        SEG1 = 1.d0 - DEXP(-SEG)
!      ENDIF
!      IF (SSUMMCI + SSUMMSNOW .GT.EPS2) THEN
!       SATNEWI = SATI - CICE*SEG1
!       IF (SATNEWI*SATI .LT.0.d0) THEN
!        SEGI = (CICE - SATI)/CICE
!        IF (SEGI.GT.EPS2.AND.SEGI.LT.1.d0) THEN
!         DTIMEI = -DLOG(SEGI)/M2
!        ENDIF
!       ENDIF
!      ELSE
!       SATNEWI = SATI
!       DMTTI = 0.0
!      ENDIF
!      IF (SSUMMC > 0.0) THEN
!       SATNEW = SATW - CWATER*SEG1
!       IF (SATNEW*SATW .LT.0.d0) THEN
!        SEGW = (CWATER - SATW)/CWATER
!        IF (SEGW.GT.EPS2.AND.SEGW.LT.1.d0) THEN
!         DTIMEW = -DLOG(SEGW)/M2
!        ENDIF
!       ENDIF
!      ELSE
!       SATNEW = SATW
!       DMTTW = 0.0
!      ENDIF
 
!  end of recalculation
      DTIMEV = AMIN1(DTIMEW,DTIMEI,DTIMEV)
       if (ibug0.eq.1) then
        write(95,*) 'dtimev',dtimev
       endif
      SEG = M2*DTIMEV
      IF (SEG.LT.1d-5) THEN
       SEG1 = SEG -0.5d0*SEG**2+1.d0/6.d0*SEG**3-         &
                                      1.d0/24.d0*SEG**4
       SEG2 = 0.5d0*SEG*DTIMEV-1.d0/6.d0*SEG**2*DTIMEV+   & 
                                   1d0/24d0*SEG**3*DTIMEV
      ELSE
       SEG1 = 1.d0 - DEXP(-SEG)
       SEG2 = DTIMEV - (1.d0-DEXP(-SEG))/M2
      ENDIF

       if (ibug0.eq.1) then
        write(95,*) 'm2*dtimev,segw,ssummc',m2*dtimev,segw,ssummc
       endif
      IF ((SSUMMCI + SSUMMSNOW).GT.0.0) THEN
       SATNEWI = SATI - CICE*SEG1
       DMTTI = SATI*DTIMEV - CICE*SEG2
       TAUI = DMTTI
       DMTTI = DMTTI*(KSZI2*SSUMCI2 + KSZI*SSUMSNOW2)
      ELSE
       DMTTI = 0.d0
       TAUI=0.d0
!       SATNEWI = SATI
       SATNEWI = SATI - CICE
      ENDIF
      IF (SSUMMC.GT.EPS2) THEN
       SATNEW = SATW - CWATER*SEG1
       DMTTW = SATW*DTIMEV - CWATER*SEG2
       TAUW = DMTTW
       DMTTW = DMTTW*KSZI*SSUM2 - KSZI*SSUM1*DTIMEV
      ELSE
       DMTTW = 0.d0
       TAUW = 0.d0
!       SATNEW = SATW
       SATNEW = SATW - CWATER
      ENDIF
      IF (DABS(DMTTW)+DABS(DMTTI).LT.1d-10) THEN
       QV1=QV1+TENQV*DTIMEV
       TK1=TK1+TENTEMP*DTIMEV
       RETURN
      ENDIF

      if (ibug0.eq.1) then
       write(95,*) 'sati,satnewi,satw,satnew,dmtti,dmttw'
       write(95,*) sati,satnewi,satw,satnew,dmtti,dmttw
       write(95,*) 'segw0,segw1,tauw',segw0,segw1,tauw
       write(95,*) 'dtimew,dtimei,dtimev',dtimew,dtimei,dtimev
      endif

      CALL COND2(k4,dmttw,dmtti,dtimev,FQSM,                       &
     &   SSUMNC4,SSUMMC4,SSUMNCI4,SSUMMCI4,SSUMNSNOW4,SSUMMSNOW4,    &
     &   TAUW,TAUI,TAU,TAU1,TAUCI,TAUSN,TK,EPS2,ibug0)

!
!  correction if the analitycal values and the numerical values are different
!
      DELTANC=0.d0
      DELTAMC=0.d0
      DELTANCI=0.d0
      DELTAMCI=0.d0
      DELTANSNOW=0.d0
      DELTAMSNOW=0.d0
      DO K=1,K4
       DELTANC=DELTANC+NTC(K)
       DELTAMC=DELTAMC+MTC(K)
       DELTANCI=DELTANCI+NTCI(K)
       DELTAMCI=DELTAMCI+MTCI(K)
       DELTANSNOW=DELTANSNOW+NTCIR(K)
       DELTAMSNOW=DELTAMSNOW+MTCIR(K)
      ENDDO
      DSNTC=DELTANC-SSUMNC
      DSMTC=DELTAMC-SSUMMC
      DSNTCI=DELTANCI-SSUMNCI
      DSMTCI=DELTAMCI-SSUMMCI
      DSNTSNOW=DELTANSNOW-SSUMNSNOW
      DSMTSNOW=DELTAMSNOW-SSUMMSNOW
                                                                                                                
      IF (DELTAMC.GT.0.0) THEN
        SEGw = (DMTTW- DSMTC)/DELTAMC
      ELSE
        SEGW=0.d0
      ENDIF
      IF (DELTAMCI+DELTAMSNOW.GT.0.0) THEN
        SEGI = (DMTTI- (DSMTCI+DSMTSNOW))/(DELTAMCI+DELTAMSNOW)
      ELSE
        SEGI=0.d0
      ENDIF
      DO K=1,K4
        MTC(K) = MTC(K) + SEGW*MTC(K)
        MTCI(K) = MTCI(K) +  SEGI*MTCI(K)
        MTCIR(K)= MTCIR(K) + SEGI*MTCIR(K)
        MTSNOWR(K)= MTSNOWR(K) + SEGI*MTSNOWR(K)
        MTSNOWM(K)= MTSNOWM(K) + SEGI*MTSNOWM(K)
      ENDDO
 
!  end of the corrrection
!   controll calculation
      DELTANC=0.d0
      DELTAMC=0.d0
      DELTANCI=0.d0
      DELTAMCI=0.d0
      DELTANSNOW=0.d0
      DELTAMSNOW=0.d0

      DO K=1,K4
!       NTC(K)= ERRORWN*NTC(K)
!       MTC(K)= ERRORWQ*MTC(K)
!       NTCI(K)=ERRORCIN*NTCI(K)
!       MTCI(K)=ERRORCIQ*MTCI(K)
!       NTCIR(K)=ERRORSNOWN*NTCIR(K)
!       MTCIR(K)=ERRORSNOWQ*MTCIR(K)
       DELTANC=DELTANC+NTC(K)
       DELTAMC=DELTAMC+MTC(K)
      if (ibug0.eq.1) then
         write(95,*)'DEBUG K,DELTAMC,MTC(K)= ', K,DELTAMC,MTC(K)
       endif
       DELTANCI=DELTANCI+NTCI(K)
       DELTAMCI=DELTAMCI+MTCI(K)
       DELTANSNOW=DELTANSNOW+NTCIR(K)
       DELTAMSNOW=DELTAMSNOW+MTCIR(K)
      ENDDO
      DSNTC=DELTANC-SSUMNC
      DSMTC=DELTAMC-SSUMMC
      DSNTCI=DELTANCI-SSUMNCI
      DSMTCI=DELTAMCI-SSUMMCI
      DSNTSNOW=DELTANSNOW-SSUMNSNOW
      DSMTSNOW=DELTAMSNOW-SSUMMSNOW
      ERRORQ=ERRORQ+DABS(DSMTC-DMTTW*DTIMEV)
      SCOND=SCOND+DABS(DMTTW)*DTIMEV
      ERRORQCI=ERRORQCI+DABS(DSMTCI+DSMTSNOW-DMTTI*DTIMEV)
      SDEP=SDEP+DABS(DMTTI)*DTIMEV
      errseg0=0.0
      if (dabs(dmtti) .gt. 0) then
      errseg0=DABS(DSMTCI+DSMTSNOW-DMTTI*DTIMEV)
      errseg0=errseg0/dabs(dmtti)/dtimev
      endif
      ERRDEP=DABS(DSMTCI+DSMTSNOW-DMTTI*DTIMEV)
      if (ibug0 .eq.1 ) then
       write(95,*) 'dsmtc,dsntc,dmttw*dt',dsmtc,dsntc,dmttw*dtime
       write(95,*) 'dsmtci,dsmtsnow,dmtti*dt',dsmtci,dsmtsnow,             &
     &             dmtti*dtime
       write(95,*) 'dsntci,dsntsnow',dsntci,dsntsnow
       write(95,*)'ERRWN,ERRWQ,ERRCIN,ERRCIQ,ERRSNOWN,ERRSNOWQ' 
!       write(95,*)ERRORWN,ERRORWQ,ERRORCIN,ERRORCIQ,ERRORSNOWN,ERRORSNOWQ
      endif
      IF (DSNTC.LT.0.0) CCN1=CCN1+DSNTC
      DNID2=0.0
      IF (DSNTCI.LT.0.0) DNID2=DSNTCI
      DNID3=0.0
      IF (DSNTSNOW.LT.0.0) DNID3=DSNTSNOW
      DNID1=DNID1+DNID2+DNID3
! xue the temp adjustment is not accurate since diffusion of water on snow is not the same as that of pure snow
! need to calculate the mass change of water on snow to make this right
!      QV1=QV1-DSMTC-DSMTCI-DSMTSNOW                        !(dmttw+dmtti)*DTIME
!      TK1=TK1+(LV*DSMTC+LD*(DSMTCI+DSMTSNOW))/CP     !(lv*dmttw+ld*dmtti)*DTIME/cp
! xue make the melting adjustment here
      QV1=QV1+TENQV*DTIMEV-DSMTC-DSMTCI-DSMTSNOW                 !(dmttw+dmtti)*DTIME
!      TK1=TK1+TENTEMP*DTIMEV+(LV*DSMTC+LD*(DSMTCI+DSMTSNOW))/CP  !(lv*dmttw+ld*dmtti)*DTIME/cp
      if(TK .LE. T0) then
       TK1=TK1+TENTEMP*DTIMEV+(LV*DSMTC+LD*(DSMTCI+DSMTSNOW))/CP  !(lv*dmttw+ld*dmtti)*DTIME/cp
      else
       TK1=TK1+TENTEMP*DTIMEV+LV*DSMTC/CP
      endif
      SATI = SATNEWI
      SATW = SATNEW
      IF (DABS(SATI) .LT.1d-8) SATI = 0.d0
      IF (DABS(SATW) .LT.1d-8) SATW = 0.d0
      STIME = STIME + DTIMEV
      IF (STIME.LT.DTIME -0.001) THEN
        DTIMEV = DTIME - STIME
        IF(ISTEP.GT.10) THEN
         WRITE(*,*) 'Too many time steps in cond',istep
         STOP
        ENDIF 
        GOTO 1
      ENDIF

      RETURN
      END SUBROUTINE COND

!----+-----------------------------------------------------------------+
!----+-----------------------------------------------------------------+
!.. This subroutine calculates the condensation on CCN
!..  continental ccn    jump=1
!..  maritime    ccn    jump=2

      SUBROUTINE COND0(CCN1,CCNM,DNTC0,DMTC0,TK1,QV1,TKM,QVM,P,LV,ibug0,piggyback)

      IMPLICIT NONE
      REAL*8 DNTC0,DMTC0,TK1,QV1
      REAL CCN1,CCNM,TKM,QVM,P,LV
      INTEGER ibug0
      INTEGER piggyback
      REAL*8 RMEAN,MMEAN,cnp_max,sum_cnp
      REAL NCCN,CORR,EWS,QWS,SATS,SSZ,DCCN,APT,DVAP,pre_factor
      INTEGER jump,kk

!----+

!      EWS = EXP((23.684*TKM-4947.34)/(TKM-35.86))
      EWS=EXP(53.67957-6743.769/tkm-4.8451*log(tkm))*100.
      IF (piggyback.eq.1) THEN
         JUMP = 2 !! maritime 
      ELSE
         JUMP = 1 !! contintental
      ENDIF
!      JUMP = 2 !1 ! for MC3E case, the cloud based droplet concentration is about 200/cc, a maritime CCN spectrum is recommended
      QWS = 0.622*EWS/P
      SATS = QVM/QWS
      DNTC0 = 0.0
      DMTC0 = 0.0
!      CORR = 3      !  correction factor for CCN concentration

      CORR = 1
!..multiplication factor for CCN concentration. Continental ramps quickly to 1000 per cc
!..whereas Maritime ramps only to 100 per cc. See Fig.1 of Rasmussen et al 2002.

!      cnp_max = 500.E6
!      if (JUMP .EQ. 3) then
!        JUMP = 2
!        CORR = 0.25
!        cnp_max = 25.E6    !  Make Maritime even cleaner (per Istvan 25 Feb 2008; GT)
!      elseif (JUMP .EQ. 2) then
!        cnp_max = 100.E6
!      endif
!    calculation of the number of active nuclei
      SSZ = 100.d0*(SATS - 1.0)

      if (ibug0.eq.1) then
        write(*,*) 'ssz in cond0,p,ews,qws,tkm,qvm',                    &
     &                            ssz,p,ews,qws,tkm,qvm
       endif
      NCCN = 0.0
      IF (SSZ < 0.0) GOTO 10
      IF (JUMP == 1) THEN          ! continental ccn
        IF (SSZ < 0.1 ) THEN
          NCCN = CORR*316.e4*SSZ**4.0*1.0e6
          GOTO 10
        ENDIF
        IF (SSZ >= 0.1 .AND. SSZ < 1.0) THEN
          NCCN=CORR*1000.0*SQRT(SSZ)*1.0e6
          GOTO 10
        ENDIF
        IF (SSZ >= 1.0) THEN
          NCCN=CORR*1000.0*1.0e6
        ENDIF
      ELSE                       ! maritime ccn
        IF (SSZ < 0.1) THEN
         NCCN = CORR*4.78e5*SSZ**4.0*1e6
         GOTO 10
        ENDIF
        IF(SSZ >= 0.1 .AND. SSZ < 0.63) THEN
         NCCN = CORR*120.0*SSZ**0.4*1e6
         GOTO 10
        ENDIF
        IF (SSZ >= 0.63) THEN
         NCCN = CORR*1e8
        ENDIF
      ENDIF
 10   continue

! Added by G. Thompson:
! Try to ensure some (below cnp_max) drops per cc no matter how many ccn
! were previously activated. Pre-factor determined by 1.0/(NSTEP*timestep)
!      sum_cnp = 0.
!      do kk = 1, n_rain-1
!         sum_cnp = sum_cnp + ntc(kk)
!      enddo
!      pre_factor = 1.0/(2.0*4.0)
       IF (NCCN <= CCNM) THEN
        RETURN
       ENDIF
!      IF (NCCN <= CCNM) THEN
!         DCCN = MAX(1.E5, NCCN - CCNM)             ! number of newly activated nuclei
!      ELSEIF (NCCN > 0. .and. cnp_max.gt.sum_cnp) THEN
!         DCCN = pre_factor*(cnp_max-sum_cnp)              ! number of newly activated nuclei
!      else
!         DCCN = 0.
!      endif
      DCCN = NCCN - CCNM              ! number of newly activated nuclei
      APT = 1.00+0.622d0*LV*LV*EWS/(RGV*CP*P*TKM*TKM)
      DVAP =(QVM - QWS)/APT            ! available vapor content for diffusion on CCN
      IF (ibug0.eq.1) THEN
        write(*,*) 'in cond01'
        write(*,*)'dccn,apt,dvap',dccn,apt,dvap
        write(*,*) 'nccn,ccn1,ccnm',nccn,ccn1,ccnm
      ENDIF
      IF (DVAP .le. 0.0) THEN
       RETURN
      ENDIF
!      the size distribution of the newly form drops is given by aa*exp(-r/rmean)
!      rmean=rmax*exp(-ssz/8.2)            ! mean radius of the newly formed drops
!30     aa=dccn/rmean/(dexp(-r1/rmean)-dexp(-rmax/rmean))
!      summ=0.d0
!      snn=0.d0
!      do 40 i=1,36
!      IF (r(i).gt.rmax) GOTO 50
!      mmean=1.5d0*m(i)
!      dntc0(i)=aa*rmean*(dexp(-r(i)/rmean)-dexp(-r(i+1)/rmean))
!      dmtc0(i)=dntc0(i)*mmean
!      summ=summ+dmtc0(i)
!      snn=snn+dntc0(i)
!40    CONTINUE
!50    CONTINUE
!      IF (summ.gt.dvap) THEN
!        defic=dvap-summ
!          do 60 i=36,1,-1
!            IF (r(i).gt.rmax) GOTO 60
!             seg=dmtc0(i)+defic
!             IF(seg.LT.0.d0) THEN
!                  defic=defic+dmtc0(i)
!              dmtc0(i)=0.d0
!                  dntc0(i)=0.d0
!                 else
!                  dmtc0(i)=dmtc0(i)+defic
!                  dntc0(i)=dmtc0(i)/(1.5d0*m(i))
!                  GOTO 65
!                 ENDIF
!60         CONTINUE
!65         CONTINUE
      DMTC0 = DCCN*1.5*M(1)
      DNTC0 = DCCN
      IF (DMTC0 > DVAP) THEN
        DMTC0 = DVAP
        DNTC0 = DMTC0/(1.5*M(1))
      ENDIF
      QV1 = QV1 - DMTC0
      TK1 = TK1 + LV*DMTC0/CP
      CCN1 = CCN1 + DNTC0
      IF (ibug0.eq.1) THEN
        write(*,*)'in cond0 dmtc0,tk1,dntc0,lv',dmtc0,tk1,dntc0,lv
        write(*,*)'supsat,ccn1',ssz,ccn1
      ENDIF
      RETURN
      END SUBROUTINE COND0

!----+-----------------------------------------------------------------+
!----+-----------------------------------------------------------------+
      SUBROUTINE COND2(k4,dmttw,dmtti,dtimev,FQSM,                 &
     &   ssumnc,ssummc,ssumnci,ssummci,SSUMNSNOW,SSUMMSNOW,        &
     &   TAUW,TAUI,TAU,TAU1,TAUCI,TAUSNOW,TK,EPS2,ibug)

      IMPLICIT NONE
      INTEGER K4,ibug
      REAL*8 DMTTW,DMTTI,qv1
      REAL*8 FQSM(K4)
      REAL ssumnc,ssummc,ssumnci,ssummci,SSUMMSNOW,SSUMNSNOW
      REAL*8 AC(nbins),BC(nbins),CC(nbins),DC(nbins)
      REAL*8 FN(nbins),FQ(nbins)
      REAL*8 ntcsi(nbins),mtcsi(nbins)
      REAL*8 TAUW,TAUI,tau(40),tau1(40),tauci(40),TAUSNOW(40),y(40)
      REAL*8 STIME,DTIMEV,mmin0,mmax0,mmin,mmax,                        &
     &       mminci,mminci0,mmaxci,mmaxci0,MMINSNOW0,MMINSNOW,          &
     &       M2,MMEAN,MMEAN1,MMAXSNOW0,MMAXSNOW,                        &
     &       SEGMIN,SEGMAX,SEG,SUMNTC,SUMMTC,XA,XF,RESULT1,RESULT2,     &
     &       RESULT3
      REAL*8 EPS2
      REAL TK
      INTEGER yk(40),K,KMIN,KMAX,I,I1,I2,IK,kmin0,kmax0,INTERV

!----+

     
!      IF (DMTTW*DTIMEV+SSUMMC .LT. 0.d0) THEN
      IF (DMTTW+SSUMMC .LT. 0.d0) THEN
        DO K=1,K4
         NTC(K)=0.d0
         MTC(K)=0.d0
        ENDDO
        GOTO 100
      ENDIF
      IF (SSUMNC.LT.EPS) GOTO 100
      DO K = 1,K4
       Y(K)=0.d0
       YK(K)=0
       TAU(K)=TAU(K)*TAUW-TAU1(K)
      ENDDO
!       calculation of the condenstional grotwh of water drops
!      CALL coef1(k4,ac,bc,cc,dc,mtc,ntc,kmin0,kmax0,ssummc)
      CALL coef1(k4,ac,bc,cc,dc,mtc,ntc,kmin0,kmax0,ssumnc)
      
      if (ibug.eq.1) then
        write(95,*) 'after coef1 in cond 2'
        do k=1,k4
         write(95,*) 'k,tau',k,tau(k)
        enddo
      endif
      mmin0=m(kmin0)
      mmax0=m(kmax0+1)
      segmin=m(1)**(2.d0/3.d0)
      segmax=m(k4+1)**(2.d0/3.d0)
!      tau=0.d0
      mmin=mmin0**(2.d0/3.d0)+2.d0/3.d0*tau(kmin0)
      IF (mmin.LT.segmin) THEN
       mmin=m(1)
      else
       mmin=mmin**(3.d0/2.d0)
      ENDIF

      if(kmax0.lt.1) then                             ! xue add this judgement
       mmax=mmax0**(2.d0/3.d0)+2.d0/3.d0*tau(1)
      else
       mmax=mmax0**(2.d0/3.d0)+2.d0/3.d0*tau(kmax0)
      endif
      IF (mmax.LT.segmin) THEN
        do k=1,k4
         ntc(K)=0.d0
         mtc(K)=0.d0
        ENDDO
        GOTO 100
      ENDIF
      IF (mmax.gt.segmax) THEN
       mmax=m(k4+1)
      else
       mmax=mmax**(3.d0/2.d0)
      ENDIF

      IF (mmin.LT.m(2)) THEN
        kmin=1
        GOTO 10
      ENDIF
      kmin=0
 13   continue
      kmin=kmin+1
      if(kmin.eq.37) goto 14
      IF(mmin.ge.m(kmin)) GOTO 13
14    kmin=kmin-1
10    IF (mmax.gt.m(k4-1)) THEN
       kmax=k4-1
       GOTO 20
      ENDIF
      kmax=kmin
15    kmax=kmax+1
      if(kmax.eq.37) goto 16
      IF (mmax.ge.m(kmax)) GOTO 15
16    kmax=kmax-1
!      calculation of the  intervals where yk and yk+1 are
!
       if (ibug.eq.2) then
        write(*,*) 'after coef1 in cond 2/2'
        do k=1,k4
         write(*,*) 'k,fqsm',k,fqsm(k)
        enddo
      endif

20    IF (dmttw.ge.0.d0) THEN     ! the drops grow by condensation
!        KMAX=MIN(K4-2,KMAX)
         KMAX = MIN(K4-1,KMAX)            !  modified on 08. 20. 2013.
        DO 40 K = KMIN,KMAX
         IK = K-1
         IF (IK.LT.1) IK = 1
         SEG = M(K)**(2.d0/3.d0)-2.d0/3.d0*TAU(IK)
         IF (SEG.LT.SEGMIN) THEN
!         YK(K)=0
          YK(K)=1                     ! was modified on 06. 07. 2004
          IF (SEG.LT.0.d0) THEN
           Y(K)=0.d0
          ELSE
           Y(K)= SEG**(3.d0/2.d0)
          ENDIF
          IF(K.GT.KMIN) THEN
            YK(K) = 1
            Y(K) = M(1)
          ENDIF
          GOTO 40
         ENDIF
         SEG = SEG**(3.d0/2.d0)
         i=k+1
 45      continue
         i=i-1
         if(i.eq.1) goto 46
         IF ((m(i)-seg).gt.0.d0) GOTO 45
 46      continue
         IF (seg.LT.mmin0) THEN
          seg=mmin0
          i=kmin0
         ENDIF
         yk(K)=i
         y(K)=seg
40      CONTINUE
      ELSE                         ! evaporation
!        KMAX=MIN(K4-2,KMAX)
        KMAX=MIN(K4-1,KMAX)             ! was modified on 08. 20. 2013. 
       DO 50 K=1,KMAX
         IK = K+1
         IF (IK.GT.KMAX) IK = KMAX
         SEG = M(K)**(2.d0/3.d0)-2.d0/3.d0*TAU(IK)
         IF (SEG.GT.SEGMAX) THEN
          YK(K)=k4
          Y(K)=seg**(3.d0/2.d0)
          GOTO 50
         ENDIF
         SEG = SEG**(3.d0/2.d0)
         I=K
 55      continue
         I = I+1
         IF(I.EQ.K4+1) GOTO 56
         IF ((M(I)-SEG).LT.0.d0) GOTO 55
 56      continue
         YK(K)=I-1
         Y(K)=SEG
50     CONTINUE
      ENDIF
       IF (y(kmax+1).LE.mmax0) THEN    ! New, 11 Feb 2008, changed lt to le
        y(kmax+1)=mmax0
        YK(KMAX+1) = KMAX0             ! New, 11 Feb 2008, per Istvan
       ENDIF
       IF (y(kmin).LE.mmin0) THEN
        y(kmin)=mmin0
        YK(KMIN)=KMIN0                 ! New, 11 Feb 2008, per Istvan
       ENDIF

       IF (ibug.eq.1)THEN
        write(95,*)'in cond2/3'
        write(95,*)'dmttw',dmttw
        write(95,*)'kmin0,kmin,kmax0,kmax',kmin0,kmin,kmax0,kmax
        write(95,*)'mmin0,mmin,mmax0,mmax',mmin0,mmin,mmax0,mmax
        do k=1,k4
          write(95,*) 'k,y,yk,tau',k,y(K),yk(K),tau(K)
        ENDDO
       ENDIF

!      calculation of the new value of drop concentration and first moment (mixing ratio)
!
!  calculation of the mass and concentration of the totally evaporated drops


      IF(dmttw.LT.0.d0.AND.mmin.EQ.m(1)) THEN
       mmin0=y(1)
       kmin0=yk(1)
      ENDIF
      DO K =1 ,K4
       NTC(K)=0.d0
       MTC(K)=0.d0
      ENDDO
      DO 60 K = KMIN,KMAX
       sumntc=0.d0
       summtc=0.d0
       IF (Y(K).GT.MMAX0 .OR. Y(K+1).LT.MMIN0) GOTO 60
       IF (DMTTW.LT.0.0.AND.KMIN.EQ.KMAX) GOTO 63
!          condensation or evaporation at lower boundary of the size distribution
       IF (K == KMIN) THEN
        IF(KMIN0 == YK(K+1)) THEN
         xa=mmin0
         xf=y(k+1)
         CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
         CALL integral2(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
         IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
         ENDIF
         NTC(K)=result1
         MTC(K)=result2
       if (ibug ==1) write(95,*) ' DEBUG after xa,xf,result2  = ', xa,xf,result2
         GOTO 60
        ENDIF
        xa=mmin0
        xf=m(kmin0+1)
        CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
        CALL integral2(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
        IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
        ENDIF
       if (ibug ==1) write(95,*) ' DEBUG1 after xa,xf,result2  = ', xa,xf,result2
        sumntc=result1
        summtc=result2
        interv=yk(k+1)-kmin0
        IF (interv.gt.1) THEN
         DO 65 i=kmin0+1,yk(k+1)-1
          i2=i+1
          xa=m(i)
          xf=m(i2)
          CALL integral1(xf,xa,bc(i),ac(i),result1)
          CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
          IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
          ENDIF
          sumntc=sumntc+result1
          summtc=result2+summtc
65       CONTINUE
        ENDIF
        I1=YK(K+1)
        XA=M(I1)
        XF=Y(K+1)
        RESULT1=0.d0
        RESULT2=0.d0
        IF (XA.GE.XF) GOTO 66
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
!     if (ibug ==1) write(*,*) ' DEBUG calling integral2 ', i1,xf,xa,dc(i1),cc(i1),tau(i1)
        CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
        ENDIF
66      CONTINUE
        NTC(K)=sumntc+result1
        MTC(K)=summtc+result2
       if (ibug ==1) write(95,*) ' DEBUG after 66-result2, summtc',summtc,result2
        GOTO 60
       ENDIF                           ! end of calculation at the lower boundary
!         condensation or evaporation at the upper boundary
 63   continue
       IF (k.eq.kmax) THEN
        IF(kmax0.eq.yk(kmax)) THEN
         xa=y(kmax)
         xf=mmax0
         CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
         CALL integral2(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
         IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
          result1=0.d0
          result2=0.d0
         ENDIF
         if (ibug.eq.1) then
          write(95,*) '1,k,xa,xf,result1,result2',k,xa,xf,result1,result2
         endif
         NTC(K)=result1
         MTC(K)=result2
         GOTO 60
        ENDIF
        xa=m(kmax0)
        xf=mmax0
        CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
        CALL integral2(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
        IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
         result1=0.d0
         result2=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        if (ibug.eq.-1) then
         write(99,*) '2,k,xa,xf,result1,result2',k,xa,xf,result1,result2
        endif
        interv=kmax0-yk(kmax)
        IF (interv.gt.1) THEN
         DO 70 I = YK(kmax)+1,kmax0-1
          i2=i+1
          xa=m(i)
          xf=m(i2)
          CALL integral1(xf,xa,bc(i),ac(i),result1)
          CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
          IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
           result1=0.d0
           result2=0.d0
          ENDIF
          sumntc=sumntc+result1
          summtc=summtc+result2
70       CONTINUE
         if (ibug.eq.-1)then
          write(99,*) 'interv',interv
          write(99,*) '3,k,xa,xf,sumntc,summtc',k,xa,xf,sumntc,summtc
         endif
        ENDIF
        i1=yk(K)
        i2=yk(K)+1
        xa=y(K)
        xf=m(i2)
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
        ENDIF
        ntc(K)=sumntc+result1
        mtc(K)=summtc+result2
         if (ibug.eq.1)then
          write(95,*) 'interv',interv
          write(95,*) '4,k,xa,xf,ntc,mtc',k,xa,xf,ntc(k),mtc(k)
         endif
        GOTO 60
       ENDIF                            ! end of the calculation at the upper boundary
!      condensation or evaporation inside of the size distribution
       interv=yk(k+1)-yk(K)
       IF (interv.eq.0) THEN
        i1=yk(K)
        xa=y(K)
        xf=y(k+1)
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
        ENDIF
        ntc(K)=result1
        mtc(K)=result2
        if (ibug.eq.1) then
          write(99,*) 'interv',interv
          write(99,*) '5,k,xa,xf,ntc,mtc',k,xa,xf,ntc(k),mtc(k)
         endif
        GOTO 60
       ENDIF
       i1=yk(K)
       i2=yk(K)+1
       xa=y(K)
       xf=m(i2)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
       IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
           result1=0.d0
           result2=0.d0
       ENDIF
       sumntc=result1
       summtc=result2
       if (ibug.eq.-1) then
          write(99,*) 'interv',interv
          write(99,*) '6,k,xa,xf,sumntc,summtc',k,xa,xf,sumntc,summtc
       endif
       IF (interv.gt.1) THEN
        DO 80 I=YK(K)+1,YK(K+1)-1
         i2=i+1
         xa=m(i)
         xf=m(i2)
         CALL integral1(xf,xa,bc(i),ac(i),result1)
         CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
         IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
         ENDIF
         sumntc=sumntc+result1
         summtc=summtc+result2
80      CONTINUE
       ENDIF
       if (ibug.eq.-1) then
          write(99,*) 'interv',interv
          write(99,*) '7,k,xa,xf,sumntc,summtc',k,xa,xf,sumntc,summtc
       endif
       i1=yk(k+1)
       xa=m(i1)
       xf=y(k+1)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),RESULT2)
       IF (result1.LT.0.d0.OR.result2.LT.0.d0) THEN
             result1=0.d0
             result2=0.d0
       ENDIF
       ntc(K)=sumntc+result1
       mtc(K)=summtc+result2
       if (ibug.eq.-1) then
          write(99,*) 'interv',interv
          write(99,*) '8,k,xa,xf,ntc,mtc',k,xa,xf,ntc(k),mtc(k)
         endif
      
60    CONTINUE
      if (ibug .eq.-1 ) then
       write(99,*) 'end of  water'
      endif
!
!                               diffusional growth of the ice crystals
!                           calculation of the boundaries of the integrals
!

100   CONTINUE
!      IF (DMTTI*DTIMEV+SSUMMCI+SSUMMSNOW.LT. 0.0) THEN
      IF (DMTTI+SSUMMCI+SSUMMSNOW.LT. 0.0) THEN
        DO K = 1,K4
         NTCI(K)=0.d0
         MTCI(K)=0.d0
         NTCIR(K)=0.d0
         MTCIR(K)=0.d0
         NTSNOWR(K)=0.d0
         MTSNOWR(K)=0.d0
         MTSNOWM(K)=0.d0
        ENDDO
        GOTO 400
      ENDIF
      IF (SSUMNCI .LT. EPS) GOTO 300 
      CALL COEF1(k4,ac,bc,cc,dc,mtci,ntci,kmin0,kmax0,ssumnci)
!      CALL COEF1(k4,ac,bc,cc,dc,mtci,ntci,kmin0,kmax0,ssummci)
      KMAX0=MIN(K4-1,KMAX0)
      mminci0=m(kmin0)
      mmaxci0=m(kmax0+1)
      DO 200 K=1,K4
       Y(K)=0.d0
       YK(K)=0
       TAU(K)=TAUI*TAUCI(K)
200   CONTINUE
      segmin=m(1)**0.5d0
      segmax=m(k4+1)**0.5d0
!      tau=0.d0
      mminci=mminci0**0.5d0+0.5d0*tau(kmin0)
      IF (mminci.LT.segmin) THEN
       mminci=m(1)
      else
       mminci=mminci**2.d0
      ENDIF
      mmaxci=mmaxci0**0.5d0+0.5d0*tau(kmax0)
      IF (mmaxci.LT.segmin) THEN
        do k=1,k4
         ntci(K)=0.d0
         mtci(K)=0.d0
        ENDDO
        GOTO 300
      ENDIF
      IF (mmaxci.gt.segmax) THEN
       mmaxci=m(k4+1)
      ELSE
       mmaxci=mmaxci**2.d0
      ENDIF
      IF (mminci.LT.m(2)) THEN
       kmin=1
       GOTO 118
      ENDIF
      kmin=0
 113  continue
      kmin=kmin+1
      if(kmin.eq.37) goto 114
      IF(mminci.ge.m(kmin)) GOTO 113
 114  continue
      kmin=kmin-1
 118  continue
      IF (mmaxci.gt.m(k4)) THEN
       kmax=k4
       GOTO 119
      ENDIF
      kmax=kmin
 115  continue
      kmax=kmax+1
      if(kmax.eq.37) goto 116
      IF (mmaxci.ge.m(kmax)) GOTO 115
 116  continue
      kmax=kmax-1
!      calculation of the  intervals where yk and yk+1 are
!
 119  continue
      IF (DMTTI .GT. 0.d0) THEN     ! the crystals grow by deposition
       KMAX=MIN(K4-2,KMAX)
       DO 140 K = KMIN,K4
        IK=K-1
        IF (IK.LT.1) IK = 1
        SEG = M(K)**0.5d0-0.5d0*TAU(IK)
        IF (seg.LT.segmin) THEN
         yk(K)=1
         IF (seg.LT.0.d0) THEN
            y(K)=0.d0
         ELSE
            y(K)=seg**2.d0
         ENDIF
         IF(k.gt.kmin) THEN
          yk(K)=1
          y(K)=m(1)
         ENDIF
         GOTO 140
        ENDIF
        seg=seg**2.d0
        i=k+1
 145    continue
        i=i-1
        if(i.eq.1) goto 146
        IF ((m(i)-seg).gt.0.d0) GOTO 145
 146    continue
        IF (seg.LT.mminci0) THEN
         seg=mminci0
         i=kmin0
        ENDIF
        yk(K)=i
        y(K)=seg
140    CONTINUE
      ELSE                        ! sublimation
       KMAX=MIN(K4-2,KMAX)
       DO 150 K = 1,KMAX
        IK = K+1
        IF (IK.GT.KMAX) IK = KMAX
        seg=m(K)**0.5d0-0.5d0*tau(ik)
        IF (seg.gt.segmax) THEN
         yk(K)=k4
         y(K)=seg**2.d0
         GOTO 150
        ENDIF
        seg=seg**2.d0
        i=k
155     continue
        i=i+1
        if(i.eq.37) goto 156
        IF ((m(i)-seg).LT.0.d0) GOTO 155
156     continue
        yk(K)=i-1
        y(K)=seg
150    CONTINUE
      ENDIF
      IF (y(kmin).LT.mminci0) THEN
         y(kmin)=mminci0
         yk(kmin)=kmin0
      ENDIF
      IF (y(kmax+1).LT.mmaxci0) THEN
         y(kmax+1)=mmaxci0
         yk(kmax+1)=kmax0+1
      ENDIF
!      calculation of the new value of crystal concentration and first moment (mixing ratio)
!
!  calculation of the mass and concentration of the totally sublimated crystals
      IF(dmtti.LT.0.d0.and.mminci.eq.m(1)) THEN
       mminci0=y(1)
       kmin0=yk(1)
      ENDIF
      do k=1,k4
       mtci(K)=0.d0
       ntci(K)=0.d0
      ENDDO
      DO 160 K = KMIN,KMAX
       sumntc=0.d0
       summtc=0.d0
       IF (Y(K).GT.mmaxci0.OR.Y(K+1).LT.mminci0) GOTO 160
!          diffusion at the bottom boundary of the size distribution
       IF (k.eq.kmin) THEN
        IF(kmin0.eq.yk(k+1)) THEN
         xa=mminci0
         xf=y(k+1)
         CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
         CALL integral4(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
         ENDIF
         ntci(K)=result1
         mtci(K)=result2
         GOTO 160
        ENDIF
        xa=mminci0
        xf=m(kmin0+1)
        CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
        CALL integral4(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        interv=yk(k+1)-kmin0
        IF (interv.gt.1) THEN
         do 165 i=kmin0+1,yk(k+1)-1
            i2=i+1
            xa=m(i)
            xf=m(i2)
            CALL integral1(xf,xa,bc(i),ac(i),result1)
            CALL integral4(xf,xa,dc(i),cc(i),tau(i),result2)
            IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
            ENDIF
            sumntc=sumntc+result1
            summtc=result2+summtc
165      CONTINUE
        ENDIF
        i1=yk(k+1)
        xa=m(i1)
        xf=y(k+1)
        RESULT1=0.d0
        RESULT2=0.d0
        IF (XA.GE.XF) GOTO 166
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral4(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
        ENDIF
166     CONTINUE
        ntci(K)=sumntc+result1
        mtci(K)=summtc+result2
        GOTO 160
       ENDIF                           ! end of calculation at the lower boundary
!         diffusion at the top boundary
       IF (k.eq.kmax) THEN
       IF(kmax0.eq.yk(kmax)) THEN
          xa=y(kmax)
          xf=mmaxci0
          CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
          CALL integral4(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
          IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
          ENDIF
          ntci(K)=result1
          mtci(K)=result2
          GOTO 160
        ENDIF
        xa=m(kmax0)
        xf=mmaxci0
        CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
        CALL integral4(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        interv=kmax0-yk(kmax)
        IF (interv.gt.1) THEN
          do 170 i=yk(kmax)+1,kmax0-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bc(i),ac(i),result1)
           CALL integral4(xf,xa,dc(i),cc(i),tau(i),result2)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=summtc+result2
 170     CONTINUE
        ENDIF
        i1=yk(K)
        i2=yk(K)+1
        xa=y(K)
        xf=m(i2)
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral4(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
        ENDIF
        ntci(K)=sumntc+result1
        mtci(K)=summtc+result2
        GOTO 160
       ENDIF                            ! end of the calculation at the upper boundary
!     deposition or sublimation inside of the size distribution
       interv=yk(k+1)-yk(K)
       IF (interv.eq.0) THEN
         i1=yk(K)
         xa=y(K)
         xf=y(k+1)
         CALL integral1(xf,xa,bc(i1),ac(i1),result1)
         CALL integral4(xf,xa,dc(i1),cc(i1),tau(i1),result2)
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
         ENDIF
         ntci(K)=result1
         mtci(K)=result2
         GOTO 160
       ENDIF
       i1=yk(K)
       i2=yk(K)+1
       xa=y(K)
       xf=m(i2)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral4(xf,xa,dc(i1),cc(i1),tau(i1),result2)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
       ENDIF
       sumntc=result1
       summtc=result2
       IF (interv.gt.1) THEN
         do 180 i=yk(K)+1,yk(k+1)-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bc(i),ac(i),result1)
           CALL integral4(xf,xa,dc(i),cc(i),tau(i),result2)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=summtc+result2
 180     CONTINUE
       ENDIF
       i1=yk(k+1)
       xa=m(i1)
       xf=y(k+1)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral4(xf,xa,dc(i1),cc(i1),tau(i1),result2)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
          RESULT1=0.d0
          RESULT2=0.d0
       ENDIF
       ntci(K)=sumntc+result1
       mtci(K)=summtc+result2
160   CONTINUE
!       end for hexagonal plate ice crystal
!
!       calculation of the diffusional  grotwh of snow flake crystal
300   continue
      IF (SSUMNSNOW.LT.EPS) GOTO 400
      CALL coef1(k4,ac,bc,cc,dc,mtcir,ntcir,kmin0,kmax0,SSUMNSNOW)
!      CALL coef1(k4,ac,bc,cc,dc,mtcir,ntcir,kmin0,kmax0,SSUMMSNOW)

      DO K=1,K4
!        FQSM(K)=0.0
         FN(K)=0.0
         FQ(K)=0.0
         IF (TK.LT.T0) THEN
            IF (NTCIR(K).GT.0.0) THEN
               FN(K)= MAX(0.0d0, MIN(NTSNOWR(K)/NTCIR(K), 1.0d0))
            ENDIF
            IF (MTCIR(K).GT.0.0) THEN
               FQ(K)=MAX(0.0d0, MIN(MTSNOWR(K)/MTCIR(K), 1.0d0))
            ENDIF
!        ELSE
!           IF (MTCIR(K).GT.0.0) THEN
!              FQSM(K)= MAX(0.0d0, MIN(MTSNOWM(K)/MTCIR(K), 1.0d0))
!           ENDIF
         ENDIF
      ENDDO

      KMAX0=MIN(K4-1,KMAX0)
      MMINSNOW0 = M(KMIN0)
      MMAXSNOW0 = M(KMAX0+1)
      DO 210 K = 1,K4
       Y(K)=0.d0
       YK(K)=0
       TAU(K)=TAUI*TAUSNOW(K)
 210  CONTINUE

!
! innen kell folytatni

      segmin=M(1)**(2.d0/3.d0)
      segmax=M(K4+1)**(2.d0/3.d0)
!      tau=0.d0
      MMINSNOW = MMINSNOW0**(2.d0/3.d0)+2.d0/3.d0*TAU(KMIN0)
      IF (MMINSNOW.LT.SEGMIN) THEN
       MMINSNOW = M(1)
      ELSE
       MMINSNOW = MMINSNOW**(3.d0/2.d0)
      ENDIF
      MMAXSNOW = MMAXSNOW0**(2.d0/3.d0)+2.d0/3.d0*TAU(KMAX0)
      IF (MMAXSNOW.LT.SEGMIN) THEN
        DO K = 1,K4
          NTCIR(K)=0.d0
          MTCIR(K)=0.d0
          NTSNOWR(K)=0.d0
          MTSNOWR(K)=0.d0
          MTSNOWM(K)=0.d0
        ENDDO
        GOTO 400
      ENDIF
      IF (MMAXSNOW.GT.SEGMAX) THEN
       MMAXSNOW = M(K4+1)
      ELSE
       MMAXSNOW = MMAXSNOW**(3.d0/2.d0)
      ENDIF
      IF (MMINSNOW.LT.M(2)) THEN
       KMIN = 1
       GOTO 218
      ENDIF
      kmin=0
 213  continue
      kmin=kmin+1
      IF(KMIN.EQ.K4+1) GOTO 214
      IF(MMINSNOW.GE.M(KMIN)) GOTO 213
 214  continue
      KMIN = KMIN-1
 218  continue
      IF (MMAXSNOW.GT.M(K4-1)) THEN
       KMAX = K4-1
       GOTO 219
      ENDIF
      kmax=kmin
 215  continue
      kmax=kmax+1
      IF (KMAX.EQ.K4+1) GOTO 216
      IF (MMAXSNOW.GE.M(KMAX)) GOTO 215
 216  continue
      KMAX = KMAX - 1
!      calculation of the  intervals where yk and yk+1 are
!
 219  continue
      IF (DMTTI.GE.0.d0) THEN     ! the crystals grow by deposition
       KMAX = MIN(K4-2,KMAX)
       DO 240 K = KMIN,KMAX
        ik=k-1
        IF (IK.LT.1) IK = 1
        seg=m(K)**(2.d0/3.d0)-2.d0/3.d0*tau(ik)
        IF (seg.LT.segmin) THEN
          yk(K)=1
          IF (seg.LT.0.d0) THEN
            y(K)=0.d0
          else
            y(K)=seg**(3.d0/2.d0)
          ENDIF
          GOTO 240
        ENDIF
        seg=seg**(3.d0/2.d0)
        i=k+1
 245    continue
        i=i-1
        if(i.eq.1) goto 246
        IF ((m(i)-seg).gt.0.d0) GOTO 245
 246    continue
        IF (SEG.LT.MMINSNOW0) THEN
           SEG = MMINSNOW0
           I = KMIN0
        ENDIF
        YK(K)=I
        Y(K)=SEG
 240    CONTINUE
      ELSE                         !sublimation
       kmax=min(k4-2,kmax)
       do 250 k=1,kmax
        ik=k+1
        IF (ik.gt.kmax) ik=kmax
        seg=m(K)**(2.d0/3.d0)-2.d0/3.d0*tau(ik)
        IF (seg.gt.segmax) THEN
           yk(K)=k4
           y(K)=seg**(3.d0/2.d0)
           GOTO 250
        ENDIF
        seg=seg**(3.d0/2.d0)
        i=k
 255    continue
        i=i+1
        IF(I.EQ.K4+1) GOTO 256
        IF ((M(I)-SEG).LT.0.d0) GOTO 255
 256    continue
        YK(K)=I-1
        Y(K)=SEG
 250    CONTINUE
      ENDIF
      IF (Y(KMAX+1).LT.MMAXSNOW0) THEN
          Y(KMAX+1)=MMAXSNOW0
          YK(KMAX+1)=KMAX0+1
      ENDIF
      IF (Y(KMIN).LT.MMINSNOW0) THEN
          Y(KMIN)=MMINSNOW0
          YK(KMIN)=KMIN0
      ENDIF
      IF (ibug.eq.1) THEN
        write(*,*)'for snow flake'
        write(*,*)'kmin0,kmin,kmax0,kmax',kmin0,kmin,kmax0,kmax
        write(*,*)'mmin0,mmin,mmax0,mmax',mmin0,mmin,mmax0,mmax
        do k=1,k4
          write(*,*) 'k,y,yk,tau',k,y(K),yk(K),tau(K)
        ENDDO
       ENDIF

!      calculation of the new value of rimed ice crystal concentration and first moment (mixing ratio)
!
!  calculation of the mass and concentration of the totally sublimated crystals
      IF(DMTTI.LT.0.d0.AND.MMINSNOW.EQ.M(1)) THEN
       MMINSNOW0=Y(1)
       KMIN0 = YK(1)
      ENDIF
      DO K = 1,K4
       mtcir(K)=0.d0
       ntcir(K)=0.d0
       NTSNOWR(K)=0.d0
       MTSNOWR(K)=0.d0
       MTSNOWM(K)=0.d0
      ENDDO
      do 260 k=kmin,kmax
       sumntc=0.d0
       summtc=0.d0
       IF (Y(K).GT.MMAXSNOW0.OR.Y(K+1).LT.MMINSNOW0) GOTO 260
!          diffusional growth at lower boundary of the size distribution
       IF(k.eq.kmin) THEN
         IF(kmin0.eq.yk(k+1)) THEN
           xa=MMINSNOW0
           xf=y(k+1)
           CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
           CALL integral2(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
           CALL integral1(xf,xa,dc(kmin0),cc(kmin0),result3)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
             RESULT3=0.d0
           ENDIF
           ntcir(K)=result1
           mtcir(K)=result2
           IF (TK.LT.T0) THEN
            NTSNOWR(K)=FN(KMIN0)*RESULT1
            MTSNOWR(K)=FQ(KMIN0)*RESULT3
           ELSE
            MTSNOWM(K) = MAX(0.d0, RESULT2 - (1.0 - FQSM(KMIN0))*RESULT3)
           ENDIF
           if (ibug.eq.1) then
            write(*,*) '1 result1,result2,result3',result1,result2,      &
     &             result3
            write(*,*) 'dm',result2-result3
           endif
           GOTO 260
         ENDIF
         XA=MMINSNOW0
         XF=m(kmin0+1)
         CALL integral1(xf,xa,bc(kmin0),ac(kmin0),result1)
         CALL integral2(xf,xa,dc(kmin0),cc(kmin0),tau(kmin0),result2)
         CALL integral1(xf,xa,dc(kmin0),cc(kmin0),result3)
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
             RESULT3=0.d0
         ENDIF
         sumntc=result1
         summtc=result2
         IF (TK.LT.T0) THEN
          NTSNOWR(K) = NTSNOWR(K) + FN(KMIN0)*RESULT1
          MTSNOWR(K) = MTSNOWR(K) + FQ(KMIN0)*RESULT3
         ELSE
          MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0 -FQSM(KMIN0))*RESULT3)
         ENDIF
         interv=yk(k+1)-kmin0
         IF (interv.gt.1) THEN
           do 265 i=kmin0+1,yk(k+1)-1
            i2=i+1
            xa=m(i)
            xf=m(i2)
            CALL integral1(xf,xa,bc(i),ac(i),result1)
            CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
            CALL integral1(xf,xa,dc(i),cc(i),result3)
            IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
                RESULT1=0.d0
                RESULT2=0.d0
                RESULT3=0.d0
            ENDIF
            sumntc=sumntc+result1
            summtc=result2+summtc
            IF (TK.LT.T0) THEN
             NTSNOWR(K) = NTSNOWR(K) + FN(I)*RESULT1
             MTSNOWR(K) = MTSNOWR(K) + FQ(I)*RESULT3
            ELSE
             MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0 -FQSM(I))*RESULT3)
            ENDIF
 265      CONTINUE
         ENDIF
         i1=yk(k+1)
         xa=m(i1)
         xf=y(k+1)
         RESULT1=0.d0
         RESULT2=0.d0
         IF (XA.GE.XF) GOTO 266
         CALL integral1(xf,xa,bc(i1),ac(i1),result1)
         CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),RESULT2)
         CALL integral1(xf,xa,dc(i1),cc(i1),RESULT3)
 266     CONTINUE
         ntcir(K)=sumntc+result1
         mtcir(K)=summtc+result2
         IF (TK.LT.T0) THEN
          NTSNOWR(K) = NTSNOWR(K) + FN(I1)*RESULT1
          MTSNOWR(K) = MTSNOWR(K) + FQ(I1)*RESULT3
         ELSE
          MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
         ENDIF
         GOTO 260
       ENDIF                           ! end of calculation at the lower boundary
!         diffusional growth at the upper boundary
       IF (k.eq.kmax) THEN
        IF(kmax0.eq.yk(kmax)) THEN
          XA = Y(kmax)
          XF = MMAXSNOW0
          CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
          CALL integral2(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
          CALL integral1(xf,xa,dc(kmax0),cc(kmax0),result3)
          IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
                RESULT1=0.d0
                RESULT2=0.d0
                RESULT3=0.d0
          ENDIF
          ntcir(K)=result1
          mtcir(K)=result2
          IF (TK.LT.T0) THEN
           NTSNOWR(K) = FN(KMAX0)*RESULT1
           MTSNOWR(K) = FQ(KMAX0)*RESULT3
          ELSE
!           MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(KMAX0))*RESULT3)
           MTSNOWM(K)=MAX(0.d0,RESULT2-(1.0-FQSM(KMAX0))*RESULT3)
          ENDIF
          GOTO 260
        ENDIF
        XA = M(KMAX0)
        XF = MMAXSNOW0
        CALL integral1(xf,xa,bc(kmax0),ac(kmax0),result1)
        CALL integral2(xf,xa,dc(kmax0),cc(kmax0),tau(kmax0),result2)
        CALL integral1(xf,xa,dc(kmax0),cc(kmax0),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        IF (TK.LT.T0) THEN
         NTSNOWR(K) = FN(KMAX0)*RESULT1
         MTSNOWR(K) = FQ(KMAX0)*RESULT3
        ELSE
!         MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(KMAX0))*RESULT3)
         MTSNOWM(K)=MAX(0.d0,RESULT2-(1.0-FQSM(KMAX0))*RESULT3)
        ENDIF
        interv=kmax0-yk(kmax)
        IF (interv.gt.1) THEN
          do 270 i=yk(kmax)+1,kmax0-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bc(i),ac(i),result1)
           CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
           CALL integral1(xf,xa,dc(i),cc(i),result3)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=summtc+result2
           IF (TK.LT.T0) THEN
            NTSNOWR(K) = NTSNOWR(K) + FN(I)*RESULT1
            MTSNOWR(K) = MTSNOWR(K) + FQ(I)*RESULT3
           ELSE
            MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I))*RESULT3)
           ENDIF
 270     CONTINUE
        ENDIF
        i1=yk(K)
        i2=yk(K)+1
        xa=y(K)
        xf=m(i2)
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        CALL integral1(xf,xa,dc(i1),cc(i1),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
        ENDIF
        ntcir(K)=sumntc+result1
        mtcir(K)=summtc+result2
        IF (TK.LT.T0) THEN
         NTSNOWR(K) = NTSNOWR(K) + FN(I1)*RESULT1
         MTSNOWR(K) = MTSNOWR(K) + FQ(I1)*RESULT3
        ELSE
         MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
        ENDIF
        GOTO 260
       ENDIF                            ! end of the calculation at the upper boundary
!      diffusional growth inside of the size distribution
       interv=yk(k+1)-yk(K)
       IF (interv.eq.0) THEN
        i1=yk(K)
        xa=y(K)
        xf=y(k+1)
        CALL integral1(xf,xa,bc(i1),ac(i1),result1)
        CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
        CALL integral1(xf,xa,dc(i1),cc(i1),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
        ENDIF
        ntcir(K)=result1
        mtcir(K)=result2
        IF (TK.LT.T0) THEN
         NTSNOWR(K) =  FN(I1)*RESULT1
         MTSNOWR(K) =  FQ(I1)*RESULT3
        ELSE
!         MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
         MTSNOWM(K)=MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
        ENDIF
        GOTO 260
       ENDIF
       i1=yk(K)
       i2=yk(K)+1
       xa=y(K)
       xf=m(i2)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
       CALL integral1(xf,xa,dc(i1),cc(i1),result3)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
        RESULT1=0.d0
        RESULT2=0.d0
        RESULT3=0.d0
       ENDIF
       sumntc=result1
       summtc=result2
       IF (TK.LT.T0) THEN
        NTSNOWR(K) =  FN(I1)*RESULT1
        MTSNOWR(K) =  FQ(I1)*RESULT3
       ELSE
!        MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
        MTSNOWM(K)=MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
       ENDIF
       IF (interv.gt.1) THEN
         do 280 i=yk(K)+1,yk(k+1)-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bc(i),ac(i),result1)
           CALL integral2(xf,xa,dc(i),cc(i),tau(i),result2)
           CALL integral1(xf,xa,dc(i),cc(i),result3)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=summtc+result2
           IF (TK.LT.T0) THEN
            NTSNOWR(K) =  NTSNOWR(K) + FN(I)*RESULT1
            MTSNOWR(K) =  MTSNOWR(K) + FQ(I)*RESULT3
           ELSE
            MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I))*RESULT3)
           ENDIF
 280    CONTINUE
       ENDIF
       i1=yk(k+1)
       xa=m(i1)
       xf=y(k+1)
       CALL integral1(xf,xa,bc(i1),ac(i1),result1)
       CALL integral2(xf,xa,dc(i1),cc(i1),tau(i1),result2)
       CALL integral1(xf,xa,dc(i1),cc(i1),result3)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
         RESULT1=0.d0
         RESULT2=0.d0
         RESULT3=0.d0
       ENDIF
       ntcir(K)=sumntc+result1
       mtcir(K)=summtc+result2
       IF ( TK.LT.T0) THEN
        NTSNOWR(K) =  NTSNOWR(K) + FN(I1)*RESULT1
        MTSNOWR(K) =  MTSNOWR(K) + FQ(I1)*RESULT3
       ELSE
        MTSNOWM(K)=MTSNOWM(K)+MAX(0.d0,RESULT2-(1.0-FQSM(I1))*RESULT3)
       ENDIF
      if (ibug.eq.1) then
      write(*,*)'12 result1,result2,result3',result1,result2,            &
     &   result3
       write(*,*) 'dm',result2-result3
      endif
 260  CONTINUE
!     end of calculation of the diffusional growth of the snow flake crystals
 400  CONTINUE
      RETURN
      END SUBROUTINE COND2

!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!
!      This subroutinu calculates the depositional growth of  graupel particles
!      If the temperature is larger than 0C, it is supposed that the graupel 
!      particels are covered by a thin water layer, so in this case the vapor
!      diffusion increase or decrease only the the mass of the liquid layer.

      SUBROUTINE DEPOS(K4,kmingra0,kmaxgra0,summgra,sumngra,             &
     &          agra,bgra,cgra,dgra,dsntgra,dsmtgra,FQGRAM,              &
     &          p,tk,qv,rhoa,ld,kg,diff,visc,errorq,sdep,dtime,ibug)

      IMPLICIT NONE
      INTEGER K4,kmingra0,kmaxgra0,ibug
      REAL dsntgra,dsmtgra,summgra,sumngra,errorq,sdep,dtime
      REAL*8 agra(K4),bgra(K4),cgra(K4),dgra(K4)
      REAL*8 FQGRAM(K4)
      real tk,p,qv,ld,KG,DIFF

      REAL*8 tau(40),taugra(40),y(40)
      REAL*8 kszi,kszi2,DMTTI,mmean,mmean1,m2,mmingra0,mmingra,          &
     &       mmaxgra0,mmaxgra,SEGMIN,SEGMAX,SSUMGRA2,SEG,SEG1,DTIMEV,    &
     &       SUMNTC,SUMMTC,XA,XF,RESULT1,RESULT2,RESULT3,SUMMGRAM
      REAL dsmtgram,DELTAQGRA,DELTANGRA,DELTAQGRAM
      REAL KHI,EIS,EV,QIS1,SATSSI,SS11,BIPT,CPTI1,CPTI2,FV,    &
     &     SEGD
      REAL REYN,visc,rhoa
      INTEGER K,YK(40),IK,I,I1,I2,KMIN,KMIN0,KMAX,KMAX0,INTERV
      errorq=0.0
      sdep=0.0
       
      summgram=0.0
      do k=1,36
       summgram = summgram + mtgram(k)
      enddo

       if (ibug.eq.1) then
        write(99,*) 'start in depos'
        write(99,*) 'errorq,sdep',errorq,sdep
        write(99,*) 'kmingra0,kmaxgra0',kmingra0,kmaxgra0
        write(99,*) 'tk,p,qv,ld,kg,diff,visc,rhoa,rgv,rogr'
        write(99,*) tk,p,qv,ld,kg,diff,visc,rhoa,rgv,rogr
        write(98,*) 'in depos'
        do k =1,36
         write(98,*) 'k,nt,mt',ntgra(k),mtgra(k),mtgram(k)
        enddo
        write(98,*) 'qgra, ngra, qgram',summgra,sumngra,summgram
       endif

      kszi=0.984065478d0          !   0.950d0       0.968130959d0      ! p=2 and delta=1/3
      kszi2=0.984122918d0             !   0.9682458368d0                 ! p=2  and delta=0.5
      dtimev=dtime
!      eis=dexp((28.289d0*tk-6024.33d0)/(tk-7.66d0))
      EIS = EXP(23.33086-6111.72784/tk+0.15215*log(tk))*100.
      IF (tk.gt.t0) THEN
       eis=610.24d0                 ! vapor saturation at temperature 0 C.
      ENDIF
      qis1=0.622d0*eis/p
      ev=qv*p/.622d0
      satssi=qv/qis1-1.0
      ss11=0.622d0/(rgv*cp*p*tk*tk)
      bipt=1.d0+ss11*ld*ld*eis
      cpti1=4.d0*pi
      cpti2=cpti1/(rgv*tk/DIFF/eis+ld/(tk*kg)*(ld/(rgv*tk)-1.d0))                    !  /qis1
      ssumgra2=0.d0
!       ibug=0
      SEGD=(3.d0/(ROGR*4.d0*PI))**0.333333
      SEG1=SATSSI*CPTI2*SEGD*DTIME
       if (ibug .eq.1) then
        write(99,*) 'start calc taus,sumngra,summgra',sumngra,summgra
        write(99,*) 'seg1,satssi,cpti2,segd,nsch1,dtime'
        write(99,*) seg1,satssi,cpti2,segd,nsch1,dtime
       endif

      DO 5 k=1,k4
       taugra(K)=0.d0
       mmean1=m(K)
!       calculation of the parameter tauv for diffusional growth of the graupel particles
       IF (ntgra(K).gt.1.d-100) THEN
        mmean=mtgra(K)/ntgra(K)
       ELSE
        mmean=m(K)
       ENDIF
       if (ibug.eq.1) then
         write(99,*) 'k,mmean',k,mmean
       endif
       IF (MMEAN.LT.0.d0) MMEAN=0.d0
!        IF(mmean.LT.m(K)) mmean=m(K)
!        IF (mmean.gt.m(k+1)) mmean=m(k+1)
       CALL reynh(mmean1,reyn,visc,rhoa)
       fv=0.78d0+0.308d0*nsch1*sqrt(reyn)
!        fv=1.0
       taugra(K)=SEG1*FV
       ssumgra2=ssumgra2+taugra(K)*mmean**(1.d0/3.d0)*ntgra(K)
       if (ibug.eq.1) then
        write(99,*) 'k,mmean1,mmean,seg1,fv,reyn'
        write(99,*) k,mmean1,mmean,seg1,fv,reyn
       endif
 5    CONTINUE
      if (ibug .eq.1) then
        write(99,*) 'after calc taus,ssumgra2,kszi',ssumgra2,kszi
       endif
      DMTTI=KSZI*SSUMGRA2
!
!       calculation of the diffusional  grotwh of graupel particles

      IF (SUMNGRA .LT. 1e-15 .OR. (DMTTI+SUMMGRA .LT. 0.0)) THEN
       DO K=1,K4
         NTGRA(K)=0.0d0
         MTGRA(K)=0.0d0
         MTGRAM(K)=0.d0
       ENDDO
       GOTO 400
      ENDIF
      kmin0=kmingra0
      kmax0=kmaxgra0
      mmingra0=m(kmin0)
      mmaxgra0=m(kmax0+1)
      do 210 k=1,k4
       y(K)=0.d0
       yk(K)=0
!       tau(K)=taui*taugra(K)
        tau(K)=taugra(K)
        if (ibug == 1) then
          write(99,*) 'k,tau,fqgram',k,tau(k),fqgram(k)
        endif
 210  CONTINUE
      if (ibug ==1) then
        write(99,*) 'start calc segmin'
       endif
      segmin=m(1)**(2.d0/3.d0)
      segmax=m(k4+1)**(2.d0/3.d0)
      if (ibug ==1) then
        write(99,*) ' calc segmin,mmingra0,mmaxgra0',segmin,              &
     &                                   segmax,mmingra0,mmaxgra0
        write(99,*) 'kmin0,kmax0',kmin0,kmax0
       endif

!      tau=0.d0
      mmingra=mmingra0**(2.d0/3.d0)+2.d0/3.d0*tau(kmin0)
      if (ibug ==1) then
        write(99,*) ' calc mmingra,m(2)',mmingra,m(2)
       endif

      IF (mmingra.LT.segmin) THEN
       mmingra=m(1)
      else
       mmingra=mmingra**(3.d0/2.d0)
      ENDIF
      mmaxgra=mmaxgra0**(2.d0/3.d0)+2.d0/3.d0*tau(kmax0)
      IF (MMAXGRA < SEGMIN ) THEN
!      IF (MMAXGRA < 0.0 ) THEN
         DO K = 1, K4
           NTGRA(K)= 0.d0
           MTGRA(K)= 0.d0
           MTGRAM(K)=0.d0
         ENDDO
         GOTO 400
      ENDIF
      if (ibug ==1) then
        write(99,*) ' calc mmaxgra,m(k4)',mmaxgra,m(36)
       endif
      IF (mmaxgra.gt.segmax) THEN
       mmaxgra=m(k4+1)
      else
       mmaxgra=mmaxgra**(3.d0/2.d0)
      ENDIF
      IF (mmingra.LT.m(2)) THEN
       kmin=1
       GOTO 218
      ENDIF
      kmin=0
 213  continue
      kmin=kmin+1
      if(kmin.eq.37) goto 214
      IF(mmingra.ge.m(kmin)) GOTO 213
 214  continue
      kmin=kmin-1
 218  continue
      IF (mmaxgra.gt.m(k4-1)) THEN
       kmax=k4-1
!218     IF (mmaxgra.gt.m(k4)) THEN
!       kmax=k4
       GOTO 219
      ENDIF
      kmax=kmin
 215  continue
      kmax=kmax+1
      if(kmax.eq.37) goto 216
      IF (mmaxgra.ge.m(kmax)) GOTO 215
 216  continue
       kmax=kmax-1
!
!      calculation of the  intervals where yk and yk+1 are
!

 219  continue
      IF (dmtti > 0.d0) THEN     ! the graupel particles  grow by deposition
       if (ibug ==1) then
        write(99,*) 'satrt calc  yk,dmtti,kmin,kmax',                     &
     &                                      dmtti,kmin,kmax
       endif
       do 240 k=kmin,k4
        ik=k-1
        IF (ik.LT.1) ik=1
        seg=m(K)**(2.d0/3.d0)-2.d0/3.d0*tau(ik)
        IF (seg.LT.segmin) THEN
!         yk(K)=0
          YK(K) = 1           ! was modified on 22 08 2008 to be consitent with the code in subroutine COND2
         IF (seg.LT.0.d0) THEN
           y(K)=0.d0
         else
           y(K)=seg**(3.d0/2.d0)
         ENDIF
         IF (K > KMIN) THEN    ! was modified on 22 08 2008 explanation see above
           YK(K) = 1
           Y(K) = M(1)
         ENDIF
         GOTO 240
        ENDIF
        seg=seg**(3.d0/2.d0)
        i=k+1
 245    continue
        i=i-1
        if(i.eq.1) goto 246
        IF ((m(i)-seg).gt.0.d0) GOTO 245
 246    continue
        IF (seg.LT.mmingra0) THEN
           seg=mmingra0
           i=kmin0
        ENDIF
        yk(K)=i
        y(K)=seg
 240    CONTINUE
      ELSE                         !sublimation
       if (ibug ==1) then
        write(99,*) 'start calc  yk,dmtti',dmtti,kmin,kmax
       endif
       do 250 k=1,kmax
        ik=k+1
        IF (ik.gt.kmax) ik=kmax
        seg=m(K)**(2.d0/3.d0)-2.d0/3.d0*tau(ik)
        IF (seg.gt.segmax) THEN
         yk(K)=k4
         y(K)=seg**(3.d0/2.d0)
         GOTO 250
        ENDIF
        seg=seg**(3.d0/2.d0)
        i=k
 255    continue
        i=i+1
        if(i.eq.37) goto 256
        IF ((m(i)-seg).LT.0.d0) GOTO 255
 256    continue
        yk(K)=i-1
        y(K)=seg
 250    CONTINUE
      ENDIF
      IF (y(kmin).LT.mmingra0) THEN
        y(kmin)=mmingra0
        yk(kmin)=kmin0
      ENDIF
      IF (y(kmax+1).LT.mmaxgra0) THEN
        y(kmax+1)=mmaxgra0
        yk(kmax+1)=kmax0        !+1   was modified on 22 08 2008
      ENDIF

!      calculation of the new value of graupel concentration and first moment (mixing ratio)
!
!  calculation of the mass and concentration of the totally sublimated particles
      IF(dmtti.LT.0.d0.and.mmingra.eq.m(1)) THEN
       mmingra0=y(1)
       kmin0=yk(1)
      ENDIF
      do k=1,k4
       mtgra(K)=0.d0
       ntgra(K)=0.d0
       MTGRAM(K)=0.d0
       if (ibug == 1) then
         write(98,*) 'k,y,yk',k,y(k),yk(k)
       endif
      ENDDO
      seg=0.0
      seg1=0.0
      do 260 k=kmin,kmax
       sumntc=0.d0
       summtc=0.d0
       RESULT1=0.d0
       RESULT2=0.d0
       RESULT3=0.d0
       IF (y(K).gt.mmaxgra0.OR.y(k+1).LT.mmingra0) GOTO 260
!          diffusional growth at lower boundary of the size distribution
       IF (k.eq.kmin) THEN
        IF(kmin0.eq.yk(k+1)) THEN
         xa=mmingra0
         xf=y(k+1)
         CALL integral1(xf,xa,bgra(kmin0),agra(kmin0),result1)
         CALL integral2(xf,xa,dgra(kmin0),cgra(kmin0),tau(kmin0),        &
     &                  RESULT2)
         IF (TK > T0) THEN
          CALL integral1(xf,xa,DGRA(KMIN0),CGRA(KMIN0),RESULT3)
         ENDIF
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
         ENDIF
         ntgra(K)=result1
         mtgra(K)=result2
         IF (TK > T0) THEN
!           MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(KMIN0))*RESULT3
           MTGRAM(K)=RESULT2-(1.0-FQGRAM(KMIN0))*RESULT3
         ENDIF
         if (ibug.eq.1) then
          write(99,*) '1,k,result2,result3',k,result2,result3
          write(99,*)'dm',result2-result3
          seg=seg+result3
          seg1=seg1+result2
         endif
         GOTO 260
        ENDIF
        xa=mmingra0
        xf=m(kmin0+1)
        CALL integral1(xf,xa,bgra(kmin0),agra(kmin0),result1)
        CALL integral2(xf,xa,dgra(kmin0),cgra(kmin0),tau(kmin0),RESULT2)
        IF (TK > T0) THEN
         CALL integral1(xf,xa,DGRA(KMIN0),CGRA(KMIN0),RESULT3)
        ENDIF
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
            RESULT1=0.d0
            RESULT2=0.d0
            RESULT3=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        IF (TK > T0) THEN
         IF (FQGRAM(KMIN0).GT.0.0) THEN
          MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(KMIN0))*RESULT3
         ENDIF
        ENDIF
         if (ibug.eq.1) then
          write(99,*) '2,k,result2,result3',k,result2,result3
          write(99,*)'dm',result2-result3
          write(99,*)'mtgram,mtgra',mtgram(k),summtc
          seg=seg+result3
          seg1=seg1+result2
         endif

        interv=yk(k+1)-kmin0
        IF (interv.gt.1) THEN
         do 265 i=kmin0+1,yk(k+1)-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bgra(i),agra(i),result1)
           CALL integral2(xf,xa,dgra(i),cgra(i),tau(i),result2)
           CALL integral1(xf,xa,DGRA(I),CGRA(I),RESULT3)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
              RESULT1=0.d0
              RESULT2=0.d0
              RESULT3=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=result2+summtc
           IF (TK > T0) THEN
            IF (FQGRAM(I).GT.0.0) THEN
             MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I))*RESULT3
            ENDIF
           ENDIF
         if (ibug.eq.1) then
          write(99,*) '3,k,result2,result3',k,result2,result3
          write(99,*)'dm',result2-result3
          write(99,*)'mtgram,mtgra',mtgram(k),summtc
          seg=seg+result3
          seg1=seg1+result2
         endif
 265     CONTINUE
        ENDIF
        i1=yk(k+1)
        xa=m(i1)
        xf=y(k+1)
        IF (XA >= XF) GOTO 266
        CALL integral1(xf,xa,bgra(i1),agra(i1),result1)
        CALL integral2(xf,xa,dgra(i1),cgra(i1),tau(i1),RESULT2)
        CALL integral1(xf,xa,DGRA(I1),CGRA(I1),RESULT3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
        ENDIF
 266    CONTINUE
        ntgra(K)=sumntc+result1
        mtgra(K)=summtc+result2
        IF (TK > T0) THEN
          MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I1))*RESULT3
        ENDIF
         if (ibug.eq.1) then
          write(99,*) '4,k,result2,result3',k,result2,result3
          write(99,*)'dm',result2-result3
          write(99,*)'mtgram,mtgra',mtgram(k),mtgra(k)
          seg=seg+result3
          seg1=seg1+result2
         endif
        GOTO 260
       ENDIF                           ! end of calculation at the lower boundary
!         diffusional growth at the upper boundary
       IF (k.eq.kmax) THEN
        IF(kmax0.eq.yk(kmax)) THEN
         xa=y(kmax)
         xf=mmaxgra0
         CALL integral1(xf,xa,bgra(kmax0),agra(kmax0),result1)
         CALL integral2(xf,xa,dgra(kmax0),cgra(kmax0),tau(kmax0),        &
     &                  RESULT2)
         CALL integral1(xf,xa,dgra(kmax0),cgra(kmax0),RESULT3)
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
         ENDIF
         ntgra(K)=result1
         mtgra(K)=result2
         IF (TK > T0) THEN
!          MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(KMAX0))*RESULT3
          MTGRAM(K)=RESULT2-(1.0-FQGRAM(KMAX0))*RESULT3
         ENDIF
         if (ibug.eq.1) then
          write(99,*) '5,k,result2,result3',k,result2,result3
          write(99,*)'dm',result2-result3
          write(99,*)'mtgram,mtgra',mtgram(k),mtgra(k)
          seg=seg+result3
          seg1=seg1+result2
         endif
         GOTO 260
        ENDIF
        xa=m(kmax0)
        xf=mmaxgra0
        CALL integral1(xf,xa,bgra(kmax0),agra(kmax0),result1)
        CALL integral2(xf,xa,dgra(kmax0),cgra(kmax0),tau(kmax0),result2)
        CALL integral1(xf,xa,dgra(kmax0),cgra(kmax0),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
        ENDIF
        sumntc=result1
        summtc=result2
        IF (TK > T0) THEN
          MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(KMAX0))*RESULT3
        ENDIF
        if (ibug.eq.1) then
           write(99,*) '6,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),result2
           seg=seg+result3
           seg1=seg1+result2
        endif
        interv=kmax0-yk(kmax)
        IF (interv.gt.1) THEN
          do 270 i=yk(kmax)+1,kmax0-1
           i2=i+1
           xa=m(i)
           xf=m(i2)
           CALL integral1(xf,xa,bgra(i),agra(i),result1)
           CALL integral2(xf,xa,dgra(i),cgra(i),tau(i),result2)
           CALL integral1(xf,xa,dgra(i),cgra(i),result3)
           IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
             RESULT1=0.d0
             RESULT2=0.d0
             RESULT3=0.d0
           ENDIF
           sumntc=sumntc+result1
           summtc=summtc+result2
           IF (TK > T0) THEN
            MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I))*RESULT3
           ENDIF
           if (ibug.eq.1) then
           write(99,*) '7,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),summtc
           seg=seg+result3
           seg1=seg1+result2
            endif
 270      CONTINUE
        ENDIF
        i1=yk(K)
        i2=yk(K)+1
        xa=y(K)
        xf=m(i2)
        CALL integral1(xf,xa,bgra(i1),agra(i1),result1)
        CALL integral2(xf,xa,dgra(i1),cgra(i1),tau(i1),result2)
        CALL integral1(xf,xa,dgra(i1),cgra(i1),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
        ENDIF
        ntgra(K)=sumntc+result1
        mtgra(K)=summtc+result2
        IF (TK > T0) THEN
         MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I1))*RESULT3
        ENDIF
        if (ibug.eq.1) then
           write(99,*) '8,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),mtgra(k)
           seg=seg+result3
           seg1=seg1+result2
        endif
        GOTO 260
       ENDIF                            ! end of the calculation at the upper boundary
!      diffusional growth inside of the size distribution
       interv=yk(k+1)-yk(K)
       IF (interv.eq.0) THEN
        i1=yk(K)
        xa=y(K)
        xf=y(k+1)
        CALL integral1(xf,xa,bgra(i1),agra(i1),result1)
        CALL integral2(xf,xa,dgra(i1),cgra(i1),tau(i1),result2)
        CALL integral1(xf,xa,dgra(i1),cgra(i1),result3)
        IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
         RESULT1=0.d0
         RESULT2=0.d0
         RESULT3=0.d0
        ENDIF
        ntgra(K)=result1
        mtgra(K)=result2
        IF (TK > T0) THEN
!         MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I1))*RESULT3
         MTGRAM(K)=RESULT2-(1.0-FQGRAM(I1))*RESULT3
        ENDIF
        if (ibug.eq.1) then
           write(99,*) '9,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),mtgra(k)
           seg=seg+result3
           seg1=seg1+result2
        endif
        GOTO 260
       ENDIF
       i1=yk(K)
       i2=yk(K)+1
       xa=y(K)
       xf=m(i2)
       CALL integral1(xf,xa,bgra(i1),agra(i1),result1)
       CALL integral2(xf,xa,dgra(i1),cgra(i1),tau(i1),result2)
       CALL integral1(xf,xa,dgra(i1),cgra(i1),result3)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
       ENDIF
       sumntc=result1
       summtc=result2
       IF (TK > T0) THEN
        MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I1))*RESULT3
       ENDIF
       if (ibug.eq.1) then
           write(99,*) '10,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),summtc
           seg=seg+result3
           seg1=seg1+result2
       endif
       IF (interv.gt.1) THEN
        do 280 i=yk(K)+1,yk(k+1)-1
         i2=i+1
         xa=m(i)
         xf=m(i2)
         CALL integral1(xf,xa,bgra(i),agra(i),result1)
         CALL integral2(xf,xa,dgra(i),cgra(i),tau(i),result2)
         CALL integral1(xf,xa,dgra(i),cgra(i),result3)
         IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
              RESULT1=0.d0
              RESULT2=0.d0
              RESULT3=0.d0
         ENDIF
         sumntc=sumntc+result1
         summtc=summtc+result2
         IF (TK > T0) THEN
          MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I))*RESULT3
         ENDIF
         if (ibug.eq.1) then
           write(99,*) '11,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),summtc
           seg=seg+result3
           seg1=seg1+result2
         endif
 280    CONTINUE
       ENDIF
       i1=yk(k+1)
       xa=m(i1)
       xf=y(k+1)
       CALL integral1(xf,xa,bgra(i1),agra(i1),result1)
       CALL integral2(xf,xa,dgra(i1),cgra(i1),tau(i1),result2)
       CALL integral1(xf,xa,dgra(i1),cgra(i1),result3)
       IF (RESULT1.LT.0.d0.OR.RESULT2.LT.0.d0) THEN
           RESULT1=0.d0
           RESULT2=0.d0
           RESULT3=0.d0
       ENDIF
       ntgra(K)=sumntc+result1
       mtgra(K)=summtc+result2
       IF (TK > T0) THEN
        MTGRAM(K)=MTGRAM(K)+RESULT2-(1.0-FQGRAM(I1))*RESULT3
       ENDIF
       if (ibug.eq.1) then
           write(99,*) '12,result2,result3',result2,result3
           write(99,*) 'dm',result2-result3
           write(99,*)'mtgram,mtgra',mtgram(k),mtgra(k)
           seg=seg+result3
           seg1=seg1+result2
       endif
 260   CONTINUE
!               end for graupel
 400   CONTINUE
!
!  correction if the analitycal values and the numerical values are different  
!
      deltaqgra=0.d0
      deltangra=0.d0
      deltaqgram=0.d0
      DO k=1,k4
        deltangra=deltangra+ntgra(K)
        deltaqgra=deltaqgra+mtgra(K)
        deltaqgram=deltaqgram+mtgram(k)
      ENDDO
      dsntgra=deltangra-sumngra
      dsmtgra=deltaqgra-summgra
      dsmtgram=deltaqgram-summgram
      IF (DELTAQGRA.GT.0.0) THEN
       SEG = (DMTTI-DSMTGRA)/DELTAQGRA
      ELSE
       SEG=0.0
      ENDIF
      DO K=1,K4
       MTGRA(K)=MTGRA(K) + SEG*MTGRA(K)
       MTGRAM(K)=MTGRAM(K) + SEG*MTGRAM(K)
      ENDDO
!   end of correction
      deltaqgra=0.d0
      deltangra=0.d0
      deltaqgram=0.d0
      do 410 k=1,k4
        deltangra=deltangra+ntgra(K)
        deltaqgra=deltaqgra+mtgra(K)
        deltaqgram=deltaqgram+mtgram(k)
 410  CONTINUE
      dsntgra=deltangra-sumngra
      dsmtgra=deltaqgra-summgra
      dsmtgram=deltaqgram-summgram
      errorq=errorq+dabs(dsmtgra-dmtti)
      sdep=sdep+dabs(dmtti)
      if (ibug ==1) then
        write(99,*) 'at the and of depos '
        write(99,*) 'dsntgra,dsmtgra,dsmtgram,dmtti',                     &
     &        dsntgra,dsmtgra,dsmtgram,dmtti
        write(99,*) 'sum res3, sum res2 dres',seg,seg1,seg1-seg
        write(99,*) 'summgra,deltaqgra',summgra,deltaqgra
        write(99,*) 'errorq,sdep',errorq,sdep
       endif
      RETURN
      END SUBROUTINE DEPOS

!----+------------------------------------------------------------------+
!
!.. Analytical integral of the function (x**(2/3)+2/3*tau)**(3/2)/x

      DOUBLE PRECISION function f1(x,tau)
      real*8 x,tau,seg0,seg1,seg2,seg3,seg4
      seg0=9.d0*x**(2.d0/3.d0)+6.d0*tau
      IF (seg0.LT.0.d0) THEN
       seg1=dsqrt(-6.d0*tau)
       f1=2.d0/3.d0*tau*seg1*3.14159d0/2.d0
       return
      else
       seg2=dsqrt(seg0)
      ENDIF
      IF (tau.gt.0.d0) THEN
       seg1=dsqrt(6.d0*tau)
       seg3=seg1/seg2
       seg4=seg1*0.5d0*dlog((1.d0+seg3)/(1.d0-seg3))
       f1=seg2**3.d0/27.d0+2.d0/3.d0*tau*(seg2-seg4)
      else
       seg1=dsqrt(-6.d0*tau)
       f1=seg2**3.d0/27.d0+2.d0/3.d0*tau*(seg2+seg1*datan(seg1/seg2))
      ENDIF
      return
      END function f1

!----+------------------------------------------------------------------+
!.. Analytical integral of the function (x**(2/3)+2/3*tau)**(3/2)      

      DOUBLE PRECISION function f2(x,tau)
      real*8 x,tau,seg0,seg1,seg2,seg3,seg4
      seg1=x**(1.d0/3.d0)
      seg0=9.d0*seg1**2.d0+6.d0*tau
      IF (seg0.LT.0.d0) seg0=0.d0
      seg2=dsqrt(seg0)
      seg3=seg1*seg2**5.d0/486.d0-tau*seg1*seg2**3.d0/324.d0-            &
     &      tau*tau*seg1*seg2/36.d0
      IF (tau.gt.0.d0) THEN
       seg4=0.5d0*dsqrt(6.d0/tau)*seg1
       f2=seg3-tau**3.d0/18.d0*dlog(seg4+dsqrt(seg4+1.d0))
      ELSE
       f2=seg3-tau**3.d0*dlog(3.d0*seg1+seg2)/18.d0
      ENDIF
      return
      END function f2
!        integral of the function (x**0.5+0.5*tau)**2/x
      DOUBLE PRECISION function g1(x,tau)
      DOUBLE PRECISION x,tau
      g1=x+tau*(2.d0*dsqrt(x)+0.25d0*tau*dlog(x))
      RETURN
      END function g1
!        integral of the function (x**0.5+0.5*tau)**2
      DOUBLE PRECISION function g2(x,tau)
      DOUBLE PRECISION x,tau
      g2=x*(0.5d0*x+tau*(2.d0*dsqrt(x)/3.d0+0.25d0*tau))
      RETURN
      END function g2

!----+------------------------------------------------------------------+

      SUBROUTINE integral1(xf,xa,b,a,result)
      real*8 xf, xa, b, a, result
      result=(xf-xa)*(a+(xf+xa)/2.d0*b)
      return
      end SUBROUTINE integral1
      SUBROUTINE integral2(xf,xa,d,c,tau,result)
      real*8 xf, xa, d, c, tau, result, segc, segd
!      external f1,f2
       segd=(f2(xf,tau)-f2(xa,tau))
       segc=(f1(xf,tau)-f1(xa,tau))
       result=segd*d+segc*c
      return
      end SUBROUTINE integral2
      SUBROUTINE integral4(xf,xa,d,c,tau,result)
      real*8 xf, xa, d, c, tau, result, segc, segd
!      external g1,g2
      segc=g1(xf,tau)-g1(xa,tau)
      segd=g2(xf,tau)-g2(xa,tau)
      result=segd*d+segc*c
      RETURN
      END SUBROUTINE integral4
      
!----+------------------------------------------------------------------+
!.. Calculation a, b, c and d coeffs from the function nt(m) and mt(m)

      SUBROUTINE COEF1 (K4,A,B,C,D,MT,NT,KMIN,KMAX,SUMMA)

      IMPLICIT NONE
      INTEGER K4, KMIN, KMAX
      DOUBLE PRECISION A(K4),B(K4),C(K4),D(K4),MT(K4),NT(K4)
      REAL SUMMA
      double precision xmean,f,fv,phi,phiv
      INTEGER K, maxflagc, minflagc

!----+

      KMIN=1
      KMAX=k4
      maxflagc=0
      minflagc=0
      DO 10 K=1,K4
       A(K)=0.d0
       B(K)=0.d0
       C(K)=0.d0
       D(K)=0.d0
       IF (nt(K).GT.1d-150.AND.minflagc.EQ.0) THEN
        kmin=k
        minflagc=1
       ENDIF
       IF (nt(K).LT.1d-150.and.maxflagc.EQ.0) THEN
        kmax=k
        maxflagc=1
       ENDIF
       IF (NT(K).GE.1d-150) maxflagc=0
 10        CONTINUE
      IF (NT(K4).GE.1d-150) kmax=K4
      kmax=kmax-1
      IF (SUMMA.LT.1.d-20) THEN
       RETURN
      ENDIF
      DO 50 K=1,K4
       IF(NT(K).GT.0.d0.AND.MT(K).GT.0.d0) xmean=MT(K)/NT(K)
       IF(NT(K).LE.0.d0.OR.MT(K).LE.0.d0)  GOTO 50
       IF (xmean.LT.M(K)) THEN
         f=2.d0*nt(K)/M(K)
         fv=2.d0*mt(K)/M(K)/M(K)
!         fv=f
         phi=0.d0
         phiv=0.d0
         GOTO 30
       ENDIF
       IF (xmean.GT.m(k+1)) THEN
         f=0.d0
         phi=2.d0*nt(K)/m(K)
         fv=0.d0
         phiv=2.d0*mt(K)/m(k+1)/m(K)
!         phiv=phi
         GOTO 30
       ENDIF
       f=2.d0*nt(K)/m(K)*(pk-xmean/m(K))
       phi=2.d0*nt(K)/m(K)*(xmean/m(K)-1.d0)
       fv=f
       phiv=phi
 30    continue
       a(K)=(pk*f-phi)
       b(K)=(phi-f)/m(K)
       c(K)=(fv-phiv)*m(k+1)
       d(K)=(pk*phiv-fv)
 50   CONTINUE      
      RETURN
      END SUBROUTINE COEF1

!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!.. Calculates the gravitational collection rate of micron size particles
!
!       (The correction term 0.893/roa means that collection efficiency was calculated at
!        p=700mb and t=0 C and the precalculation showed that this simple correction gives
!        an practically good approximation for the collection efficiency at other levels,
!        roa is the air density at the actual level.)
!
      SUBROUTINE gravcoag(k4,a,b,c,d,dntc,dmtc,c6,roa)

      IMPLICIT NONE
      INTEGER K4
      DOUBLE PRECISION a(k4),b(k4),c(k4),d(k4),dntc(k4),dmtc(k4)
      REAL (KIND=R8SIZE) :: c6(36,6)
      REAL roa
      integer k

      DO  K = 1,k4
       dntc(K)=(a(K)*c6(k,5)+b(K)*c6(k,6))*0.893/roa
       dmtc(K)=(c(K)*c6(k,5)+d(K)*c6(k,6))*0.893/roa
      ENDDO
      END SUBROUTINE gravcoag

!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!.. This subroutine calculates the immersional freezing rate of the
!.. supercooloed droplets. The immersional freezing rate is approximated
!.. by the Bigg formula. The drops smaller than 100 um are assigned to
!.. the ice crystals, the larger are transferred to the hail particles.
!.. Change by G. Thompson (29 Feb 2008) for diameters larger than
!.. 184 microns freeze into graupel/hail.  Original code had 50 microns
!.. contrary to comment above.

      SUBROUTINE freezingi(K4,NTC1,MTC1,dntci1,dmtci1,dnth0,dmth0,dtime, P,TK,qv)

      IMPLICIT NONE
      INTEGER K4
      REAL*8 dnth0(k4),dmth0(k4),dntci1(k4),dmtci1(k4),NTC1(K4),MTC1(K4)
      real dtime, tk,p,qv
      real deltat, prob, mmean
      double precision rmean, dnf, dmf
      integer k
      double precision, parameter :: rseg = (3.d0/(1000.d0*PI*4.d0))**0.3333d0
      real, parameter :: aa = 100.0
      real, parameter :: bb = 0.66

!----+

!  if the temperature less than -35 C, all of the liquid drops will be frozen and pristine ice particles form
      IF (TK < 238.0) THEN
       DO K = 1, K4
        DNTCI1(K) = NTC1(K)/DTIME
        DMTCI1(K) = MTC1(K)/DTIME
       ENDDO
       RETURN
      ENDIF

!  if temperature larger than -5 C, no immersional freezing
      IF (TK > 268.0) THEN
       RETURN
      ENDIF
      deltat=273.15-tk

      DO 10 K=1,k4
        IF (ntc1(K).LT.1d-10) GOTO 10
         mmean=mtc1(K)/ntc1(K)
         IF (mmean.LT.m(K)) mmean=m(K)
         IF (mmean.gt.m(k+1)) mmean=m(k+1)
         rmean=rseg*mmean**0.33333d0
!!-G Thompson
!! The original equation below does not match Biggs (1953).  Probability of
!! 1.0 mm drop freezing at roughly -24C should be 57 percent but eqn below
!! is Chester Wisner (1972) adaptation and produces lower probabilities
!! than original Biggs.  The smaller drops, the Wisner method produces much
!! too low probabilities.
!         dnf=ntc1(K)*(1.d0-dexp(-mmean/1000.d0*aa*exp(bb*deltat)*dtime))

         prob=1.d0-dexp(-mmean/1000.d0*120.0D0*5.2D-4*dexp(deltat*1.0d0)*dtime)
         prob = min(1.0, max(0.0, prob))
         dnf=ntc1(K)*prob
         dmf=dnf*mmean
!!-GT    IF (rmean.LT.2.5d-5) THEN
!! With change above, dnf and dmf are already time rates of change so
!! do not divide by dtime any longer.
! xue should /dtime be removed?
!         IF (rmean.LT. 92.0d-6) THEN
         IF (rmean.LT. 25.0d-6) THEN
           dntci1(K)=dnf/dtime
           dmtci1(K)=dmf/dtime
         ELSE
           dnth0(K)=dnf/dtime
           dmth0(K)=dmf/dtime
         ENDIF
 10   CONTINUE
      RETURN
      END SUBROUTINE freezingi
 
!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+

!.. Calculates the mean terminal velocity of drops in size interval

      SUBROUTINE veloc1(rx,v,roa)

      IMPLICIT NONE
      DOUBLE PRECISION rx
      real lamb,nre,nbo,nbo1,np,nst,nbe,roa,v
      real x1,y1,xv,visc,snre,seg1

! The terminal velocity of the drops are given by the book of Pruppacher and Klett p417-419
! All the parameters are given at temperature of 0 C and pressure of 700mb
! The terminal velocties are corrected by sqrt(roa(700mb)/roa(p)), the collision
! efficiencies are corrected by roa(700)/roa(p).
!  air density=0.893, viscosity=1.718*10**-5, sigma(surface tension)=75.93*10**-3

      seg1=0.0620350490               ! 1/(4/3*pi*1000)**(1/3)
      lamb=8.89919e-8
      nbe=3.163114206e14            ! Best num./rd**3 =32.d0*(row-roa)*roa*g/3d0/visc/visc 
      nbo=129082.5717e0               ! Bond number/rd**2 =  g*(row-roa)/sigma
      np=86.15124908              ! (sigma**3.d0*roa*roa/(visc**4*g*(row-roa)))**(1/6)
      snre=9.619260920e-6           ! visc/2/roa
      nst=1.267784202e8             ! 2./9./visc*(row-roa)*g
      visc=1.718e-5
      IF (rx.le.1d-5) THEN
       v=nst*rx*rx*(1.0+1.26*lamb/rx)
       GOTO 20
      ENDIF
      IF (rx.gt.1.d-5.and.rx.LT.535.d-6) THEN
       xv=rx**3*nbe
       x1=log(xv)
       y1=-3.186570+0.992696*x1-0.153193e-2*x1*x1-                       &
     &     0.987059e-3*x1*x1*x1-0.578878e-3*x1**4.0+                     &
     &     0.855176d-4*x1**5.0-0.327815e-5*x1**6.0
       nre=exp(y1)
       v=nre*snre/rx
       GOTO 20
      ENDIF
      IF (rx.gt.535.d-6.and.rx.LT.2.5d-3) THEN
       nbo1=nbo*rx*rx
       x1=log(16.0/3.0*nbo1*np)
       y1=-5.000150+5.23778*x1-2.04914*x1*x1+0.475294*x1**3-             &
     &  0.0542819*x1**4.0+0.002384490*x1**5.0
       nre=np*exp(y1)
       v=nre*snre/rx
       GOTO 20
      ENDIF
      IF (rx.gt.2.5d-3) THEN
       v=10.620
      ENDIF
 20   continue
      v=sqrt(0.8930/roa)*v
      RETURN
      END SUBROUTINE veloc1

!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+

      SUBROUTINE REYNH (MMEAN,REYN,visc,roa)

      IMPLICIT NONE
      REAL*8 MMEAN
      real REYN, visc, roa
      real x, w

      x=8.*mmean*9.8*roa/pi/visc**2.d0
      w=log10(x)
      IF (x.LT.73.0 ) THEN
       reyn=0.d0
       return
      ENDIF
!      IF (x.LT.562.0) THEN
!       reyn=-1.7095+1.33438*w-.011591*w*w
!       reyn=10.0**reyn
!       return
!      ENDIF
      IF (x.LT.1830.0) THEN
       reyn=-1.813910+1.3467*w-0.12427*w*w+0.0063*w*w*w
       reyn=10.0**reyn
       return
      ENDIF
      IF (x.LT.3.46e8) THEN
       reyn=0.4487*x**0.55360
       return
      ENDIF
      reyn=sqrt(x/0.60)
      RETURN
      END SUBROUTINE REYNH

!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!.. Radar reflectivity calculation subroutine
     subroutine reflbin(ncw,ngra,fqgr,nsnow,fqs,nic,t,dBZ,m,rdr,rhosnow)

      implicit none
      integer ibug
      real, intent(in)::  t
      real, intent(inout):: dBZ
      double precision m,temp
!      complex*16 m_complex_water_ray,m_complex_ice_maetzler
      complex*16 m_w,m_w0,m_i,m_i0,m_a,K_w,K_w0,K_i,K_i0,K_s1,K_s2,K_gr
      double precision pi5,lambda4,pk,rhosnow
      double precision,parameter:: pi=3.14159265358979d0
      double precision,parameter:: lambda_radar=0.10d0
!.. Variables for calculation of raindrop reflectivity
      double precision rdr
      real dr,rhow,ncw,xr
!.. Variables for calculation of graupel reflectivity
      real de,re,mmean,rhoice
      parameter (rhow=1000., rhoice=900)
      real rhogr,xgr,ngra,fqgr,rhgr
      parameter (rhogr=800.)
!.. Variables for calculation snowflake reflectivity
      real rhos,xs,nsnow,fqs
!.. Variables for calculation pristine ice reflectivity
      real nic
!.. Variables for equivalent radar reflectivity calculations
      real zk_rain,zk_gra,zk_snow,zk_ice
      real ze_rain,ze_gra,ze_snow,ze_ice
!.. Variables for wet particle reflectivity calculation
      integer bb
      real melt_outs,m_waters,vol_s,C_back_s
      real melt_outgr,m_watergr,vol_gr,C_back_gr
!+-----------------------------------------------------------------------------------+
!+-----------------------------------------------------------------------------------+
       ibug = 0
       ze_rain=0.0
       ze_snow=0.0
       ze_gra=0.0
       ze_ice=0.0
       lambda4=lambda_radar*lambda_radar*lambda_radar*lambda_radar
       pi5=pi*pi*pi*pi*pi
       zk_rain=0.0
       zk_gra=0.0
       zk_snow=0.0
       zk_ice=0.0
       mmean=0.0
       melt_outs=0.0
       m_waters=0.0
       vol_s=0.0
       C_back_s=0.0
       melt_outgr=0.0
       m_watergr=0.0
       vol_gr=0.0
       C_back_gr=0.0
       bb=1

!.. Calculation of refractive indices for different particles
       m_a=(1.0d0,0.0d0)
       m_w0 = m_complex_water_ray (lambda_radar, 0.0d0)
       m_i0 = m_complex_ice_maetzler (lambda_radar, 0.0d0)
       K_w0 =(ABS((m_w0*m_w0-1.0)/(m_w0*m_w0+2.0)))**2
       K_i0 =(ABS((m_i0*m_i0-1.0)/(m_i0*m_i0+2.0)))**2

       temp=t-273.15
       m_w = m_complex_water_ray (lambda_radar, temp)
       m_i = m_complex_ice_maetzler (lambda_radar, temp)
       K_w = (ABS((m_w*m_w-1.0)/(m_w*m_w+2.0)))**2
       K_i = (ABS((m_i*m_i-1.0)/(m_i*m_i+2.0)))**2

!.. Calculation of detailed microphyics parameters
!.. Such as diameters and axis ratios for all prt.
       pk=2.d0
       xr=(2.*pi/lambda_radar)*rdr
       dr=2*rdr    ! diameter in m
       mmean=1.5*m
       de = (6*mmean/pi/rhow)**(1./3.)
       re = de/2.0
       xgr=(2.*pi/lambda_radar)*re
       xs=(2.*pi/lambda_radar)*re
       vol_gr=mmean*rhogr
       rhgr=fqgr*1000 + (1-fqgr)*rhogr
       rhos=fqs*1000 + (1-fqs)*rhosnow
       vol_s=mmean*rhos
       K_s1=(rhos/rhoice)*K_i
       K_gr=fqgr*K_w+(1-fqgr)*K_i
       K_s2=fqs*K_w+(1-fqs)*K_i
       if (fqgr.gt.0.0) then
        melt_outgr=rhgr/1000
        m_watergr=mmean*fqgr
       else
        melt_outgr=0.0
        m_waters=0.0
       endif

       if (fqs.gt.0.0) then
         melt_outs=rhos/1000
         m_waters=mmean*fqs
       else
         melt_outs=0.0
         m_waters=0.0
       endif
!.. Calculation of different reflectivity for equivalent reflectivity
!.. Equivalent reflectivity for rain drops:
       if (ncw.gt.0.0) then
         zk_rain=ncw*(dr**6.0)*(K_w/K_w0)
       else
         zk_rain=0.0
       endif
!.. Calculation of different reflectivity for equivalent reflectivity
!.. Equivalent reflectivity for rain drops:
       if (nic.gt.0.0) then
         zk_ice=nic*(de**6.0)*(K_i/K_w0)
       else
         zk_ice=0.0
       endif

!.. Equivalent reflectivity for graupel particles:
       if (fqgr.eq.0.0) then   !dry ice particles
        if (ngra.gt.0.0) then
          zk_gra=ngra*(de**6.0)*(K_i/K_w0)
        else
          zk_gra=0.0
        endif
       else     ! wet ice particles
        if (ngra.gt.0.0) then
        call backscattering(mmean,fqgr,vol_gr,melt_outgr,de,m_w,m_i,m_a,   &
     &       lambda_radar,C_back_gr,bb)
          zk_gra=ngra*lambda4*C_back_gr/pi5/K_w0
!          zk_gra = ngra*(de**6.0)*(K_gr/K_w0)
        else
          zk_gra=0.0
        endif
       endif
!.. Equivalent reflectivity for snowflakes
       if (fqs.eq.0.0) then   !dry snowflakes
         if (nsnow.gt.0.0) then
          zk_snow= nsnow*(de**6.0)*(K_s1/K_w0)
         else
          zk_snow=0.0
         endif
       else     !wet snowflakes
         if (nsnow.gt.0.0) then
       call backscattering(mmean,fqs,vol_s,melt_outs,de,m_w,m_i,m_a,       &
     &      lambda_radar,C_back_s,bb)
          zk_snow= nsnow*lambda4*C_back_s/pi5/K_w0
!          zk_snow = nsnow*(de**6.0)*(K_s2/K_w0)
         else
           zk_snow = 0.0
         endif
       endif
!.. Summation over the bins:
        ze_rain=ze_rain+zk_rain
        ze_gra=ze_gra+zk_gra
        ze_snow=ze_snow+zk_snow
	ze_ice=ze_ice+zk_ice

! Equivalent radar reflectivity over all particle types and all bins
        dBZ = ze_rain+ze_gra+ze_snow+ze_ice

        return
        end subroutine reflbin
 
!+---+------------------------------------------------------------------+
!----+------------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!+----------------------------------------------------------------------+
      COMPLEX*16 FUNCTION m_complex_water_ray(lambda,T)
      IMPLICIT NONE
      DOUBLE PRECISION T,lambda
      DOUBLE PRECISION epsinf,epss,epsr,epsi
      DOUBLE PRECISION alpha,lambdas,nenner
      COMPLEX*16, PARAMETER:: i = (0d0,1d0)
      DOUBLE PRECISION, PARAMETER:: Pi=3.1415926535897932384626434d0

      epsinf  = 5.27137d0 + 0.02164740d0 * T - 0.00131198d0 * T*T
      epss    = 78.54d+0 * (1.0 - 4.579d-3 * (T - 25.0)    &
     &         + 1.190d-5 * (T - 25.0)*(T - 25.0)          &
     &         - 2.800d-8 * (T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha   = -16.8129d0/(T+273.16) + 0.0609265d0
      lambdas = 0.00033836d0 * exp(2513.98d0/(T+273.16)) * 1e-2

      nenner = 1.d0+2.d0*(lambdas/lambda)**(1d0-alpha)*sin(alpha*Pi*0.5)  &
     &        + (lambdas/lambda)**(2d0-2d0*alpha)
      epsr = epsinf + ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)     &
     &      * sin(alpha*Pi*0.5)+1d0)) / nenner
      epsi = ((epss-epsinf) * ((lambdas/lambda)**(1d0-alpha)   &
     &      * cos(alpha*Pi*0.5)+0d0)) / nenner                 &
     &      + lambda*1.25664/1.88496

      m_complex_water_ray = SQRT(CMPLX(epsr,-epsi))

      return
      END FUNCTION m_complex_water_ray
!+----------------------------------------------------------------------+
      COMPLEX*16 FUNCTION m_complex_ice_maetzler(lambda,T)

      IMPLICIT NONE
      DOUBLE PRECISION T,lambda
      DOUBLE PRECISION f,c,TK,B1,B2,b,deltabeta,betam,beta,theta,alfa

      c = 2.99d8
      TK = T + 273.16
      f = c / lambda * 1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = EXP(-10.02 + 0.0364*(TK-273.16))
      betam = (B1/TK) * ( EXP(b/TK) / ((EXP(b/TK)-1)**2) ) + B2*f*f
      beta = betam + deltabeta
      theta = 300. / TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta) * EXP(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK-273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler            &
     &                        + CMPLX(0.0d0, (alfa/f + beta*f))
      m_complex_ice_maetzler = SQRT(CONJG(m_complex_ice_maetzler))

      return
      END FUNCTION m_complex_ice_maetzler
!+----------------------------------------------------------------------+
!+----------------------------------------------------------------------+
SUBROUTINE read_in_bin(qw,qw_old,qi,qi_old, 	&
  &					   qs,qs_old,qg,qg_old, 	&
  &					   qsr,qsr_old,qsm,qsm_old, &
  &  				   qgm,qgm_old,nw,nw_old,   &
  &					   ni,ni_old,ns,ns_old,ng,  &
  &				       ng_old,nsr,nsr_old,scalar,  &
  &					   scalar_old,n_scalar,&  
  &                    ids,ide, jds,jde, kds,kde,  &
  &                    ims,ime, jms,jme, kms,kme,  &
  &                    its,ite, jts,jte, kts,kte,  &
  &                    i,j,k)
  
  
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: i,j,k
  INTEGER, INTENT(IN) :: ims,ime,kms,kme,jms,jme,ids,ide,jds,jde,kds,kde,its,ite,jts,jte,kts,kte
  INTEGER, PARAMETER :: nbin = 36
  INTEGER, INTENT(IN) :: n_scalar
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar_old
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar
  REAL, DIMENSION(KTS:KTE, nbin), INTENT(INOUT) ::     &
  &    qw,qw_old,qi,qi_old,qs,qs_old,qg,qg_old, 	&
  &	   qsr,qsr_old,qsm,qsm_old,qgm,qgm_old,nw,nw_old,   &
  &	   ni,ni_old,ns,ns_old,ng,ng_old,nsr,nsr_old


  !! Mixing ratios
!! Water drops
    qw(k,1) = scalar(i,k,j,P_MC1)
    qw(k,2) = scalar(i,k,j,P_MC2)
    qw(k,3) = scalar(i,k,j,P_MC3)
    qw(k,4) = scalar(i,k,j,P_MC4)
    qw(k,5) = scalar(i,k,j,P_MC5)
    qw(k,6) = scalar(i,k,j,P_MC6)
    qw(k,7) = scalar(i,k,j,P_MC7)
    qw(k,8) = scalar(i,k,j,P_MC8)
    qw(k,9) = scalar(i,k,j,P_MC9)
    qw(k,10) = scalar(i,k,j,P_MC10)
    qw(k,11) = scalar(i,k,j,P_MC11)
    qw(k,12) = scalar(i,k,j,P_MC12)
    qw(k,13) = scalar(i,k,j,P_MC13)
    qw(k,14) = scalar(i,k,j,P_MC14)
    qw(k,15) = scalar(i,k,j,P_MC15)
    qw(k,16) = scalar(i,k,j,P_MC16)
    qw(k,17) = scalar(i,k,j,P_MC17)
    qw(k,18) = scalar(i,k,j,P_MC18)
    qw(k,19) = scalar(i,k,j,P_MC19)
    qw(k,20) = scalar(i,k,j,P_MC20)
    qw(k,21) = scalar(i,k,j,P_MC21)
    qw(k,22) = scalar(i,k,j,P_MC22)
    qw(k,23) = scalar(i,k,j,P_MC23)
    qw(k,24) = scalar(i,k,j,P_MC24)
    qw(k,25) = scalar(i,k,j,P_MC25)
    qw(k,26) = scalar(i,k,j,P_MC26)
    qw(k,27) = scalar(i,k,j,P_MC27)
    qw(k,28) = scalar(i,k,j,P_MC28)
    qw(k,29) = scalar(i,k,j,P_MC29)
    qw(k,30) = scalar(i,k,j,P_MC30)
    qw(k,31) = scalar(i,k,j,P_MC31)
    qw(k,32) = scalar(i,k,j,P_MC32)
    qw(k,33) = scalar(i,k,j,P_MC33)
    qw(k,34) = scalar(i,k,j,P_MC34)
    qw(k,35) = scalar(i,k,j,P_MC35)
    qw(k,36) = scalar(i,k,j,P_MC36)  
!! Ice crystals
    qi(k,1) = scalar(i,k,j,P_MI1)
    qi(k,2) = scalar(i,k,j,P_MI2)
    qi(k,3) = scalar(i,k,j,P_MI3)
    qi(k,4) = scalar(i,k,j,P_MI4)
    qi(k,5) = scalar(i,k,j,P_MI5)
    qi(k,6) = scalar(i,k,j,P_MI6)
    qi(k,7) = scalar(i,k,j,P_MI7)
    qi(k,8) = scalar(i,k,j,P_MI8)
    qi(k,9) = scalar(i,k,j,P_MI9)
    qi(k,10) = scalar(i,k,j,P_MI10)
    qi(k,11) = scalar(i,k,j,P_MI11)
    qi(k,12) = scalar(i,k,j,P_MI12)
    qi(k,13) = scalar(i,k,j,P_MI13)
    qi(k,14) = scalar(i,k,j,P_MI14)
    qi(k,15) = scalar(i,k,j,P_MI15)
    qi(k,16) = scalar(i,k,j,P_MI16)
    qi(k,17) = scalar(i,k,j,P_MI17)
    qi(k,18) = scalar(i,k,j,P_MI18)
    qi(k,19) = scalar(i,k,j,P_MI19)
    qi(k,20) = scalar(i,k,j,P_MI20)
    qi(k,21) = scalar(i,k,j,P_MI21)
    qi(k,22) = scalar(i,k,j,P_MI22)
    qi(k,23) = scalar(i,k,j,P_MI23)
    qi(k,24) = scalar(i,k,j,P_MI24)
    qi(k,25) = scalar(i,k,j,P_MI25)
    qi(k,26) = scalar(i,k,j,P_MI26)
    qi(k,27) = scalar(i,k,j,P_MI27)
    qi(k,28) = scalar(i,k,j,P_MI28)
    qi(k,29) = scalar(i,k,j,P_MI29)
    qi(k,30) = scalar(i,k,j,P_MI30)
    qi(k,31) = scalar(i,k,j,P_MI31)
    qi(k,32) = scalar(i,k,j,P_MI32)
    qi(k,33) = scalar(i,k,j,P_MI33)
    qi(k,34) = scalar(i,k,j,P_MI34)
    qi(k,35) = scalar(i,k,j,P_MI35)
    qi(k,36) = scalar(i,k,j,P_MI36)  
!! Snowflakes
    qs(k,1) = scalar(i,k,j,P_MR1)
    qs(k,2) = scalar(i,k,j,P_MR2)
    qs(k,3) = scalar(i,k,j,P_MR3)
    qs(k,4) = scalar(i,k,j,P_MR4)
    qs(k,5) = scalar(i,k,j,P_MR5)
    qs(k,6) = scalar(i,k,j,P_MR6)
    qs(k,7) = scalar(i,k,j,P_MR7)
    qs(k,8) = scalar(i,k,j,P_MR8)
    qs(k,9) = scalar(i,k,j,P_MR9)
    qs(k,10) = scalar(i,k,j,P_MR10)
    qs(k,11) = scalar(i,k,j,P_MR11)
    qs(k,12) = scalar(i,k,j,P_MR12)
    qs(k,13) = scalar(i,k,j,P_MR13)
    qs(k,14) = scalar(i,k,j,P_MR14)
    qs(k,15) = scalar(i,k,j,P_MR15)
    qs(k,16) = scalar(i,k,j,P_MR16)
    qs(k,17) = scalar(i,k,j,P_MR17)
    qs(k,18) = scalar(i,k,j,P_MR18)
    qs(k,19) = scalar(i,k,j,P_MR19)
    qs(k,20) = scalar(i,k,j,P_MR20)
    qs(k,21) = scalar(i,k,j,P_MR21)
    qs(k,22) = scalar(i,k,j,P_MR22)
    qs(k,23) = scalar(i,k,j,P_MR23)
    qs(k,24) = scalar(i,k,j,P_MR24)
    qs(k,25) = scalar(i,k,j,P_MR25)
    qs(k,26) = scalar(i,k,j,P_MR26)
    qs(k,27) = scalar(i,k,j,P_MR27)
    qs(k,28) = scalar(i,k,j,P_MR28)
    qs(k,29) = scalar(i,k,j,P_MR29)
    qs(k,30) = scalar(i,k,j,P_MR30)
    qs(k,31) = scalar(i,k,j,P_MR31)
    qs(k,32) = scalar(i,k,j,P_MR32)
    qs(k,33) = scalar(i,k,j,P_MR33)
    qs(k,34) = scalar(i,k,j,P_MR34)
    qs(k,35) = scalar(i,k,j,P_MR35)
    qs(k,36) = scalar(i,k,j,P_MR36)  
!! Graupel particles
    qg(k,1) = scalar(i,k,j,P_MG1)
    qg(k,2) = scalar(i,k,j,P_MG2)
    qg(k,3) = scalar(i,k,j,P_MG3)
    qg(k,4) = scalar(i,k,j,P_MG4)
    qg(k,5) = scalar(i,k,j,P_MG5)
    qg(k,6) = scalar(i,k,j,P_MG6)
    qg(k,7) = scalar(i,k,j,P_MG7)
    qg(k,8) = scalar(i,k,j,P_MG8)
    qg(k,9) = scalar(i,k,j,P_MG9)
    qg(k,10) = scalar(i,k,j,P_MG10)
    qg(k,11) = scalar(i,k,j,P_MG11)
    qg(k,12) = scalar(i,k,j,P_MG12)
    qg(k,13) = scalar(i,k,j,P_MG13)
    qg(k,14) = scalar(i,k,j,P_MG14)
    qg(k,15) = scalar(i,k,j,P_MG15)
    qg(k,16) = scalar(i,k,j,P_MG16)
    qg(k,17) = scalar(i,k,j,P_MG17)
    qg(k,18) = scalar(i,k,j,P_MG18)
    qg(k,19) = scalar(i,k,j,P_MG19)
    qg(k,20) = scalar(i,k,j,P_MG20)
    qg(k,21) = scalar(i,k,j,P_MG21)
    qg(k,22) = scalar(i,k,j,P_MG22)
    qg(k,23) = scalar(i,k,j,P_MG23)
    qg(k,24) = scalar(i,k,j,P_MG24)
    qg(k,25) = scalar(i,k,j,P_MG25)
    qg(k,26) = scalar(i,k,j,P_MG26)
    qg(k,27) = scalar(i,k,j,P_MG27)
    qg(k,28) = scalar(i,k,j,P_MG28)
    qg(k,29) = scalar(i,k,j,P_MG29)
    qg(k,30) = scalar(i,k,j,P_MG30)
    qg(k,31) = scalar(i,k,j,P_MG31)
    qg(k,32) = scalar(i,k,j,P_MG32)
    qg(k,33) = scalar(i,k,j,P_MG33)
    qg(k,34) = scalar(i,k,j,P_MG34)
    qg(k,35) = scalar(i,k,j,P_MG35)
    qg(k,36) = scalar(i,k,j,P_MG36)
!! Rimed snowflakes
    qsr(k,1) = scalar(i,k,j,P_MX1)
    qsr(k,2) = scalar(i,k,j,P_MX2)
    qsr(k,3) = scalar(i,k,j,P_MX3)
    qsr(k,4) = scalar(i,k,j,P_MX4)
    qsr(k,5) = scalar(i,k,j,P_MX5)
    qsr(k,6) = scalar(i,k,j,P_MX6)
    qsr(k,7) = scalar(i,k,j,P_MX7)
    qsr(k,8) = scalar(i,k,j,P_MX8)
    qsr(k,9) = scalar(i,k,j,P_MX9)
    qsr(k,10) = scalar(i,k,j,P_MX10)
    qsr(k,11) = scalar(i,k,j,P_MX11)
    qsr(k,12) = scalar(i,k,j,P_MX12)
    qsr(k,13) = scalar(i,k,j,P_MX13)
    qsr(k,14) = scalar(i,k,j,P_MX14)
    qsr(k,15) = scalar(i,k,j,P_MX15)
    qsr(k,16) = scalar(i,k,j,P_MX16)
    qsr(k,17) = scalar(i,k,j,P_MX17)
    qsr(k,18) = scalar(i,k,j,P_MX18)
    qsr(k,19) = scalar(i,k,j,P_MX19)
    qsr(k,20) = scalar(i,k,j,P_MX20)
    qsr(k,21) = scalar(i,k,j,P_MX21)
    qsr(k,22) = scalar(i,k,j,P_MX22)
    qsr(k,23) = scalar(i,k,j,P_MX23)
    qsr(k,24) = scalar(i,k,j,P_MX24)
    qsr(k,25) = scalar(i,k,j,P_MX25)
    qsr(k,26) = scalar(i,k,j,P_MX26)
    qsr(k,27) = scalar(i,k,j,P_MX27)
    qsr(k,28) = scalar(i,k,j,P_MX28)
    qsr(k,29) = scalar(i,k,j,P_MX29)
    qsr(k,30) = scalar(i,k,j,P_MX30)
    qsr(k,31) = scalar(i,k,j,P_MX31)
    qsr(k,32) = scalar(i,k,j,P_MX32)
    qsr(k,33) = scalar(i,k,j,P_MX33)
    qsr(k,34) = scalar(i,k,j,P_MX34)
    qsr(k,35) = scalar(i,k,j,P_MX35)
    qsr(k,36) = scalar(i,k,j,P_MX36)
!! Melted snowflakes
    qsm(k,1) = scalar(i,k,j,P_MY1)
    qsm(k,2) = scalar(i,k,j,P_MY2)
    qsm(k,3) = scalar(i,k,j,P_MY3)
    qsm(k,4) = scalar(i,k,j,P_MY4)
    qsm(k,5) = scalar(i,k,j,P_MY5)
    qsm(k,6) = scalar(i,k,j,P_MY6)
    qsm(k,7) = scalar(i,k,j,P_MY7)
    qsm(k,8) = scalar(i,k,j,P_MY8)
    qsm(k,9) = scalar(i,k,j,P_MY9)
    qsm(k,10) = scalar(i,k,j,P_MY10)
    qsm(k,11) = scalar(i,k,j,P_MY11)
    qsm(k,12) = scalar(i,k,j,P_MY12)
    qsm(k,13) = scalar(i,k,j,P_MY13)
    qsm(k,14) = scalar(i,k,j,P_MY14)
    qsm(k,15) = scalar(i,k,j,P_MY15)
    qsm(k,16) = scalar(i,k,j,P_MY16)
    qsm(k,17) = scalar(i,k,j,P_MY17)
    qsm(k,18) = scalar(i,k,j,P_MY18)
    qsm(k,19) = scalar(i,k,j,P_MY19)
    qsm(k,20) = scalar(i,k,j,P_MY20)
    qsm(k,21) = scalar(i,k,j,P_MY21)
    qsm(k,22) = scalar(i,k,j,P_MY22)
    qsm(k,23) = scalar(i,k,j,P_MY23)
    qsm(k,24) = scalar(i,k,j,P_MY24)
    qsm(k,25) = scalar(i,k,j,P_MY25)
    qsm(k,26) = scalar(i,k,j,P_MY26)
    qsm(k,27) = scalar(i,k,j,P_MY27)
    qsm(k,28) = scalar(i,k,j,P_MY28)
    qsm(k,29) = scalar(i,k,j,P_MY29)
    qsm(k,30) = scalar(i,k,j,P_MY30)
    qsm(k,31) = scalar(i,k,j,P_MY31)
    qsm(k,32) = scalar(i,k,j,P_MY32)
    qsm(k,33) = scalar(i,k,j,P_MY33)
    qsm(k,34) = scalar(i,k,j,P_MY34)
    qsm(k,35) = scalar(i,k,j,P_MY35)
    qsm(k,36) = scalar(i,k,j,P_MY36)
!! Melted graupel
    qgm(k,1) = scalar(i,k,j,P_MZ1)
    qgm(k,2) = scalar(i,k,j,P_MZ2)
    qgm(k,3) = scalar(i,k,j,P_MZ3)
    qgm(k,4) = scalar(i,k,j,P_MZ4)
    qgm(k,5) = scalar(i,k,j,P_MZ5)
    qgm(k,6) = scalar(i,k,j,P_MZ6)
    qgm(k,7) = scalar(i,k,j,P_MZ7)
    qgm(k,8) = scalar(i,k,j,P_MZ8)
    qgm(k,9) = scalar(i,k,j,P_MZ9)
    qgm(k,10) = scalar(i,k,j,P_MZ10)
    qgm(k,11) = scalar(i,k,j,P_MZ11)
    qgm(k,12) = scalar(i,k,j,P_MZ12)
    qgm(k,13) = scalar(i,k,j,P_MZ13)
    qgm(k,14) = scalar(i,k,j,P_MZ14)
    qgm(k,15) = scalar(i,k,j,P_MZ15)
    qgm(k,16) = scalar(i,k,j,P_MZ16)
    qgm(k,17) = scalar(i,k,j,P_MZ17)
    qgm(k,18) = scalar(i,k,j,P_MZ18)
    qgm(k,19) = scalar(i,k,j,P_MZ19)
    qgm(k,20) = scalar(i,k,j,P_MZ20)
    qgm(k,21) = scalar(i,k,j,P_MZ21)
    qgm(k,22) = scalar(i,k,j,P_MZ22)
    qgm(k,23) = scalar(i,k,j,P_MZ23)
    qgm(k,24) = scalar(i,k,j,P_MZ24)
    qgm(k,25) = scalar(i,k,j,P_MZ25)
    qgm(k,26) = scalar(i,k,j,P_MZ26)
    qgm(k,27) = scalar(i,k,j,P_MZ27)
    qgm(k,28) = scalar(i,k,j,P_MZ28)
    qgm(k,29) = scalar(i,k,j,P_MZ29)
    qgm(k,30) = scalar(i,k,j,P_MZ30)
    qgm(k,31) = scalar(i,k,j,P_MZ31)
    qgm(k,32) = scalar(i,k,j,P_MZ32)
    qgm(k,33) = scalar(i,k,j,P_MZ33)
    qgm(k,34) = scalar(i,k,j,P_MZ34)
    qgm(k,35) = scalar(i,k,j,P_MZ35)
    qgm(k,36) = scalar(i,k,j,P_MZ36)
	
  !! Number concentrations
!! Water drops  
    nw(k,1) = scalar(i,k,j,P_NC1)
    nw(k,2) = scalar(i,k,j,P_NC2)
    nw(k,3) = scalar(i,k,j,P_NC3)
    nw(k,4) = scalar(i,k,j,P_NC4)
    nw(k,5) = scalar(i,k,j,P_NC5)
    nw(k,6) = scalar(i,k,j,P_NC6)
    nw(k,7) = scalar(i,k,j,P_NC7)
    nw(k,8) = scalar(i,k,j,P_NC8)
    nw(k,9) = scalar(i,k,j,P_NC9)
    nw(k,10) = scalar(i,k,j,P_NC10)
    nw(k,11) = scalar(i,k,j,P_NC11)
    nw(k,12) = scalar(i,k,j,P_NC12)
    nw(k,13) = scalar(i,k,j,P_NC13)
    nw(k,14) = scalar(i,k,j,P_NC14)
    nw(k,15) = scalar(i,k,j,P_NC15)
    nw(k,16) = scalar(i,k,j,P_NC16)
    nw(k,17) = scalar(i,k,j,P_NC17)
    nw(k,18) = scalar(i,k,j,P_NC18)
    nw(k,19) = scalar(i,k,j,P_NC19)
    nw(k,20) = scalar(i,k,j,P_NC20)
    nw(k,21) = scalar(i,k,j,P_NC21)
    nw(k,22) = scalar(i,k,j,P_NC22)
    nw(k,23) = scalar(i,k,j,P_NC23)
    nw(k,24) = scalar(i,k,j,P_NC24)
    nw(k,25) = scalar(i,k,j,P_NC25)
    nw(k,26) = scalar(i,k,j,P_NC26)
    nw(k,27) = scalar(i,k,j,P_NC27)
    nw(k,28) = scalar(i,k,j,P_NC28)
    nw(k,29) = scalar(i,k,j,P_NC29)
    nw(k,30) = scalar(i,k,j,P_NC30)
    nw(k,31) = scalar(i,k,j,P_NC31)
    nw(k,32) = scalar(i,k,j,P_NC32)
    nw(k,33) = scalar(i,k,j,P_NC33)
    nw(k,34) = scalar(i,k,j,P_NC34)
    nw(k,35) = scalar(i,k,j,P_NC35)
    nw(k,36) = scalar(i,k,j,P_NC36)
!! Snowflakes	
    ns(k,1) = scalar(i,k,j,P_NR1)
    ns(k,2) = scalar(i,k,j,P_NR2)
    ns(k,3) = scalar(i,k,j,P_NR3)
    ns(k,4) = scalar(i,k,j,P_NR4)
    ns(k,5) = scalar(i,k,j,P_NR5)
    ns(k,6) = scalar(i,k,j,P_NR6)
    ns(k,7) = scalar(i,k,j,P_NR7)
    ns(k,8) = scalar(i,k,j,P_NR8)
    ns(k,9) = scalar(i,k,j,P_NR9)
    ns(k,10) = scalar(i,k,j,P_NR10)
    ns(k,11) = scalar(i,k,j,P_NR11)
    ns(k,12) = scalar(i,k,j,P_NR12)
    ns(k,13) = scalar(i,k,j,P_NR13)
    ns(k,14) = scalar(i,k,j,P_NR14)
    ns(k,15) = scalar(i,k,j,P_NR15)
    ns(k,16) = scalar(i,k,j,P_NR16)
    ns(k,17) = scalar(i,k,j,P_NR17)
    ns(k,18) = scalar(i,k,j,P_NR18)
    ns(k,19) = scalar(i,k,j,P_NR19)
    ns(k,20) = scalar(i,k,j,P_NR20)
    ns(k,21) = scalar(i,k,j,P_NR21)
    ns(k,22) = scalar(i,k,j,P_NR22)
    ns(k,23) = scalar(i,k,j,P_NR23)
    ns(k,24) = scalar(i,k,j,P_NR24)
    ns(k,25) = scalar(i,k,j,P_NR25)
    ns(k,26) = scalar(i,k,j,P_NR26)
    ns(k,27) = scalar(i,k,j,P_NR27)
    ns(k,28) = scalar(i,k,j,P_NR28)
    ns(k,29) = scalar(i,k,j,P_NR29)
    ns(k,30) = scalar(i,k,j,P_NR30)
    ns(k,31) = scalar(i,k,j,P_NR31)
    ns(k,32) = scalar(i,k,j,P_NR32)
    ns(k,33) = scalar(i,k,j,P_NR33)
    ns(k,34) = scalar(i,k,j,P_NR34)
    ns(k,35) = scalar(i,k,j,P_NR35)
    ns(k,36) = scalar(i,k,j,P_NR36)
!! Graupel particles
    ng(k,1) = scalar(i,k,j,P_NG1)
    ng(k,2) = scalar(i,k,j,P_NG2)
    ng(k,3) = scalar(i,k,j,P_NG3)
    ng(k,4) = scalar(i,k,j,P_NG4)
    ng(k,5) = scalar(i,k,j,P_NG5)
    ng(k,6) = scalar(i,k,j,P_NG6)
    ng(k,7) = scalar(i,k,j,P_NG7)
    ng(k,8) = scalar(i,k,j,P_NG8)
    ng(k,9) = scalar(i,k,j,P_NG9)
    ng(k,10) = scalar(i,k,j,P_NG10)
    ng(k,11) = scalar(i,k,j,P_NG11)
    ng(k,12) = scalar(i,k,j,P_NG12)
    ng(k,13) = scalar(i,k,j,P_NG13)
    ng(k,14) = scalar(i,k,j,P_NG14)
    ng(k,15) = scalar(i,k,j,P_NG15)
    ng(k,16) = scalar(i,k,j,P_NG16)
    ng(k,17) = scalar(i,k,j,P_NG17)
    ng(k,18) = scalar(i,k,j,P_NG18)
    ng(k,19) = scalar(i,k,j,P_NG19)
    ng(k,20) = scalar(i,k,j,P_NG20)
    ng(k,21) = scalar(i,k,j,P_NG21)
    ng(k,22) = scalar(i,k,j,P_NG22)
    ng(k,23) = scalar(i,k,j,P_NG23)
    ng(k,24) = scalar(i,k,j,P_NG24)
    ng(k,25) = scalar(i,k,j,P_NG25)
    ng(k,26) = scalar(i,k,j,P_NG26)
    ng(k,27) = scalar(i,k,j,P_NG27)
    ng(k,28) = scalar(i,k,j,P_NG28)
    ng(k,29) = scalar(i,k,j,P_NG29)
    ng(k,30) = scalar(i,k,j,P_NG30)
    ng(k,31) = scalar(i,k,j,P_NG31)
    ng(k,32) = scalar(i,k,j,P_NG32)
    ng(k,33) = scalar(i,k,j,P_NG33)
    ng(k,34) = scalar(i,k,j,P_NG34)
    ng(k,35) = scalar(i,k,j,P_NG35)
    ng(k,36) = scalar(i,k,j,P_NG36)	
!! Ice crystals
    ni(k,1) = scalar(i,k,j,P_NI1)
    ni(k,2) = scalar(i,k,j,P_NI2)
    ni(k,3) = scalar(i,k,j,P_NI3)
    ni(k,4) = scalar(i,k,j,P_NI4)
    ni(k,5) = scalar(i,k,j,P_NI5)
    ni(k,6) = scalar(i,k,j,P_NI6)
    ni(k,7) = scalar(i,k,j,P_NI7)
    ni(k,8) = scalar(i,k,j,P_NI8)
    ni(k,9) = scalar(i,k,j,P_NI9)
    ni(k,10) = scalar(i,k,j,P_NI10)
    ni(k,11) = scalar(i,k,j,P_NI11)
    ni(k,12) = scalar(i,k,j,P_NI12)
    ni(k,13) = scalar(i,k,j,P_NI13)
    ni(k,14) = scalar(i,k,j,P_NI14)
    ni(k,15) = scalar(i,k,j,P_NI15)
    ni(k,16) = scalar(i,k,j,P_NI16)
    ni(k,17) = scalar(i,k,j,P_NI17)
    ni(k,18) = scalar(i,k,j,P_NI18)
    ni(k,19) = scalar(i,k,j,P_NI19)
    ni(k,20) = scalar(i,k,j,P_NI20)
    ni(k,21) = scalar(i,k,j,P_NI21)
    ni(k,22) = scalar(i,k,j,P_NI22)
    ni(k,23) = scalar(i,k,j,P_NI23)
    ni(k,24) = scalar(i,k,j,P_NI24)
    ni(k,25) = scalar(i,k,j,P_NI25)
    ni(k,26) = scalar(i,k,j,P_NI26)
    ni(k,27) = scalar(i,k,j,P_NI27)
    ni(k,28) = scalar(i,k,j,P_NI28)
    ni(k,29) = scalar(i,k,j,P_NI29)
    ni(k,30) = scalar(i,k,j,P_NI30)
    ni(k,31) = scalar(i,k,j,P_NI31)
    ni(k,32) = scalar(i,k,j,P_NI32)
    ni(k,33) = scalar(i,k,j,P_NI33)
    ni(k,34) = scalar(i,k,j,P_NI34)
    ni(k,35) = scalar(i,k,j,P_NI35)
    ni(k,36) = scalar(i,k,j,P_NI36)	
!! Rimed snowflakes number
    nsr(k,1) = scalar(i,k,j,P_NX1)
    nsr(k,2) = scalar(i,k,j,P_NX2)
    nsr(k,3) = scalar(i,k,j,P_NX3)
    nsr(k,4) = scalar(i,k,j,P_NX4)
    nsr(k,5) = scalar(i,k,j,P_NX5)
    nsr(k,6) = scalar(i,k,j,P_NX6)
    nsr(k,7) = scalar(i,k,j,P_NX7)
    nsr(k,8) = scalar(i,k,j,P_NX8)
    nsr(k,9) = scalar(i,k,j,P_NX9)
    nsr(k,10) = scalar(i,k,j,P_NX10)
    nsr(k,11) = scalar(i,k,j,P_NX11)
    nsr(k,12) = scalar(i,k,j,P_NX12)
    nsr(k,13) = scalar(i,k,j,P_NX13)
    nsr(k,14) = scalar(i,k,j,P_NX14)
    nsr(k,15) = scalar(i,k,j,P_NX15)
    nsr(k,16) = scalar(i,k,j,P_NX16)
    nsr(k,17) = scalar(i,k,j,P_NX17)
    nsr(k,18) = scalar(i,k,j,P_NX18)
    nsr(k,19) = scalar(i,k,j,P_NX19)
    nsr(k,20) = scalar(i,k,j,P_NX20)
    nsr(k,21) = scalar(i,k,j,P_NX21)
    nsr(k,22) = scalar(i,k,j,P_NX22)
    nsr(k,23) = scalar(i,k,j,P_NX23)
    nsr(k,24) = scalar(i,k,j,P_NX24)
    nsr(k,25) = scalar(i,k,j,P_NX25)
    nsr(k,26) = scalar(i,k,j,P_NX26)
    nsr(k,27) = scalar(i,k,j,P_NX27)
    nsr(k,28) = scalar(i,k,j,P_NX28)
    nsr(k,29) = scalar(i,k,j,P_NX29)
    nsr(k,30) = scalar(i,k,j,P_NX30)
    nsr(k,31) = scalar(i,k,j,P_NX31)
    nsr(k,32) = scalar(i,k,j,P_NX32)
    nsr(k,33) = scalar(i,k,j,P_NX33)
    nsr(k,34) = scalar(i,k,j,P_NX34)
    nsr(k,35) = scalar(i,k,j,P_NX35)
    nsr(k,36) = scalar(i,k,j,P_NX36)	

	
!! Old variables (before advection)
  !! Mixing ratios
!! Water drops
    qw_old(k,1) = scalar_old(i,k,j,P_MC1)
    qw_old(k,2) = scalar_old(i,k,j,P_MC2)
    qw_old(k,3) = scalar_old(i,k,j,P_MC3)
    qw_old(k,4) = scalar_old(i,k,j,P_MC4)
    qw_old(k,5) = scalar_old(i,k,j,P_MC5)
    qw_old(k,6) = scalar_old(i,k,j,P_MC6)
    qw_old(k,7) = scalar_old(i,k,j,P_MC7)
    qw_old(k,8) = scalar_old(i,k,j,P_MC8)
    qw_old(k,9) = scalar_old(i,k,j,P_MC9)
    qw_old(k,10) = scalar_old(i,k,j,P_MC10)
    qw_old(k,11) = scalar_old(i,k,j,P_MC11)
    qw_old(k,12) = scalar_old(i,k,j,P_MC12)
    qw_old(k,13) = scalar_old(i,k,j,P_MC13)
    qw_old(k,14) = scalar_old(i,k,j,P_MC14)
    qw_old(k,15) = scalar_old(i,k,j,P_MC15)
    qw_old(k,16) = scalar_old(i,k,j,P_MC16)
    qw_old(k,17) = scalar_old(i,k,j,P_MC17)
    qw_old(k,18) = scalar_old(i,k,j,P_MC18)
    qw_old(k,19) = scalar_old(i,k,j,P_MC19)
    qw_old(k,20) = scalar_old(i,k,j,P_MC20)
    qw_old(k,21) = scalar_old(i,k,j,P_MC21)
    qw_old(k,22) = scalar_old(i,k,j,P_MC22)
    qw_old(k,23) = scalar_old(i,k,j,P_MC23)
    qw_old(k,24) = scalar_old(i,k,j,P_MC24)
    qw_old(k,25) = scalar_old(i,k,j,P_MC25)
    qw_old(k,26) = scalar_old(i,k,j,P_MC26)
    qw_old(k,27) = scalar_old(i,k,j,P_MC27)
    qw_old(k,28) = scalar_old(i,k,j,P_MC28)
    qw_old(k,29) = scalar_old(i,k,j,P_MC29)
    qw_old(k,30) = scalar_old(i,k,j,P_MC30)
    qw_old(k,31) = scalar_old(i,k,j,P_MC31)
    qw_old(k,32) = scalar_old(i,k,j,P_MC32)
    qw_old(k,33) = scalar_old(i,k,j,P_MC33)
    qw_old(k,34) = scalar_old(i,k,j,P_MC34)
    qw_old(k,35) = scalar_old(i,k,j,P_MC35)
    qw_old(k,36) = scalar_old(i,k,j,P_MC36)  
!! Ice crystals
    qi_old(k,1) = scalar_old(i,k,j,P_MI1)
    qi_old(k,2) = scalar_old(i,k,j,P_MI2)
    qi_old(k,3) = scalar_old(i,k,j,P_MI3)
    qi_old(k,4) = scalar_old(i,k,j,P_MI4)
    qi_old(k,5) = scalar_old(i,k,j,P_MI5)
    qi_old(k,6) = scalar_old(i,k,j,P_MI6)
    qi_old(k,7) = scalar_old(i,k,j,P_MI7)
    qi_old(k,8) = scalar_old(i,k,j,P_MI8)
    qi_old(k,9) = scalar_old(i,k,j,P_MI9)
    qi_old(k,10) = scalar_old(i,k,j,P_MI10)
    qi_old(k,11) = scalar_old(i,k,j,P_MI11)
    qi_old(k,12) = scalar_old(i,k,j,P_MI12)
    qi_old(k,13) = scalar_old(i,k,j,P_MI13)
    qi_old(k,14) = scalar_old(i,k,j,P_MI14)
    qi_old(k,15) = scalar_old(i,k,j,P_MI15)
    qi_old(k,16) = scalar_old(i,k,j,P_MI16)
    qi_old(k,17) = scalar_old(i,k,j,P_MI17)
    qi_old(k,18) = scalar_old(i,k,j,P_MI18)
    qi_old(k,19) = scalar_old(i,k,j,P_MI19)
    qi_old(k,20) = scalar_old(i,k,j,P_MI20)
    qi_old(k,21) = scalar_old(i,k,j,P_MI21)
    qi_old(k,22) = scalar_old(i,k,j,P_MI22)
    qi_old(k,23) = scalar_old(i,k,j,P_MI23)
    qi_old(k,24) = scalar_old(i,k,j,P_MI24)
    qi_old(k,25) = scalar_old(i,k,j,P_MI25)
    qi_old(k,26) = scalar_old(i,k,j,P_MI26)
    qi_old(k,27) = scalar_old(i,k,j,P_MI27)
    qi_old(k,28) = scalar_old(i,k,j,P_MI28)
    qi_old(k,29) = scalar_old(i,k,j,P_MI29)
    qi_old(k,30) = scalar_old(i,k,j,P_MI30)
    qi_old(k,31) = scalar_old(i,k,j,P_MI31)
    qi_old(k,32) = scalar_old(i,k,j,P_MI32)
    qi_old(k,33) = scalar_old(i,k,j,P_MI33)
    qi_old(k,34) = scalar_old(i,k,j,P_MI34)
    qi_old(k,35) = scalar_old(i,k,j,P_MI35)
    qi_old(k,36) = scalar_old(i,k,j,P_MI36)  
!! Snowflakes
    qs_old(k,1) = scalar_old(i,k,j,P_MR1)
    qs_old(k,2) = scalar_old(i,k,j,P_MR2)
    qs_old(k,3) = scalar_old(i,k,j,P_MR3)
    qs_old(k,4) = scalar_old(i,k,j,P_MR4)
    qs_old(k,5) = scalar_old(i,k,j,P_MR5)
    qs_old(k,6) = scalar_old(i,k,j,P_MR6)
    qs_old(k,7) = scalar_old(i,k,j,P_MR7)
    qs_old(k,8) = scalar_old(i,k,j,P_MR8)
    qs_old(k,9) = scalar_old(i,k,j,P_MR9)
    qs_old(k,10) = scalar_old(i,k,j,P_MR10)
    qs_old(k,11) = scalar_old(i,k,j,P_MR11)
    qs_old(k,12) = scalar_old(i,k,j,P_MR12)
    qs_old(k,13) = scalar_old(i,k,j,P_MR13)
    qs_old(k,14) = scalar_old(i,k,j,P_MR14)
    qs_old(k,15) = scalar_old(i,k,j,P_MR15)
    qs_old(k,16) = scalar_old(i,k,j,P_MR16)
    qs_old(k,17) = scalar_old(i,k,j,P_MR17)
    qs_old(k,18) = scalar_old(i,k,j,P_MR18)
    qs_old(k,19) = scalar_old(i,k,j,P_MR19)
    qs_old(k,20) = scalar_old(i,k,j,P_MR20)
    qs_old(k,21) = scalar_old(i,k,j,P_MR21)
    qs_old(k,22) = scalar_old(i,k,j,P_MR22)
    qs_old(k,23) = scalar_old(i,k,j,P_MR23)
    qs_old(k,24) = scalar_old(i,k,j,P_MR24)
    qs_old(k,25) = scalar_old(i,k,j,P_MR25)
    qs_old(k,26) = scalar_old(i,k,j,P_MR26)
    qs_old(k,27) = scalar_old(i,k,j,P_MR27)
    qs_old(k,28) = scalar_old(i,k,j,P_MR28)
    qs_old(k,29) = scalar_old(i,k,j,P_MR29)
    qs_old(k,30) = scalar_old(i,k,j,P_MR30)
    qs_old(k,31) = scalar_old(i,k,j,P_MR31)
    qs_old(k,32) = scalar_old(i,k,j,P_MR32)
    qs_old(k,33) = scalar_old(i,k,j,P_MR33)
    qs_old(k,34) = scalar_old(i,k,j,P_MR34)
    qs_old(k,35) = scalar_old(i,k,j,P_MR35)
    qs_old(k,36) = scalar_old(i,k,j,P_MR36)  
!! Graupel particles
    qg_old(k,1) = scalar_old(i,k,j,P_MG1)
    qg_old(k,2) = scalar_old(i,k,j,P_MG2)
    qg_old(k,3) = scalar_old(i,k,j,P_MG3)
    qg_old(k,4) = scalar_old(i,k,j,P_MG4)
    qg_old(k,5) = scalar_old(i,k,j,P_MG5)
    qg_old(k,6) = scalar_old(i,k,j,P_MG6)
    qg_old(k,7) = scalar_old(i,k,j,P_MG7)
    qg_old(k,8) = scalar_old(i,k,j,P_MG8)
    qg_old(k,9) = scalar_old(i,k,j,P_MG9)
    qg_old(k,10) = scalar_old(i,k,j,P_MG10)
    qg_old(k,11) = scalar_old(i,k,j,P_MG11)
    qg_old(k,12) = scalar_old(i,k,j,P_MG12)
    qg_old(k,13) = scalar_old(i,k,j,P_MG13)
    qg_old(k,14) = scalar_old(i,k,j,P_MG14)
    qg_old(k,15) = scalar_old(i,k,j,P_MG15)
    qg_old(k,16) = scalar_old(i,k,j,P_MG16)
    qg_old(k,17) = scalar_old(i,k,j,P_MG17)
    qg_old(k,18) = scalar_old(i,k,j,P_MG18)
    qg_old(k,19) = scalar_old(i,k,j,P_MG19)
    qg_old(k,20) = scalar_old(i,k,j,P_MG20)
    qg_old(k,21) = scalar_old(i,k,j,P_MG21)
    qg_old(k,22) = scalar_old(i,k,j,P_MG22)
    qg_old(k,23) = scalar_old(i,k,j,P_MG23)
    qg_old(k,24) = scalar_old(i,k,j,P_MG24)
    qg_old(k,25) = scalar_old(i,k,j,P_MG25)
    qg_old(k,26) = scalar_old(i,k,j,P_MG26)
    qg_old(k,27) = scalar_old(i,k,j,P_MG27)
    qg_old(k,28) = scalar_old(i,k,j,P_MG28)
    qg_old(k,29) = scalar_old(i,k,j,P_MG29)
    qg_old(k,30) = scalar_old(i,k,j,P_MG30)
    qg_old(k,31) = scalar_old(i,k,j,P_MG31)
    qg_old(k,32) = scalar_old(i,k,j,P_MG32)
    qg_old(k,33) = scalar_old(i,k,j,P_MG33)
    qg_old(k,34) = scalar_old(i,k,j,P_MG34)
    qg_old(k,35) = scalar_old(i,k,j,P_MG35)
    qg_old(k,36) = scalar_old(i,k,j,P_MG36)
!! Rimed snowflakes
    qsr_old(k,1) = scalar_old(i,k,j,P_MX1)
    qsr_old(k,2) = scalar_old(i,k,j,P_MX2)
    qsr_old(k,3) = scalar_old(i,k,j,P_MX3)
    qsr_old(k,4) = scalar_old(i,k,j,P_MX4)
    qsr_old(k,5) = scalar_old(i,k,j,P_MX5)
    qsr_old(k,6) = scalar_old(i,k,j,P_MX6)
    qsr_old(k,7) = scalar_old(i,k,j,P_MX7)
    qsr_old(k,8) = scalar_old(i,k,j,P_MX8)
    qsr_old(k,9) = scalar_old(i,k,j,P_MX9)
    qsr_old(k,10) = scalar_old(i,k,j,P_MX10)
    qsr_old(k,11) = scalar_old(i,k,j,P_MX11)
    qsr_old(k,12) = scalar_old(i,k,j,P_MX12)
    qsr_old(k,13) = scalar_old(i,k,j,P_MX13)
    qsr_old(k,14) = scalar_old(i,k,j,P_MX14)
    qsr_old(k,15) = scalar_old(i,k,j,P_MX15)
    qsr_old(k,16) = scalar_old(i,k,j,P_MX16)
    qsr_old(k,17) = scalar_old(i,k,j,P_MX17)
    qsr_old(k,18) = scalar_old(i,k,j,P_MX18)
    qsr_old(k,19) = scalar_old(i,k,j,P_MX19)
    qsr_old(k,20) = scalar_old(i,k,j,P_MX20)
    qsr_old(k,21) = scalar_old(i,k,j,P_MX21)
    qsr_old(k,22) = scalar_old(i,k,j,P_MX22)
    qsr_old(k,23) = scalar_old(i,k,j,P_MX23)
    qsr_old(k,24) = scalar_old(i,k,j,P_MX24)
    qsr_old(k,25) = scalar_old(i,k,j,P_MX25)
    qsr_old(k,26) = scalar_old(i,k,j,P_MX26)
    qsr_old(k,27) = scalar_old(i,k,j,P_MX27)
    qsr_old(k,28) = scalar_old(i,k,j,P_MX28)
    qsr_old(k,29) = scalar_old(i,k,j,P_MX29)
    qsr_old(k,30) = scalar_old(i,k,j,P_MX30)
    qsr_old(k,31) = scalar_old(i,k,j,P_MX31)
    qsr_old(k,32) = scalar_old(i,k,j,P_MX32)
    qsr_old(k,33) = scalar_old(i,k,j,P_MX33)
    qsr_old(k,34) = scalar_old(i,k,j,P_MX34)
    qsr_old(k,35) = scalar_old(i,k,j,P_MX35)
    qsr_old(k,36) = scalar_old(i,k,j,P_MX36)
!! Melted snowflakes
    qsm_old(k,1) = scalar_old(i,k,j,P_MY1)
    qsm_old(k,2) = scalar_old(i,k,j,P_MY2)
    qsm_old(k,3) = scalar_old(i,k,j,P_MY3)
    qsm_old(k,4) = scalar_old(i,k,j,P_MY4)
    qsm_old(k,5) = scalar_old(i,k,j,P_MY5)
    qsm_old(k,6) = scalar_old(i,k,j,P_MY6)
    qsm_old(k,7) = scalar_old(i,k,j,P_MY7)
    qsm_old(k,8) = scalar_old(i,k,j,P_MY8)
    qsm_old(k,9) = scalar_old(i,k,j,P_MY9)
    qsm_old(k,10) = scalar_old(i,k,j,P_MY10)
    qsm_old(k,11) = scalar_old(i,k,j,P_MY11)
    qsm_old(k,12) = scalar_old(i,k,j,P_MY12)
    qsm_old(k,13) = scalar_old(i,k,j,P_MY13)
    qsm_old(k,14) = scalar_old(i,k,j,P_MY14)
    qsm_old(k,15) = scalar_old(i,k,j,P_MY15)
    qsm_old(k,16) = scalar_old(i,k,j,P_MY16)
    qsm_old(k,17) = scalar_old(i,k,j,P_MY17)
    qsm_old(k,18) = scalar_old(i,k,j,P_MY18)
    qsm_old(k,19) = scalar_old(i,k,j,P_MY19)
    qsm_old(k,20) = scalar_old(i,k,j,P_MY20)
    qsm_old(k,21) = scalar_old(i,k,j,P_MY21)
    qsm_old(k,22) = scalar_old(i,k,j,P_MY22)
    qsm_old(k,23) = scalar_old(i,k,j,P_MY23)
    qsm_old(k,24) = scalar_old(i,k,j,P_MY24)
    qsm_old(k,25) = scalar_old(i,k,j,P_MY25)
    qsm_old(k,26) = scalar_old(i,k,j,P_MY26)
    qsm_old(k,27) = scalar_old(i,k,j,P_MY27)
    qsm_old(k,28) = scalar_old(i,k,j,P_MY28)
    qsm_old(k,29) = scalar_old(i,k,j,P_MY29)
    qsm_old(k,30) = scalar_old(i,k,j,P_MY30)
    qsm_old(k,31) = scalar_old(i,k,j,P_MY31)
    qsm_old(k,32) = scalar_old(i,k,j,P_MY32)
    qsm_old(k,33) = scalar_old(i,k,j,P_MY33)
    qsm_old(k,34) = scalar_old(i,k,j,P_MY34)
    qsm_old(k,35) = scalar_old(i,k,j,P_MY35)
    qsm_old(k,36) = scalar_old(i,k,j,P_MY36)
!! Melted graupel
    qgm_old(k,1) = scalar_old(i,k,j,P_MZ1)
    qgm_old(k,2) = scalar_old(i,k,j,P_MZ2)
    qgm_old(k,3) = scalar_old(i,k,j,P_MZ3)
    qgm_old(k,4) = scalar_old(i,k,j,P_MZ4)
    qgm_old(k,5) = scalar_old(i,k,j,P_MZ5)
    qgm_old(k,6) = scalar_old(i,k,j,P_MZ6)
    qgm_old(k,7) = scalar_old(i,k,j,P_MZ7)
    qgm_old(k,8) = scalar_old(i,k,j,P_MZ8)
    qgm_old(k,9) = scalar_old(i,k,j,P_MZ9)
    qgm_old(k,10) = scalar_old(i,k,j,P_MZ10)
    qgm_old(k,11) = scalar_old(i,k,j,P_MZ11)
    qgm_old(k,12) = scalar_old(i,k,j,P_MZ12)
    qgm_old(k,13) = scalar_old(i,k,j,P_MZ13)
    qgm_old(k,14) = scalar_old(i,k,j,P_MZ14)
    qgm_old(k,15) = scalar_old(i,k,j,P_MZ15)
    qgm_old(k,16) = scalar_old(i,k,j,P_MZ16)
    qgm_old(k,17) = scalar_old(i,k,j,P_MZ17)
    qgm_old(k,18) = scalar_old(i,k,j,P_MZ18)
    qgm_old(k,19) = scalar_old(i,k,j,P_MZ19)
    qgm_old(k,20) = scalar_old(i,k,j,P_MZ20)
    qgm_old(k,21) = scalar_old(i,k,j,P_MZ21)
    qgm_old(k,22) = scalar_old(i,k,j,P_MZ22)
    qgm_old(k,23) = scalar_old(i,k,j,P_MZ23)
    qgm_old(k,24) = scalar_old(i,k,j,P_MZ24)
    qgm_old(k,25) = scalar_old(i,k,j,P_MZ25)
    qgm_old(k,26) = scalar_old(i,k,j,P_MZ26)
    qgm_old(k,27) = scalar_old(i,k,j,P_MZ27)
    qgm_old(k,28) = scalar_old(i,k,j,P_MZ28)
    qgm_old(k,29) = scalar_old(i,k,j,P_MZ29)
    qgm_old(k,30) = scalar_old(i,k,j,P_MZ30)
    qgm_old(k,31) = scalar_old(i,k,j,P_MZ31)
    qgm_old(k,32) = scalar_old(i,k,j,P_MZ32)
    qgm_old(k,33) = scalar_old(i,k,j,P_MZ33)
    qgm_old(k,34) = scalar_old(i,k,j,P_MZ34)
    qgm_old(k,35) = scalar_old(i,k,j,P_MZ35)
    qgm_old(k,36) = scalar_old(i,k,j,P_MZ36)

	
  !! Number concentrations
!! Water drops  
    nw_old(k,1) = scalar_old(i,k,j,P_NC1)
    nw_old(k,2) = scalar_old(i,k,j,P_NC2)
    nw_old(k,3) = scalar_old(i,k,j,P_NC3)
    nw_old(k,4) = scalar_old(i,k,j,P_NC4)
    nw_old(k,5) = scalar_old(i,k,j,P_NC5)
    nw_old(k,6) = scalar_old(i,k,j,P_NC6)
    nw_old(k,7) = scalar_old(i,k,j,P_NC7)
    nw_old(k,8) = scalar_old(i,k,j,P_NC8)
    nw_old(k,9) = scalar_old(i,k,j,P_NC9)
    nw_old(k,10) = scalar_old(i,k,j,P_NC10)
    nw_old(k,11) = scalar_old(i,k,j,P_NC11)
    nw_old(k,12) = scalar_old(i,k,j,P_NC12)
    nw_old(k,13) = scalar_old(i,k,j,P_NC13)
    nw_old(k,14) = scalar_old(i,k,j,P_NC14)
    nw_old(k,15) = scalar_old(i,k,j,P_NC15)
    nw_old(k,16) = scalar_old(i,k,j,P_NC16)
    nw_old(k,17) = scalar_old(i,k,j,P_NC17)
    nw_old(k,18) = scalar_old(i,k,j,P_NC18)
    nw_old(k,19) = scalar_old(i,k,j,P_NC19)
    nw_old(k,20) = scalar_old(i,k,j,P_NC20)
    nw_old(k,21) = scalar_old(i,k,j,P_NC21)
    nw_old(k,22) = scalar_old(i,k,j,P_NC22)
    nw_old(k,23) = scalar_old(i,k,j,P_NC23)
    nw_old(k,24) = scalar_old(i,k,j,P_NC24)
    nw_old(k,25) = scalar_old(i,k,j,P_NC25)
    nw_old(k,26) = scalar_old(i,k,j,P_NC26)
    nw_old(k,27) = scalar_old(i,k,j,P_NC27)
    nw_old(k,28) = scalar_old(i,k,j,P_NC28)
    nw_old(k,29) = scalar_old(i,k,j,P_NC29)
    nw_old(k,30) = scalar_old(i,k,j,P_NC30)
    nw_old(k,31) = scalar_old(i,k,j,P_NC31)
    nw_old(k,32) = scalar_old(i,k,j,P_NC32)
    nw_old(k,33) = scalar_old(i,k,j,P_NC33)
    nw_old(k,34) = scalar_old(i,k,j,P_NC34)
    nw_old(k,35) = scalar_old(i,k,j,P_NC35)
    nw_old(k,36) = scalar_old(i,k,j,P_NC36)
!! Snowflakes	
    ns_old(k,1) = scalar_old(i,k,j,P_NR1)
    ns_old(k,2) = scalar_old(i,k,j,P_NR2)
    ns_old(k,3) = scalar_old(i,k,j,P_NR3)
    ns_old(k,4) = scalar_old(i,k,j,P_NR4)
    ns_old(k,5) = scalar_old(i,k,j,P_NR5)
    ns_old(k,6) = scalar_old(i,k,j,P_NR6)
    ns_old(k,7) = scalar_old(i,k,j,P_NR7)
    ns_old(k,8) = scalar_old(i,k,j,P_NR8)
    ns_old(k,9) = scalar_old(i,k,j,P_NR9)
    ns_old(k,10) = scalar_old(i,k,j,P_NR10)
    ns_old(k,11) = scalar_old(i,k,j,P_NR11)
    ns_old(k,12) = scalar_old(i,k,j,P_NR12)
    ns_old(k,13) = scalar_old(i,k,j,P_NR13)
    ns_old(k,14) = scalar_old(i,k,j,P_NR14)
    ns_old(k,15) = scalar_old(i,k,j,P_NR15)
    ns_old(k,16) = scalar_old(i,k,j,P_NR16)
    ns_old(k,17) = scalar_old(i,k,j,P_NR17)
    ns_old(k,18) = scalar_old(i,k,j,P_NR18)
    ns_old(k,19) = scalar_old(i,k,j,P_NR19)
    ns_old(k,20) = scalar_old(i,k,j,P_NR20)
    ns_old(k,21) = scalar_old(i,k,j,P_NR21)
    ns_old(k,22) = scalar_old(i,k,j,P_NR22)
    ns_old(k,23) = scalar_old(i,k,j,P_NR23)
    ns_old(k,24) = scalar_old(i,k,j,P_NR24)
    ns_old(k,25) = scalar_old(i,k,j,P_NR25)
    ns_old(k,26) = scalar_old(i,k,j,P_NR26)
    ns_old(k,27) = scalar_old(i,k,j,P_NR27)
    ns_old(k,28) = scalar_old(i,k,j,P_NR28)
    ns_old(k,29) = scalar_old(i,k,j,P_NR29)
    ns_old(k,30) = scalar_old(i,k,j,P_NR30)
    ns_old(k,31) = scalar_old(i,k,j,P_NR31)
    ns_old(k,32) = scalar_old(i,k,j,P_NR32)
    ns_old(k,33) = scalar_old(i,k,j,P_NR33)
    ns_old(k,34) = scalar_old(i,k,j,P_NR34)
    ns_old(k,35) = scalar_old(i,k,j,P_NR35)
    ns_old(k,36) = scalar_old(i,k,j,P_NR36)
!! Graupel particles
    ng_old(k,1) = scalar_old(i,k,j,P_NG1)
    ng_old(k,2) = scalar_old(i,k,j,P_NG2)
    ng_old(k,3) = scalar_old(i,k,j,P_NG3)
    ng_old(k,4) = scalar_old(i,k,j,P_NG4)
    ng_old(k,5) = scalar_old(i,k,j,P_NG5)
    ng_old(k,6) = scalar_old(i,k,j,P_NG6)
    ng_old(k,7) = scalar_old(i,k,j,P_NG7)
    ng_old(k,8) = scalar_old(i,k,j,P_NG8)
    ng_old(k,9) = scalar_old(i,k,j,P_NG9)
    ng_old(k,10) = scalar_old(i,k,j,P_NG10)
    ng_old(k,11) = scalar_old(i,k,j,P_NG11)
    ng_old(k,12) = scalar_old(i,k,j,P_NG12)
    ng_old(k,13) = scalar_old(i,k,j,P_NG13)
    ng_old(k,14) = scalar_old(i,k,j,P_NG14)
    ng_old(k,15) = scalar_old(i,k,j,P_NG15)
    ng_old(k,16) = scalar_old(i,k,j,P_NG16)
    ng_old(k,17) = scalar_old(i,k,j,P_NG17)
    ng_old(k,18) = scalar_old(i,k,j,P_NG18)
    ng_old(k,19) = scalar_old(i,k,j,P_NG19)
    ng_old(k,20) = scalar_old(i,k,j,P_NG20)
    ng_old(k,21) = scalar_old(i,k,j,P_NG21)
    ng_old(k,22) = scalar_old(i,k,j,P_NG22)
    ng_old(k,23) = scalar_old(i,k,j,P_NG23)
    ng_old(k,24) = scalar_old(i,k,j,P_NG24)
    ng_old(k,25) = scalar_old(i,k,j,P_NG25)
    ng_old(k,26) = scalar_old(i,k,j,P_NG26)
    ng_old(k,27) = scalar_old(i,k,j,P_NG27)
    ng_old(k,28) = scalar_old(i,k,j,P_NG28)
    ng_old(k,29) = scalar_old(i,k,j,P_NG29)
    ng_old(k,30) = scalar_old(i,k,j,P_NG30)
    ng_old(k,31) = scalar_old(i,k,j,P_NG31)
    ng_old(k,32) = scalar_old(i,k,j,P_NG32)
    ng_old(k,33) = scalar_old(i,k,j,P_NG33)
    ng_old(k,34) = scalar_old(i,k,j,P_NG34)
    ng_old(k,35) = scalar_old(i,k,j,P_NG35)
    ng_old(k,36) = scalar_old(i,k,j,P_NG36)	
!! Ice crystals
    ni_old(k,1) = scalar_old(i,k,j,P_NI1)
    ni_old(k,2) = scalar_old(i,k,j,P_NI2)
    ni_old(k,3) = scalar_old(i,k,j,P_NI3)
    ni_old(k,4) = scalar_old(i,k,j,P_NI4)
    ni_old(k,5) = scalar_old(i,k,j,P_NI5)
    ni_old(k,6) = scalar_old(i,k,j,P_NI6)
    ni_old(k,7) = scalar_old(i,k,j,P_NI7)
    ni_old(k,8) = scalar_old(i,k,j,P_NI8)
    ni_old(k,9) = scalar_old(i,k,j,P_NI9)
    ni_old(k,10) = scalar_old(i,k,j,P_NI10)
    ni_old(k,11) = scalar_old(i,k,j,P_NI11)
    ni_old(k,12) = scalar_old(i,k,j,P_NI12)
    ni_old(k,13) = scalar_old(i,k,j,P_NI13)
    ni_old(k,14) = scalar_old(i,k,j,P_NI14)
    ni_old(k,15) = scalar_old(i,k,j,P_NI15)
    ni_old(k,16) = scalar_old(i,k,j,P_NI16)
    ni_old(k,17) = scalar_old(i,k,j,P_NI17)
    ni_old(k,18) = scalar_old(i,k,j,P_NI18)
    ni_old(k,19) = scalar_old(i,k,j,P_NI19)
    ni_old(k,20) = scalar_old(i,k,j,P_NI20)
    ni_old(k,21) = scalar_old(i,k,j,P_NI21)
    ni_old(k,22) = scalar_old(i,k,j,P_NI22)
    ni_old(k,23) = scalar_old(i,k,j,P_NI23)
    ni_old(k,24) = scalar_old(i,k,j,P_NI24)
    ni_old(k,25) = scalar_old(i,k,j,P_NI25)
    ni_old(k,26) = scalar_old(i,k,j,P_NI26)
    ni_old(k,27) = scalar_old(i,k,j,P_NI27)
    ni_old(k,28) = scalar_old(i,k,j,P_NI28)
    ni_old(k,29) = scalar_old(i,k,j,P_NI29)
    ni_old(k,30) = scalar_old(i,k,j,P_NI30)
    ni_old(k,31) = scalar_old(i,k,j,P_NI31)
    ni_old(k,32) = scalar_old(i,k,j,P_NI32)
    ni_old(k,33) = scalar_old(i,k,j,P_NI33)
    ni_old(k,34) = scalar_old(i,k,j,P_NI34)
    ni_old(k,35) = scalar_old(i,k,j,P_NI35)
    ni_old(k,36) = scalar_old(i,k,j,P_NI36)	
!! Rimed snowflakes number
    nsr_old(k,1) = scalar_old(i,k,j,P_NX1)
    nsr_old(k,2) = scalar_old(i,k,j,P_NX2)
    nsr_old(k,3) = scalar_old(i,k,j,P_NX3)
    nsr_old(k,4) = scalar_old(i,k,j,P_NX4)
    nsr_old(k,5) = scalar_old(i,k,j,P_NX5)
    nsr_old(k,6) = scalar_old(i,k,j,P_NX6)
    nsr_old(k,7) = scalar_old(i,k,j,P_NX7)
    nsr_old(k,8) = scalar_old(i,k,j,P_NX8)
    nsr_old(k,9) = scalar_old(i,k,j,P_NX9)
    nsr_old(k,10) = scalar_old(i,k,j,P_NX10)
    nsr_old(k,11) = scalar_old(i,k,j,P_NX11)
    nsr_old(k,12) = scalar_old(i,k,j,P_NX12)
    nsr_old(k,13) = scalar_old(i,k,j,P_NX13)
    nsr_old(k,14) = scalar_old(i,k,j,P_NX14)
    nsr_old(k,15) = scalar_old(i,k,j,P_NX15)
    nsr_old(k,16) = scalar_old(i,k,j,P_NX16)
    nsr_old(k,17) = scalar_old(i,k,j,P_NX17)
    nsr_old(k,18) = scalar_old(i,k,j,P_NX18)
    nsr_old(k,19) = scalar_old(i,k,j,P_NX19)
    nsr_old(k,20) = scalar_old(i,k,j,P_NX20)
    nsr_old(k,21) = scalar_old(i,k,j,P_NX21)
    nsr_old(k,22) = scalar_old(i,k,j,P_NX22)
    nsr_old(k,23) = scalar_old(i,k,j,P_NX23)
    nsr_old(k,24) = scalar_old(i,k,j,P_NX24)
    nsr_old(k,25) = scalar_old(i,k,j,P_NX25)
    nsr_old(k,26) = scalar_old(i,k,j,P_NX26)
    nsr_old(k,27) = scalar_old(i,k,j,P_NX27)
    nsr_old(k,28) = scalar_old(i,k,j,P_NX28)
    nsr_old(k,29) = scalar_old(i,k,j,P_NX29)
    nsr_old(k,30) = scalar_old(i,k,j,P_NX30)
    nsr_old(k,31) = scalar_old(i,k,j,P_NX31)
    nsr_old(k,32) = scalar_old(i,k,j,P_NX32)
    nsr_old(k,33) = scalar_old(i,k,j,P_NX33)
    nsr_old(k,34) = scalar_old(i,k,j,P_NX34)
    nsr_old(k,35) = scalar_old(i,k,j,P_NX35)
    nsr_old(k,36) = scalar_old(i,k,j,P_NX36)	


END SUBROUTINE read_in_bin	
!+---------------------------------------------------------+
!+---------------------------------------------------------+
SUBROUTINE write_out_bin(qw,qi, 	&
  &					   qs,qg,qsr,qsm,qgm,nw,   &
  &					   ni,ns,ng,nsr,scalar,  &
  &					   n_scalar,            &  
  &                    ids,ide, jds,jde, kds,kde,  &
  &                    ims,ime, jms,jme, kms,kme,  &
  &                    its,ite, jts,jte, kts,kte,  &
  &                    i,j,k)
  
  
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: i,j,k
  INTEGER, INTENT(IN) :: ims,ime,kms,kme,jms,jme,ids,ide,jds,jde,kds,kde,its,ite,jts,jte,kts,kte
  INTEGER, PARAMETER :: nbin = 36
  INTEGER, INTENT(IN) :: n_scalar
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(INOUT) :: scalar
  REAL, DIMENSION(KTS:KTE, nbin), INTENT(IN) ::     &
  &    qw,qi,qs,qg,qsr,qsm,qgm,nw,ni,ns,ng,nsr

  !! Mixing ratios
!! Water drops
    scalar(i,k,j,P_MC1) = qw(k,1)
    scalar(i,k,j,P_MC2) = qw(k,2)
    scalar(i,k,j,P_MC3) = qw(k,3) 
    scalar(i,k,j,P_MC4) = qw(k,4) 
    scalar(i,k,j,P_MC5) = qw(k,5)
    scalar(i,k,j,P_MC6) = qw(k,6)
    scalar(i,k,j,P_MC7) = qw(k,7)
    scalar(i,k,j,P_MC8) = qw(k,8)
    scalar(i,k,j,P_MC9) = qw(k,9)
    scalar(i,k,j,P_MC10) = qw(k,10)
    scalar(i,k,j,P_MC11) = qw(k,11) 
    scalar(i,k,j,P_MC12) = qw(k,12) 
    scalar(i,k,j,P_MC13) = qw(k,13)
    scalar(i,k,j,P_MC14) = qw(k,14) 
    scalar(i,k,j,P_MC15) = qw(k,15) 
    scalar(i,k,j,P_MC16) = qw(k,16)
    scalar(i,k,j,P_MC17) = qw(k,17)  
    scalar(i,k,j,P_MC18) = qw(k,18) 
    scalar(i,k,j,P_MC19) = qw(k,19) 
    scalar(i,k,j,P_MC20) = qw(k,20)
    scalar(i,k,j,P_MC21) = qw(k,21) 
    scalar(i,k,j,P_MC22) = qw(k,22) 
    scalar(i,k,j,P_MC23) = qw(k,23)
    scalar(i,k,j,P_MC24) = qw(k,24)
    scalar(i,k,j,P_MC25) = qw(k,25)
    scalar(i,k,j,P_MC26) = qw(k,26)
    scalar(i,k,j,P_MC27) = qw(k,27)
    scalar(i,k,j,P_MC28) = qw(k,28)
    scalar(i,k,j,P_MC29) = qw(k,29)
    scalar(i,k,j,P_MC30) = qw(k,30) 
    scalar(i,k,j,P_MC31) = qw(k,31)
    scalar(i,k,j,P_MC32) = qw(k,32)  
    scalar(i,k,j,P_MC33) = qw(k,33) 
    scalar(i,k,j,P_MC34) = qw(k,34) 
    scalar(i,k,j,P_MC35) = qw(k,35) 
    scalar(i,k,j,P_MC36) = qw(k,36)
	
!! Ice crystals
    scalar(i,k,j,P_MI1) = qi(k,1)
    scalar(i,k,j,P_MI2) = qi(k,2)
    scalar(i,k,j,P_MI3) = qi(k,3) 
    scalar(i,k,j,P_MI4) = qi(k,4) 
    scalar(i,k,j,P_MI5) = qi(k,5)
    scalar(i,k,j,P_MI6) = qi(k,6)
    scalar(i,k,j,P_MI7) = qi(k,7)
    scalar(i,k,j,P_MI8) = qi(k,8)
    scalar(i,k,j,P_MI9) = qi(k,9)
    scalar(i,k,j,P_MI10) = qi(k,10)
    scalar(i,k,j,P_MI11) = qi(k,11) 
    scalar(i,k,j,P_MI12) = qi(k,12) 
    scalar(i,k,j,P_MI13) = qi(k,13)
    scalar(i,k,j,P_MI14) = qi(k,14) 
    scalar(i,k,j,P_MI15) = qi(k,15) 
    scalar(i,k,j,P_MI16) = qi(k,16)
    scalar(i,k,j,P_MI17) = qi(k,17)  
    scalar(i,k,j,P_MI18) = qi(k,18) 
    scalar(i,k,j,P_MI19) = qi(k,19) 
    scalar(i,k,j,P_MI20) = qi(k,20)
    scalar(i,k,j,P_MI21) = qi(k,21) 
    scalar(i,k,j,P_MI22) = qi(k,22) 
    scalar(i,k,j,P_MI23) = qi(k,23)
    scalar(i,k,j,P_MI24) = qi(k,24)
    scalar(i,k,j,P_MI25) = qi(k,25)
    scalar(i,k,j,P_MI26) = qi(k,26)
    scalar(i,k,j,P_MI27) = qi(k,27)
    scalar(i,k,j,P_MI28) = qi(k,28)
    scalar(i,k,j,P_MI29) = qi(k,29)
    scalar(i,k,j,P_MI30) = qi(k,30) 
    scalar(i,k,j,P_MI31) = qi(k,31)
    scalar(i,k,j,P_MI32) = qi(k,32)  
    scalar(i,k,j,P_MI33) = qi(k,33) 
    scalar(i,k,j,P_MI34) = qi(k,34) 
    scalar(i,k,j,P_MI35) = qi(k,35) 
    scalar(i,k,j,P_MI36) = qi(k,36)
	
!! Snowflakes
    scalar(i,k,j,P_MR1) = qs(k,1)
    scalar(i,k,j,P_MR2) = qs(k,2)
    scalar(i,k,j,P_MR3) = qs(k,3) 
    scalar(i,k,j,P_MR4) = qs(k,4) 
    scalar(i,k,j,P_MR5) = qs(k,5)
    scalar(i,k,j,P_MR6) = qs(k,6)
    scalar(i,k,j,P_MR7) = qs(k,7)
    scalar(i,k,j,P_MR8) = qs(k,8)
    scalar(i,k,j,P_MR9) = qs(k,9)
    scalar(i,k,j,P_MR10) = qs(k,10)
    scalar(i,k,j,P_MR11) = qs(k,11) 
    scalar(i,k,j,P_MR12) = qs(k,12) 
    scalar(i,k,j,P_MR13) = qs(k,13)
    scalar(i,k,j,P_MR14) = qs(k,14) 
    scalar(i,k,j,P_MR15) = qs(k,15) 
    scalar(i,k,j,P_MR16) = qs(k,16)
    scalar(i,k,j,P_MR17) = qs(k,17)  
    scalar(i,k,j,P_MR18) = qs(k,18) 
    scalar(i,k,j,P_MR19) = qs(k,19) 
    scalar(i,k,j,P_MR20) = qs(k,20)
    scalar(i,k,j,P_MR21) = qs(k,21) 
    scalar(i,k,j,P_MR22) = qs(k,22) 
    scalar(i,k,j,P_MR23) = qs(k,23)
    scalar(i,k,j,P_MR24) = qs(k,24)
    scalar(i,k,j,P_MR25) = qs(k,25)
    scalar(i,k,j,P_MR26) = qs(k,26)
    scalar(i,k,j,P_MR27) = qs(k,27)
    scalar(i,k,j,P_MR28) = qs(k,28)
    scalar(i,k,j,P_MR29) = qs(k,29)
    scalar(i,k,j,P_MR30) = qs(k,30) 
    scalar(i,k,j,P_MR31) = qs(k,31)
    scalar(i,k,j,P_MR32) = qs(k,32)  
    scalar(i,k,j,P_MR33) = qs(k,33) 
    scalar(i,k,j,P_MR34) = qs(k,34) 
    scalar(i,k,j,P_MR35) = qs(k,35) 
    scalar(i,k,j,P_MR36) = qs(k,36)
	
!! Graupel particles
    scalar(i,k,j,P_MG1) = qg(k,1)
    scalar(i,k,j,P_MG2) = qg(k,2)
    scalar(i,k,j,P_MG3) = qg(k,3) 
    scalar(i,k,j,P_MG4) = qg(k,4) 
    scalar(i,k,j,P_MG5) = qg(k,5)
    scalar(i,k,j,P_MG6) = qg(k,6)
    scalar(i,k,j,P_MG7) = qg(k,7)
    scalar(i,k,j,P_MG8) = qg(k,8)
    scalar(i,k,j,P_MG9) = qg(k,9)
    scalar(i,k,j,P_MG10) = qg(k,10)
    scalar(i,k,j,P_MG11) = qg(k,11) 
    scalar(i,k,j,P_MG12) = qg(k,12) 
    scalar(i,k,j,P_MG13) = qg(k,13)
    scalar(i,k,j,P_MG14) = qg(k,14) 
    scalar(i,k,j,P_MG15) = qg(k,15) 
    scalar(i,k,j,P_MG16) = qg(k,16)
    scalar(i,k,j,P_MG17) = qg(k,17)  
    scalar(i,k,j,P_MG18) = qg(k,18) 
    scalar(i,k,j,P_MG19) = qg(k,19) 
    scalar(i,k,j,P_MG20) = qg(k,20)
    scalar(i,k,j,P_MG21) = qg(k,21) 
    scalar(i,k,j,P_MG22) = qg(k,22) 
    scalar(i,k,j,P_MG23) = qg(k,23)
    scalar(i,k,j,P_MG24) = qg(k,24)
    scalar(i,k,j,P_MG25) = qg(k,25)
    scalar(i,k,j,P_MG26) = qg(k,26)
    scalar(i,k,j,P_MG27) = qg(k,27)
    scalar(i,k,j,P_MG28) = qg(k,28)
    scalar(i,k,j,P_MG29) = qg(k,29)
    scalar(i,k,j,P_MG30) = qg(k,30) 
    scalar(i,k,j,P_MG31) = qg(k,31)
    scalar(i,k,j,P_MG32) = qg(k,32)  
    scalar(i,k,j,P_MG33) = qg(k,33) 
    scalar(i,k,j,P_MG34) = qg(k,34) 
    scalar(i,k,j,P_MG35) = qg(k,35) 
    scalar(i,k,j,P_MG36) = qg(k,36)
	
!! Rimed snowflakes
    scalar(i,k,j,P_MX1) = qsr(k,1)
    scalar(i,k,j,P_MX2) = qsr(k,2)
    scalar(i,k,j,P_MX3) = qsr(k,3) 
    scalar(i,k,j,P_MX4) = qsr(k,4) 
    scalar(i,k,j,P_MX5) = qsr(k,5)
    scalar(i,k,j,P_MX6) = qsr(k,6)
    scalar(i,k,j,P_MX7) = qsr(k,7)
    scalar(i,k,j,P_MX8) = qsr(k,8)
    scalar(i,k,j,P_MX9) = qsr(k,9)
    scalar(i,k,j,P_MX10) = qsr(k,10)
    scalar(i,k,j,P_MX11) = qsr(k,11) 
    scalar(i,k,j,P_MX12) = qsr(k,12) 
    scalar(i,k,j,P_MX13) = qsr(k,13)
    scalar(i,k,j,P_MX14) = qsr(k,14) 
    scalar(i,k,j,P_MX15) = qsr(k,15) 
    scalar(i,k,j,P_MX16) = qsr(k,16)
    scalar(i,k,j,P_MX17) = qsr(k,17)  
    scalar(i,k,j,P_MX18) = qsr(k,18) 
    scalar(i,k,j,P_MX19) = qsr(k,19) 
    scalar(i,k,j,P_MX20) = qsr(k,20)
    scalar(i,k,j,P_MX21) = qsr(k,21) 
    scalar(i,k,j,P_MX22) = qsr(k,22) 
    scalar(i,k,j,P_MX23) = qsr(k,23)
    scalar(i,k,j,P_MX24) = qsr(k,24)
    scalar(i,k,j,P_MX25) = qsr(k,25)
    scalar(i,k,j,P_MX26) = qsr(k,26)
    scalar(i,k,j,P_MX27) = qsr(k,27)
    scalar(i,k,j,P_MX28) = qsr(k,28)
    scalar(i,k,j,P_MX29) = qsr(k,29)
    scalar(i,k,j,P_MX30) = qsr(k,30) 
    scalar(i,k,j,P_MX31) = qsr(k,31)
    scalar(i,k,j,P_MX32) = qsr(k,32)  
    scalar(i,k,j,P_MX33) = qsr(k,33) 
    scalar(i,k,j,P_MX34) = qsr(k,34) 
    scalar(i,k,j,P_MX35) = qsr(k,35) 
    scalar(i,k,j,P_MX36) = qsr(k,36)
	
!! Melted snowflakes
    scalar(i,k,j,P_MY1) = qsm(k,1)
    scalar(i,k,j,P_MY2) = qsm(k,2)
    scalar(i,k,j,P_MY3) = qsm(k,3) 
    scalar(i,k,j,P_MY4) = qsm(k,4) 
    scalar(i,k,j,P_MY5) = qsm(k,5)
    scalar(i,k,j,P_MY6) = qsm(k,6)
    scalar(i,k,j,P_MY7) = qsm(k,7)
    scalar(i,k,j,P_MY8) = qsm(k,8)
    scalar(i,k,j,P_MY9) = qsm(k,9)
    scalar(i,k,j,P_MY10) = qsm(k,10)
    scalar(i,k,j,P_MY11) = qsm(k,11) 
    scalar(i,k,j,P_MY12) = qsm(k,12) 
    scalar(i,k,j,P_MY13) = qsm(k,13)
    scalar(i,k,j,P_MY14) = qsm(k,14) 
    scalar(i,k,j,P_MY15) = qsm(k,15) 
    scalar(i,k,j,P_MY16) = qsm(k,16)
    scalar(i,k,j,P_MY17) = qsm(k,17)  
    scalar(i,k,j,P_MY18) = qsm(k,18) 
    scalar(i,k,j,P_MY19) = qsm(k,19) 
    scalar(i,k,j,P_MY20) = qsm(k,20)
    scalar(i,k,j,P_MY21) = qsm(k,21) 
    scalar(i,k,j,P_MY22) = qsm(k,22) 
    scalar(i,k,j,P_MY23) = qsm(k,23)
    scalar(i,k,j,P_MY24) = qsm(k,24)
    scalar(i,k,j,P_MY25) = qsm(k,25)
    scalar(i,k,j,P_MY26) = qsm(k,26)
    scalar(i,k,j,P_MY27) = qsm(k,27)
    scalar(i,k,j,P_MY28) = qsm(k,28)
    scalar(i,k,j,P_MY29) = qsm(k,29)
    scalar(i,k,j,P_MY30) = qsm(k,30) 
    scalar(i,k,j,P_MY31) = qsm(k,31)
    scalar(i,k,j,P_MY32) = qsm(k,32)  
    scalar(i,k,j,P_MY33) = qsm(k,33) 
    scalar(i,k,j,P_MY34) = qsm(k,34) 
    scalar(i,k,j,P_MY35) = qsm(k,35) 
    scalar(i,k,j,P_MY36) = qsm(k,36)
	
!! Melted graupel
    scalar(i,k,j,P_MZ1) = qgm(k,1)
    scalar(i,k,j,P_MZ2) = qgm(k,2)
    scalar(i,k,j,P_MZ3) = qgm(k,3) 
    scalar(i,k,j,P_MZ4) = qgm(k,4) 
    scalar(i,k,j,P_MZ5) = qgm(k,5)
    scalar(i,k,j,P_MZ6) = qgm(k,6)
    scalar(i,k,j,P_MZ7) = qgm(k,7)
    scalar(i,k,j,P_MZ8) = qgm(k,8)
    scalar(i,k,j,P_MZ9) = qgm(k,9)
    scalar(i,k,j,P_MZ10) = qgm(k,10)
    scalar(i,k,j,P_MZ11) = qgm(k,11) 
    scalar(i,k,j,P_MZ12) = qgm(k,12) 
    scalar(i,k,j,P_MZ13) = qgm(k,13)
    scalar(i,k,j,P_MZ14) = qgm(k,14) 
    scalar(i,k,j,P_MZ15) = qgm(k,15) 
    scalar(i,k,j,P_MZ16) = qgm(k,16)
    scalar(i,k,j,P_MZ17) = qgm(k,17)  
    scalar(i,k,j,P_MZ18) = qgm(k,18) 
    scalar(i,k,j,P_MZ19) = qgm(k,19) 
    scalar(i,k,j,P_MZ20) = qgm(k,20)
    scalar(i,k,j,P_MZ21) = qgm(k,21) 
    scalar(i,k,j,P_MZ22) = qgm(k,22) 
    scalar(i,k,j,P_MZ23) = qgm(k,23)
    scalar(i,k,j,P_MZ24) = qgm(k,24)
    scalar(i,k,j,P_MZ25) = qgm(k,25)
    scalar(i,k,j,P_MZ26) = qgm(k,26)
    scalar(i,k,j,P_MZ27) = qgm(k,27)
    scalar(i,k,j,P_MZ28) = qgm(k,28)
    scalar(i,k,j,P_MZ29) = qgm(k,29)
    scalar(i,k,j,P_MZ30) = qgm(k,30) 
    scalar(i,k,j,P_MZ31) = qgm(k,31)
    scalar(i,k,j,P_MZ32) = qgm(k,32)  
    scalar(i,k,j,P_MZ33) = qgm(k,33) 
    scalar(i,k,j,P_MZ34) = qgm(k,34) 
    scalar(i,k,j,P_MZ35) = qgm(k,35) 
    scalar(i,k,j,P_MZ36) = qgm(k,36)
	
  !! Number concentrations
!! Water drops  
    scalar(i,k,j,P_NC1) = nw(k,1)
    scalar(i,k,j,P_NC2) = nw(k,2)
    scalar(i,k,j,P_NC3) = nw(k,3) 
    scalar(i,k,j,P_NC4) = nw(k,4) 
    scalar(i,k,j,P_NC5) = nw(k,5)
    scalar(i,k,j,P_NC6) = nw(k,6)
    scalar(i,k,j,P_NC7) = nw(k,7)
    scalar(i,k,j,P_NC8) = nw(k,8)
    scalar(i,k,j,P_NC9) = nw(k,9)
    scalar(i,k,j,P_NC10) = nw(k,10)
    scalar(i,k,j,P_NC11) = nw(k,11) 
    scalar(i,k,j,P_NC12) = nw(k,12) 
    scalar(i,k,j,P_NC13) = nw(k,13)
    scalar(i,k,j,P_NC14) = nw(k,14) 
    scalar(i,k,j,P_NC15) = nw(k,15) 
    scalar(i,k,j,P_NC16) = nw(k,16)
    scalar(i,k,j,P_NC17) = nw(k,17)  
    scalar(i,k,j,P_NC18) = nw(k,18) 
    scalar(i,k,j,P_NC19) = nw(k,19) 
    scalar(i,k,j,P_NC20) = nw(k,20)
    scalar(i,k,j,P_NC21) = nw(k,21) 
    scalar(i,k,j,P_NC22) = nw(k,22) 
    scalar(i,k,j,P_NC23) = nw(k,23)
    scalar(i,k,j,P_NC24) = nw(k,24)
    scalar(i,k,j,P_NC25) = nw(k,25)
    scalar(i,k,j,P_NC26) = nw(k,26)
    scalar(i,k,j,P_NC27) = nw(k,27)
    scalar(i,k,j,P_NC28) = nw(k,28)
    scalar(i,k,j,P_NC29) = nw(k,29)
    scalar(i,k,j,P_NC30) = nw(k,30) 
    scalar(i,k,j,P_NC31) = nw(k,31)
    scalar(i,k,j,P_NC32) = nw(k,32)  
    scalar(i,k,j,P_NC33) = nw(k,33) 
    scalar(i,k,j,P_NC34) = nw(k,34) 
    scalar(i,k,j,P_NC35) = nw(k,35) 
    scalar(i,k,j,P_NC36) = nw(k,36)
	
!! Snowflakes	
    scalar(i,k,j,P_NR1) = ns(k,1)
    scalar(i,k,j,P_NR2) = ns(k,2)
    scalar(i,k,j,P_NR3) = ns(k,3) 
    scalar(i,k,j,P_NR4) = ns(k,4) 
    scalar(i,k,j,P_NR5) = ns(k,5)
    scalar(i,k,j,P_NR6) = ns(k,6)
    scalar(i,k,j,P_NR7) = ns(k,7)
    scalar(i,k,j,P_NR8) = ns(k,8)
    scalar(i,k,j,P_NR9) = ns(k,9)
    scalar(i,k,j,P_NR10) = ns(k,10)
    scalar(i,k,j,P_NR11) = ns(k,11) 
    scalar(i,k,j,P_NR12) = ns(k,12) 
    scalar(i,k,j,P_NR13) = ns(k,13)
    scalar(i,k,j,P_NR14) = ns(k,14) 
    scalar(i,k,j,P_NR15) = ns(k,15) 
    scalar(i,k,j,P_NR16) = ns(k,16)
    scalar(i,k,j,P_NR17) = ns(k,17)  
    scalar(i,k,j,P_NR18) = ns(k,18) 
    scalar(i,k,j,P_NR19) = ns(k,19) 
    scalar(i,k,j,P_NR20) = ns(k,20)
    scalar(i,k,j,P_NR21) = ns(k,21) 
    scalar(i,k,j,P_NR22) = ns(k,22) 
    scalar(i,k,j,P_NR23) = ns(k,23)
    scalar(i,k,j,P_NR24) = ns(k,24)
    scalar(i,k,j,P_NR25) = ns(k,25)
    scalar(i,k,j,P_NR26) = ns(k,26)
    scalar(i,k,j,P_NR27) = ns(k,27)
    scalar(i,k,j,P_NR28) = ns(k,28)
    scalar(i,k,j,P_NR29) = ns(k,29)
    scalar(i,k,j,P_NR30) = ns(k,30) 
    scalar(i,k,j,P_NR31) = ns(k,31)
    scalar(i,k,j,P_NR32) = ns(k,32)  
    scalar(i,k,j,P_NR33) = ns(k,33) 
    scalar(i,k,j,P_NR34) = ns(k,34) 
    scalar(i,k,j,P_NR35) = ns(k,35) 
    scalar(i,k,j,P_NR36) = ns(k,36)
	
!! Graupel particles
    scalar(i,k,j,P_NG1) = ng(k,1)
    scalar(i,k,j,P_NG2) = ng(k,2)
    scalar(i,k,j,P_NG3) = ng(k,3) 
    scalar(i,k,j,P_NG4) = ng(k,4) 
    scalar(i,k,j,P_NG5) = ng(k,5)
    scalar(i,k,j,P_NG6) = ng(k,6)
    scalar(i,k,j,P_NG7) = ng(k,7)
    scalar(i,k,j,P_NG8) = ng(k,8)
    scalar(i,k,j,P_NG9) = ng(k,9)
    scalar(i,k,j,P_NG10) = ng(k,10)
    scalar(i,k,j,P_NG11) = ng(k,11) 
    scalar(i,k,j,P_NG12) = ng(k,12) 
    scalar(i,k,j,P_NG13) = ng(k,13)
    scalar(i,k,j,P_NG14) = ng(k,14) 
    scalar(i,k,j,P_NG15) = ng(k,15) 
    scalar(i,k,j,P_NG16) = ng(k,16)
    scalar(i,k,j,P_NG17) = ng(k,17)  
    scalar(i,k,j,P_NG18) = ng(k,18) 
    scalar(i,k,j,P_NG19) = ng(k,19) 
    scalar(i,k,j,P_NG20) = ng(k,20)
    scalar(i,k,j,P_NG21) = ng(k,21) 
    scalar(i,k,j,P_NG22) = ng(k,22) 
    scalar(i,k,j,P_NG23) = ng(k,23)
    scalar(i,k,j,P_NG24) = ng(k,24)
    scalar(i,k,j,P_NG25) = ng(k,25)
    scalar(i,k,j,P_NG26) = ng(k,26)
    scalar(i,k,j,P_NG27) = ng(k,27)
    scalar(i,k,j,P_NG28) = ng(k,28)
    scalar(i,k,j,P_NG29) = ng(k,29)
    scalar(i,k,j,P_NG30) = ng(k,30) 
    scalar(i,k,j,P_NG31) = ng(k,31)
    scalar(i,k,j,P_NG32) = ng(k,32)  
    scalar(i,k,j,P_NG33) = ng(k,33) 
    scalar(i,k,j,P_NG34) = ng(k,34) 
    scalar(i,k,j,P_NG35) = ng(k,35) 
    scalar(i,k,j,P_NG36) = ng(k,36)
	
!! Ice crystals
    scalar(i,k,j,P_NI1) = ni(k,1)
    scalar(i,k,j,P_NI2) = ni(k,2)
    scalar(i,k,j,P_NI3) = ni(k,3) 
    scalar(i,k,j,P_NI4) = ni(k,4) 
    scalar(i,k,j,P_NI5) = ni(k,5)
    scalar(i,k,j,P_NI6) = ni(k,6)
    scalar(i,k,j,P_NI7) = ni(k,7)
    scalar(i,k,j,P_NI8) = ni(k,8)
    scalar(i,k,j,P_NI9) = ni(k,9)
    scalar(i,k,j,P_NI10) = ni(k,10)
    scalar(i,k,j,P_NI11) = ni(k,11) 
    scalar(i,k,j,P_NI12) = ni(k,12) 
    scalar(i,k,j,P_NI13) = ni(k,13)
    scalar(i,k,j,P_NI14) = ni(k,14) 
    scalar(i,k,j,P_NI15) = ni(k,15) 
    scalar(i,k,j,P_NI16) = ni(k,16)
    scalar(i,k,j,P_NI17) = ni(k,17)  
    scalar(i,k,j,P_NI18) = ni(k,18) 
    scalar(i,k,j,P_NI19) = ni(k,19) 
    scalar(i,k,j,P_NI20) = ni(k,20)
    scalar(i,k,j,P_NI21) = ni(k,21) 
    scalar(i,k,j,P_NI22) = ni(k,22) 
    scalar(i,k,j,P_NI23) = ni(k,23)
    scalar(i,k,j,P_NI24) = ni(k,24)
    scalar(i,k,j,P_NI25) = ni(k,25)
    scalar(i,k,j,P_NI26) = ni(k,26)
    scalar(i,k,j,P_NI27) = ni(k,27)
    scalar(i,k,j,P_NI28) = ni(k,28)
    scalar(i,k,j,P_NI29) = ni(k,29)
    scalar(i,k,j,P_NI30) = ni(k,30) 
    scalar(i,k,j,P_NI31) = ni(k,31)
    scalar(i,k,j,P_NI32) = ni(k,32)  
    scalar(i,k,j,P_NI33) = ni(k,33) 
    scalar(i,k,j,P_NI34) = ni(k,34) 
    scalar(i,k,j,P_NI35) = ni(k,35) 
    scalar(i,k,j,P_NI36) = ni(k,36)
	
!! Rimed snowflakes number
    scalar(i,k,j,P_NX1) = nsr(k,1)
    scalar(i,k,j,P_NX2) = nsr(k,2)
    scalar(i,k,j,P_NX3) = nsr(k,3) 
    scalar(i,k,j,P_NX4) = nsr(k,4) 
    scalar(i,k,j,P_NX5) = nsr(k,5)
    scalar(i,k,j,P_NX6) = nsr(k,6)
    scalar(i,k,j,P_NX7) = nsr(k,7)
    scalar(i,k,j,P_NX8) = nsr(k,8)
    scalar(i,k,j,P_NX9) = nsr(k,9)
    scalar(i,k,j,P_NX10) = nsr(k,10)
    scalar(i,k,j,P_NX11) = nsr(k,11) 
    scalar(i,k,j,P_NX12) = nsr(k,12) 
    scalar(i,k,j,P_NX13) = nsr(k,13)
    scalar(i,k,j,P_NX14) = nsr(k,14) 
    scalar(i,k,j,P_NX15) = nsr(k,15) 
    scalar(i,k,j,P_NX16) = nsr(k,16)
    scalar(i,k,j,P_NX17) = nsr(k,17)  
    scalar(i,k,j,P_NX18) = nsr(k,18) 
    scalar(i,k,j,P_NX19) = nsr(k,19) 
    scalar(i,k,j,P_NX20) = nsr(k,20)
    scalar(i,k,j,P_NX21) = nsr(k,21) 
    scalar(i,k,j,P_NX22) = nsr(k,22) 
    scalar(i,k,j,P_NX23) = nsr(k,23)
    scalar(i,k,j,P_NX24) = nsr(k,24)
    scalar(i,k,j,P_NX25) = nsr(k,25)
    scalar(i,k,j,P_NX26) = nsr(k,26)
    scalar(i,k,j,P_NX27) = nsr(k,27)
    scalar(i,k,j,P_NX28) = nsr(k,28)
    scalar(i,k,j,P_NX29) = nsr(k,29)
    scalar(i,k,j,P_NX30) = nsr(k,30) 
    scalar(i,k,j,P_NX31) = nsr(k,31)
    scalar(i,k,j,P_NX32) = nsr(k,32)  
    scalar(i,k,j,P_NX33) = nsr(k,33) 
    scalar(i,k,j,P_NX34) = nsr(k,34) 
    scalar(i,k,j,P_NX35) = nsr(k,35) 
    scalar(i,k,j,P_NX36) = nsr(k,36)

END SUBROUTINE write_out_bin	
!+---------------------------------------------------------+
!+---------------------------------------------------------+
!+----------------------------------------------------------------------+
SUBROUTINE read_in_bin_pg(qw,qw_old,qi,qi_old, 	&
  &		          qs,qs_old,qg,qg_old, 	&
  &			  qsr,qsr_old,qsm,qsm_old, &
  &  		          qgm,qgm_old,nw,nw_old,   &
  &		          ni,ni_old,ns,ns_old,ng,  &
  &		          ng_old,nsr,nsr_old,		&
  &					scalar,  &
  &		          scalar_old,n_scalar,&  
  &                    ids,ide, jds,jde, kds,kde,  &
  &                    ims,ime, jms,jme, kms,kme,  &
  &                    its,ite, jts,jte, kts,kte,  &
  &                    i,j,k)
  
  
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: i,j,k
  INTEGER, INTENT(IN) :: ims,ime,kms,kme,jms,jme,ids,ide,jds,jde,kds,kde,its,ite,jts,jte,kts,kte
  INTEGER, PARAMETER :: nbin = 36
  INTEGER, INTENT(IN) :: n_scalar
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar_old
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(IN) :: scalar
  REAL, DIMENSION(KTS:KTE, nbin), INTENT(INOUT) ::     &
  &    qw,qw_old,qi,qi_old,qs,qs_old,qg,qg_old, 	&
  &	   qsr,qsr_old,qsm,qsm_old,qgm,qgm_old,nw,nw_old,   &
  &	   ni,ni_old,ns,ns_old,ng,ng_old,nsr,nsr_old
 
  !! Mixing ratios
!! Water drops
    qw(k,1) = scalar(i,k,j,P_MC1_PG)
    qw(k,2) = scalar(i,k,j,P_MC2_PG)
    qw(k,3) = scalar(i,k,j,P_MC3_PG)
    qw(k,4) = scalar(i,k,j,P_MC4_PG)
    qw(k,5) = scalar(i,k,j,P_MC5_PG)
    qw(k,6) = scalar(i,k,j,P_MC6_PG)
    qw(k,7) = scalar(i,k,j,P_MC7_PG)
    qw(k,8) = scalar(i,k,j,P_MC8_PG)
    qw(k,9) = scalar(i,k,j,P_MC9_PG)
    qw(k,10) = scalar(i,k,j,P_MC10_PG)
    qw(k,11) = scalar(i,k,j,P_MC11_PG)
    qw(k,12) = scalar(i,k,j,P_MC12_PG)
    qw(k,13) = scalar(i,k,j,P_MC13_PG)
    qw(k,14) = scalar(i,k,j,P_MC14_PG)
    qw(k,15) = scalar(i,k,j,P_MC15_PG)
    qw(k,16) = scalar(i,k,j,P_MC16_PG)
    qw(k,17) = scalar(i,k,j,P_MC17_PG)
    qw(k,18) = scalar(i,k,j,P_MC18_PG)
    qw(k,19) = scalar(i,k,j,P_MC19_PG)
    qw(k,20) = scalar(i,k,j,P_MC20_PG)
    qw(k,21) = scalar(i,k,j,P_MC21_PG)
    qw(k,22) = scalar(i,k,j,P_MC22_PG)
    qw(k,23) = scalar(i,k,j,P_MC23_PG)
    qw(k,24) = scalar(i,k,j,P_MC24_PG)
    qw(k,25) = scalar(i,k,j,P_MC25_PG)
    qw(k,26) = scalar(i,k,j,P_MC26_PG)
    qw(k,27) = scalar(i,k,j,P_MC27_PG)
    qw(k,28) = scalar(i,k,j,P_MC28_PG)
    qw(k,29) = scalar(i,k,j,P_MC29_PG)
    qw(k,30) = scalar(i,k,j,P_MC30_PG)
    qw(k,31) = scalar(i,k,j,P_MC31_PG)
    qw(k,32) = scalar(i,k,j,P_MC32_PG)
    qw(k,33) = scalar(i,k,j,P_MC33_PG)
    qw(k,34) = scalar(i,k,j,P_MC34_PG)
    qw(k,35) = scalar(i,k,j,P_MC35_PG)
    qw(k,36) = scalar(i,k,j,P_MC36_PG)  
!! Ice crystals
    qi(k,1) = scalar(i,k,j,P_MI1_PG)
    qi(k,2) = scalar(i,k,j,P_MI2_PG)
    qi(k,3) = scalar(i,k,j,P_MI3_PG)
    qi(k,4) = scalar(i,k,j,P_MI4_PG)
    qi(k,5) = scalar(i,k,j,P_MI5_PG)
    qi(k,6) = scalar(i,k,j,P_MI6_PG)
    qi(k,7) = scalar(i,k,j,P_MI7_PG)
    qi(k,8) = scalar(i,k,j,P_MI8_PG)
    qi(k,9) = scalar(i,k,j,P_MI9_PG)
    qi(k,10) = scalar(i,k,j,P_MI10_PG)
    qi(k,11) = scalar(i,k,j,P_MI11_PG)
    qi(k,12) = scalar(i,k,j,P_MI12_PG)
    qi(k,13) = scalar(i,k,j,P_MI13_PG)
    qi(k,14) = scalar(i,k,j,P_MI14_PG)
    qi(k,15) = scalar(i,k,j,P_MI15_PG)
    qi(k,16) = scalar(i,k,j,P_MI16_PG)
    qi(k,17) = scalar(i,k,j,P_MI17_PG)
    qi(k,18) = scalar(i,k,j,P_MI18_PG)
    qi(k,19) = scalar(i,k,j,P_MI19_PG)
    qi(k,20) = scalar(i,k,j,P_MI20_PG)
    qi(k,21) = scalar(i,k,j,P_MI21_PG)
    qi(k,22) = scalar(i,k,j,P_MI22_PG)
    qi(k,23) = scalar(i,k,j,P_MI23_PG)
    qi(k,24) = scalar(i,k,j,P_MI24_PG)
    qi(k,25) = scalar(i,k,j,P_MI25_PG)
    qi(k,26) = scalar(i,k,j,P_MI26_PG)
    qi(k,27) = scalar(i,k,j,P_MI27_PG)
    qi(k,28) = scalar(i,k,j,P_MI28_PG)
    qi(k,29) = scalar(i,k,j,P_MI29_PG)
    qi(k,30) = scalar(i,k,j,P_MI30_PG)
    qi(k,31) = scalar(i,k,j,P_MI31_PG)
    qi(k,32) = scalar(i,k,j,P_MI32_PG)
    qi(k,33) = scalar(i,k,j,P_MI33_PG)
    qi(k,34) = scalar(i,k,j,P_MI34_PG)
    qi(k,35) = scalar(i,k,j,P_MI35_PG)
    qi(k,36) = scalar(i,k,j,P_MI36_PG) 
!! Snowflakes
    qs(k,1) = scalar(i,k,j,P_MR1_PG)
    qs(k,2) = scalar(i,k,j,P_MR2_PG)
    qs(k,3) = scalar(i,k,j,P_MR3_PG)
    qs(k,4) = scalar(i,k,j,P_MR4_PG)
    qs(k,5) = scalar(i,k,j,P_MR5_PG)
    qs(k,6) = scalar(i,k,j,P_MR6_PG)
    qs(k,7) = scalar(i,k,j,P_MR7_PG)
    qs(k,8) = scalar(i,k,j,P_MR8_PG)
    qs(k,9) = scalar(i,k,j,P_MR9_PG)
    qs(k,10) = scalar(i,k,j,P_MR10_PG)
    qs(k,11) = scalar(i,k,j,P_MR11_PG)
    qs(k,12) = scalar(i,k,j,P_MR12_PG)
    qs(k,13) = scalar(i,k,j,P_MR13_PG)
    qs(k,14) = scalar(i,k,j,P_MR14_PG)
    qs(k,15) = scalar(i,k,j,P_MR15_PG)
    qs(k,16) = scalar(i,k,j,P_MR16_PG)
    qs(k,17) = scalar(i,k,j,P_MR17_PG)
    qs(k,18) = scalar(i,k,j,P_MR18_PG)
    qs(k,19) = scalar(i,k,j,P_MR19_PG)
    qs(k,20) = scalar(i,k,j,P_MR20_PG)
    qs(k,21) = scalar(i,k,j,P_MR21_PG)
    qs(k,22) = scalar(i,k,j,P_MR22_PG)
    qs(k,23) = scalar(i,k,j,P_MR23_PG)
    qs(k,24) = scalar(i,k,j,P_MR24_PG)
    qs(k,25) = scalar(i,k,j,P_MR25_PG)
    qs(k,26) = scalar(i,k,j,P_MR26_PG)
    qs(k,27) = scalar(i,k,j,P_MR27_PG)
    qs(k,28) = scalar(i,k,j,P_MR28_PG)
    qs(k,29) = scalar(i,k,j,P_MR29_PG)
    qs(k,30) = scalar(i,k,j,P_MR30_PG)
    qs(k,31) = scalar(i,k,j,P_MR31_PG)
    qs(k,32) = scalar(i,k,j,P_MR32_PG)
    qs(k,33) = scalar(i,k,j,P_MR33_PG)
    qs(k,34) = scalar(i,k,j,P_MR34_PG)
    qs(k,35) = scalar(i,k,j,P_MR35_PG)
    qs(k,36) = scalar(i,k,j,P_MR36_PG)  
!! Graupel particles
    qg(k,1) = scalar(i,k,j,P_MG1_PG)
    qg(k,2) = scalar(i,k,j,P_MG2_PG)
    qg(k,3) = scalar(i,k,j,P_MG3_PG)
    qg(k,4) = scalar(i,k,j,P_MG4_PG)
    qg(k,5) = scalar(i,k,j,P_MG5_PG)
    qg(k,6) = scalar(i,k,j,P_MG6_PG)
    qg(k,7) = scalar(i,k,j,P_MG7_PG)
    qg(k,8) = scalar(i,k,j,P_MG8_PG)
    qg(k,9) = scalar(i,k,j,P_MG9_PG)
    qg(k,10) = scalar(i,k,j,P_MG10_PG)
    qg(k,11) = scalar(i,k,j,P_MG11_PG)
    qg(k,12) = scalar(i,k,j,P_MG12_PG)
    qg(k,13) = scalar(i,k,j,P_MG13_PG)
    qg(k,14) = scalar(i,k,j,P_MG14_PG)
    qg(k,15) = scalar(i,k,j,P_MG15_PG)
    qg(k,16) = scalar(i,k,j,P_MG16_PG)
    qg(k,17) = scalar(i,k,j,P_MG17_PG)
    qg(k,18) = scalar(i,k,j,P_MG18_PG)
    qg(k,19) = scalar(i,k,j,P_MG19_PG)
    qg(k,20) = scalar(i,k,j,P_MG20_PG)
    qg(k,21) = scalar(i,k,j,P_MG21_PG)
    qg(k,22) = scalar(i,k,j,P_MG22_PG)
    qg(k,23) = scalar(i,k,j,P_MG23_PG)
    qg(k,24) = scalar(i,k,j,P_MG24_PG)
    qg(k,25) = scalar(i,k,j,P_MG25_PG)
    qg(k,26) = scalar(i,k,j,P_MG26_PG)
    qg(k,27) = scalar(i,k,j,P_MG27_PG)
    qg(k,28) = scalar(i,k,j,P_MG28_PG)
    qg(k,29) = scalar(i,k,j,P_MG29_PG)
    qg(k,30) = scalar(i,k,j,P_MG30_PG)
    qg(k,31) = scalar(i,k,j,P_MG31_PG)
    qg(k,32) = scalar(i,k,j,P_MG32_PG)
    qg(k,33) = scalar(i,k,j,P_MG33_PG)
    qg(k,34) = scalar(i,k,j,P_MG34_PG)
    qg(k,35) = scalar(i,k,j,P_MG35_PG)
    qg(k,36) = scalar(i,k,j,P_MG36_PG)
!! Rimed snowflakes
    qsr(k,1) = scalar(i,k,j,P_MX1_PG)
    qsr(k,2) = scalar(i,k,j,P_MX2_PG)
    qsr(k,3) = scalar(i,k,j,P_MX3_PG)
    qsr(k,4) = scalar(i,k,j,P_MX4_PG)
    qsr(k,5) = scalar(i,k,j,P_MX5_PG)
    qsr(k,6) = scalar(i,k,j,P_MX6_PG)
    qsr(k,7) = scalar(i,k,j,P_MX7_PG)
    qsr(k,8) = scalar(i,k,j,P_MX8_PG)
    qsr(k,9) = scalar(i,k,j,P_MX9_PG)
    qsr(k,10) = scalar(i,k,j,P_MX10_PG)
    qsr(k,11) = scalar(i,k,j,P_MX11_PG)
    qsr(k,12) = scalar(i,k,j,P_MX12_PG)
    qsr(k,13) = scalar(i,k,j,P_MX13_PG)
    qsr(k,14) = scalar(i,k,j,P_MX14_PG)
    qsr(k,15) = scalar(i,k,j,P_MX15_PG)
    qsr(k,16) = scalar(i,k,j,P_MX16_PG)
    qsr(k,17) = scalar(i,k,j,P_MX17_PG)
    qsr(k,18) = scalar(i,k,j,P_MX18_PG)
    qsr(k,19) = scalar(i,k,j,P_MX19_PG)
    qsr(k,20) = scalar(i,k,j,P_MX20_PG)
    qsr(k,21) = scalar(i,k,j,P_MX21_PG)
    qsr(k,22) = scalar(i,k,j,P_MX22_PG)
    qsr(k,23) = scalar(i,k,j,P_MX23_PG)
    qsr(k,24) = scalar(i,k,j,P_MX24_PG)
    qsr(k,25) = scalar(i,k,j,P_MX25_PG)
    qsr(k,26) = scalar(i,k,j,P_MX26_PG)
    qsr(k,27) = scalar(i,k,j,P_MX27_PG)
    qsr(k,28) = scalar(i,k,j,P_MX28_PG)
    qsr(k,29) = scalar(i,k,j,P_MX29_PG)
    qsr(k,30) = scalar(i,k,j,P_MX30_PG)
    qsr(k,31) = scalar(i,k,j,P_MX31_PG)
    qsr(k,32) = scalar(i,k,j,P_MX32_PG)
    qsr(k,33) = scalar(i,k,j,P_MX33_PG)
    qsr(k,34) = scalar(i,k,j,P_MX34_PG)
    qsr(k,35) = scalar(i,k,j,P_MX35_PG)
    qsr(k,36) = scalar(i,k,j,P_MX36_PG)
!! Melted snowflakes
    qsm(k,1) = scalar(i,k,j,P_MY1_PG)
    qsm(k,2) = scalar(i,k,j,P_MY2_PG)
    qsm(k,3) = scalar(i,k,j,P_MY3_PG)
    qsm(k,4) = scalar(i,k,j,P_MY4_PG)
    qsm(k,5) = scalar(i,k,j,P_MY5_PG)
    qsm(k,6) = scalar(i,k,j,P_MY6_PG)
    qsm(k,7) = scalar(i,k,j,P_MY7_PG)
    qsm(k,8) = scalar(i,k,j,P_MY8_PG)
    qsm(k,9) = scalar(i,k,j,P_MY9_PG)
    qsm(k,10) = scalar(i,k,j,P_MY10_PG)
    qsm(k,11) = scalar(i,k,j,P_MY11_PG)
    qsm(k,12) = scalar(i,k,j,P_MY12_PG)
    qsm(k,13) = scalar(i,k,j,P_MY13_PG)
    qsm(k,14) = scalar(i,k,j,P_MY14_PG)
    qsm(k,15) = scalar(i,k,j,P_MY15_PG)
    qsm(k,16) = scalar(i,k,j,P_MY16_PG)
    qsm(k,17) = scalar(i,k,j,P_MY17_PG)
    qsm(k,18) = scalar(i,k,j,P_MY18_PG)
    qsm(k,19) = scalar(i,k,j,P_MY19_PG)
    qsm(k,20) = scalar(i,k,j,P_MY20_PG)
    qsm(k,21) = scalar(i,k,j,P_MY21_PG)
    qsm(k,22) = scalar(i,k,j,P_MY22_PG)
    qsm(k,23) = scalar(i,k,j,P_MY23_PG)
    qsm(k,24) = scalar(i,k,j,P_MY24_PG)
    qsm(k,25) = scalar(i,k,j,P_MY25_PG)
    qsm(k,26) = scalar(i,k,j,P_MY26_PG)
    qsm(k,27) = scalar(i,k,j,P_MY27_PG)
    qsm(k,28) = scalar(i,k,j,P_MY28_PG)
    qsm(k,29) = scalar(i,k,j,P_MY29_PG)
    qsm(k,30) = scalar(i,k,j,P_MY30_PG)
    qsm(k,31) = scalar(i,k,j,P_MY31_PG)
    qsm(k,32) = scalar(i,k,j,P_MY32_PG)
    qsm(k,33) = scalar(i,k,j,P_MY33_PG)
    qsm(k,34) = scalar(i,k,j,P_MY34_PG)
    qsm(k,35) = scalar(i,k,j,P_MY35_PG)
    qsm(k,36) = scalar(i,k,j,P_MY36_PG)
!! Melted graupel
    qgm(k,1) = scalar(i,k,j,P_MZ1_PG)
    qgm(k,2) = scalar(i,k,j,P_MZ2_PG)
    qgm(k,3) = scalar(i,k,j,P_MZ3_PG)
    qgm(k,4) = scalar(i,k,j,P_MZ4_PG)
    qgm(k,5) = scalar(i,k,j,P_MZ5_PG)
    qgm(k,6) = scalar(i,k,j,P_MZ6_PG)
    qgm(k,7) = scalar(i,k,j,P_MZ7_PG)
    qgm(k,8) = scalar(i,k,j,P_MZ8_PG)
    qgm(k,9) = scalar(i,k,j,P_MZ9_PG)
    qgm(k,10) = scalar(i,k,j,P_MZ10_PG)
    qgm(k,11) = scalar(i,k,j,P_MZ11_PG)
    qgm(k,12) = scalar(i,k,j,P_MZ12_PG)
    qgm(k,13) = scalar(i,k,j,P_MZ13_PG)
    qgm(k,14) = scalar(i,k,j,P_MZ14_PG)
    qgm(k,15) = scalar(i,k,j,P_MZ15_PG)
    qgm(k,16) = scalar(i,k,j,P_MZ16_PG)
    qgm(k,17) = scalar(i,k,j,P_MZ17_PG)
    qgm(k,18) = scalar(i,k,j,P_MZ18_PG)
    qgm(k,19) = scalar(i,k,j,P_MZ19_PG)
    qgm(k,20) = scalar(i,k,j,P_MZ20_PG)
    qgm(k,21) = scalar(i,k,j,P_MZ21_PG)
    qgm(k,22) = scalar(i,k,j,P_MZ22_PG)
    qgm(k,23) = scalar(i,k,j,P_MZ23_PG)
    qgm(k,24) = scalar(i,k,j,P_MZ24_PG)
    qgm(k,25) = scalar(i,k,j,P_MZ25_PG)
    qgm(k,26) = scalar(i,k,j,P_MZ26_PG)
    qgm(k,27) = scalar(i,k,j,P_MZ27_PG)
    qgm(k,28) = scalar(i,k,j,P_MZ28_PG)
    qgm(k,29) = scalar(i,k,j,P_MZ29_PG)
    qgm(k,30) = scalar(i,k,j,P_MZ30_PG)
    qgm(k,31) = scalar(i,k,j,P_MZ31_PG)
    qgm(k,32) = scalar(i,k,j,P_MZ32_PG)
    qgm(k,33) = scalar(i,k,j,P_MZ33_PG)
    qgm(k,34) = scalar(i,k,j,P_MZ34_PG)
    qgm(k,35) = scalar(i,k,j,P_MZ35_PG)
    qgm(k,36) = scalar(i,k,j,P_MZ36_PG)
	
  !! Number concentrations
!! Water drops  
    nw(k,1) = scalar(i,k,j,P_NC1_PG)
    nw(k,2) = scalar(i,k,j,P_NC2_PG)
    nw(k,3) = scalar(i,k,j,P_NC3_PG)
    nw(k,4) = scalar(i,k,j,P_NC4_PG)
    nw(k,5) = scalar(i,k,j,P_NC5_PG)
    nw(k,6) = scalar(i,k,j,P_NC6_PG)
    nw(k,7) = scalar(i,k,j,P_NC7_PG)
    nw(k,8) = scalar(i,k,j,P_NC8_PG)
    nw(k,9) = scalar(i,k,j,P_NC9_PG)
    nw(k,10) = scalar(i,k,j,P_NC10_PG)
    nw(k,11) = scalar(i,k,j,P_NC11_PG)
    nw(k,12) = scalar(i,k,j,P_NC12_PG)
    nw(k,13) = scalar(i,k,j,P_NC13_PG)
    nw(k,14) = scalar(i,k,j,P_NC14_PG)
    nw(k,15) = scalar(i,k,j,P_NC15_PG)
    nw(k,16) = scalar(i,k,j,P_NC16_PG)
    nw(k,17) = scalar(i,k,j,P_NC17_PG)
    nw(k,18) = scalar(i,k,j,P_NC18_PG)
    nw(k,19) = scalar(i,k,j,P_NC19_PG)
    nw(k,20) = scalar(i,k,j,P_NC20_PG)
    nw(k,21) = scalar(i,k,j,P_NC21_PG)
    nw(k,22) = scalar(i,k,j,P_NC22_PG)
    nw(k,23) = scalar(i,k,j,P_NC23_PG)
    nw(k,24) = scalar(i,k,j,P_NC24_PG)
    nw(k,25) = scalar(i,k,j,P_NC25_PG)
    nw(k,26) = scalar(i,k,j,P_NC26_PG)
    nw(k,27) = scalar(i,k,j,P_NC27_PG)
    nw(k,28) = scalar(i,k,j,P_NC28_PG)
    nw(k,29) = scalar(i,k,j,P_NC29_PG)
    nw(k,30) = scalar(i,k,j,P_NC30_PG)
    nw(k,31) = scalar(i,k,j,P_NC31_PG)
    nw(k,32) = scalar(i,k,j,P_NC32_PG)
    nw(k,33) = scalar(i,k,j,P_NC33_PG)
    nw(k,34) = scalar(i,k,j,P_NC34_PG)
    nw(k,35) = scalar(i,k,j,P_NC35_PG)
    nw(k,36) = scalar(i,k,j,P_NC36_PG)
!! Snowflakes	
    ns(k,1) = scalar(i,k,j,P_NR1_PG)
    ns(k,2) = scalar(i,k,j,P_NR2_PG)
    ns(k,3) = scalar(i,k,j,P_NR3_PG)
    ns(k,4) = scalar(i,k,j,P_NR4_PG)
    ns(k,5) = scalar(i,k,j,P_NR5_PG)
    ns(k,6) = scalar(i,k,j,P_NR6_PG)
    ns(k,7) = scalar(i,k,j,P_NR7_PG)
    ns(k,8) = scalar(i,k,j,P_NR8_PG)
    ns(k,9) = scalar(i,k,j,P_NR9_PG)
    ns(k,10) = scalar(i,k,j,P_NR10_PG)
    ns(k,11) = scalar(i,k,j,P_NR11_PG)
    ns(k,12) = scalar(i,k,j,P_NR12_PG)
    ns(k,13) = scalar(i,k,j,P_NR13_PG)
    ns(k,14) = scalar(i,k,j,P_NR14_PG)
    ns(k,15) = scalar(i,k,j,P_NR15_PG)
    ns(k,16) = scalar(i,k,j,P_NR16_PG)
    ns(k,17) = scalar(i,k,j,P_NR17_PG)
    ns(k,18) = scalar(i,k,j,P_NR18_PG)
    ns(k,19) = scalar(i,k,j,P_NR19_PG)
    ns(k,20) = scalar(i,k,j,P_NR20_PG)
    ns(k,21) = scalar(i,k,j,P_NR21_PG)
    ns(k,22) = scalar(i,k,j,P_NR22_PG)
    ns(k,23) = scalar(i,k,j,P_NR23_PG)
    ns(k,24) = scalar(i,k,j,P_NR24_PG)
    ns(k,25) = scalar(i,k,j,P_NR25_PG)
    ns(k,26) = scalar(i,k,j,P_NR26_PG)
    ns(k,27) = scalar(i,k,j,P_NR27_PG)
    ns(k,28) = scalar(i,k,j,P_NR28_PG)
    ns(k,29) = scalar(i,k,j,P_NR29_PG)
    ns(k,30) = scalar(i,k,j,P_NR30_PG)
    ns(k,31) = scalar(i,k,j,P_NR31_PG)
    ns(k,32) = scalar(i,k,j,P_NR32_PG)
    ns(k,33) = scalar(i,k,j,P_NR33_PG)
    ns(k,34) = scalar(i,k,j,P_NR34_PG)
    ns(k,35) = scalar(i,k,j,P_NR35_PG)
    ns(k,36) = scalar(i,k,j,P_NR36_PG)
!! Graupel particles
    ng(k,1) = scalar(i,k,j,P_NG1_PG)
    ng(k,2) = scalar(i,k,j,P_NG2_PG)
    ng(k,3) = scalar(i,k,j,P_NG3_PG)
    ng(k,4) = scalar(i,k,j,P_NG4_PG)
    ng(k,5) = scalar(i,k,j,P_NG5_PG)
    ng(k,6) = scalar(i,k,j,P_NG6_PG)
    ng(k,7) = scalar(i,k,j,P_NG7_PG)
    ng(k,8) = scalar(i,k,j,P_NG8_PG)
    ng(k,9) = scalar(i,k,j,P_NG9_PG)
    ng(k,10) = scalar(i,k,j,P_NG10_PG)
    ng(k,11) = scalar(i,k,j,P_NG11_PG)
    ng(k,12) = scalar(i,k,j,P_NG12_PG)
    ng(k,13) = scalar(i,k,j,P_NG13_PG)
    ng(k,14) = scalar(i,k,j,P_NG14_PG)
    ng(k,15) = scalar(i,k,j,P_NG15_PG)
    ng(k,16) = scalar(i,k,j,P_NG16_PG)
    ng(k,17) = scalar(i,k,j,P_NG17_PG)
    ng(k,18) = scalar(i,k,j,P_NG18_PG)
    ng(k,19) = scalar(i,k,j,P_NG19_PG)
    ng(k,20) = scalar(i,k,j,P_NG20_PG)
    ng(k,21) = scalar(i,k,j,P_NG21_PG)
    ng(k,22) = scalar(i,k,j,P_NG22_PG)
    ng(k,23) = scalar(i,k,j,P_NG23_PG)
    ng(k,24) = scalar(i,k,j,P_NG24_PG)
    ng(k,25) = scalar(i,k,j,P_NG25_PG)
    ng(k,26) = scalar(i,k,j,P_NG26_PG)
    ng(k,27) = scalar(i,k,j,P_NG27_PG)
    ng(k,28) = scalar(i,k,j,P_NG28_PG)
    ng(k,29) = scalar(i,k,j,P_NG29_PG)
    ng(k,30) = scalar(i,k,j,P_NG30_PG)
    ng(k,31) = scalar(i,k,j,P_NG31_PG)
    ng(k,32) = scalar(i,k,j,P_NG32_PG)
    ng(k,33) = scalar(i,k,j,P_NG33_PG)
    ng(k,34) = scalar(i,k,j,P_NG34_PG)
    ng(k,35) = scalar(i,k,j,P_NG35_PG)
    ng(k,36) = scalar(i,k,j,P_NG36_PG)	
!! Ice crystals
    ni(k,1) = scalar(i,k,j,P_NI1_PG)
    ni(k,2) = scalar(i,k,j,P_NI2_PG)
    ni(k,3) = scalar(i,k,j,P_NI3_PG)
    ni(k,4) = scalar(i,k,j,P_NI4_PG)
    ni(k,5) = scalar(i,k,j,P_NI5_PG)
    ni(k,6) = scalar(i,k,j,P_NI6_PG)
    ni(k,7) = scalar(i,k,j,P_NI7_PG)
    ni(k,8) = scalar(i,k,j,P_NI8_PG)
    ni(k,9) = scalar(i,k,j,P_NI9_PG)
    ni(k,10) = scalar(i,k,j,P_NI10_PG)
    ni(k,11) = scalar(i,k,j,P_NI11_PG)
    ni(k,12) = scalar(i,k,j,P_NI12_PG)
    ni(k,13) = scalar(i,k,j,P_NI13_PG)
    ni(k,14) = scalar(i,k,j,P_NI14_PG)
    ni(k,15) = scalar(i,k,j,P_NI15_PG)
    ni(k,16) = scalar(i,k,j,P_NI16_PG)
    ni(k,17) = scalar(i,k,j,P_NI17_PG)
    ni(k,18) = scalar(i,k,j,P_NI18_PG)
    ni(k,19) = scalar(i,k,j,P_NI19_PG)
    ni(k,20) = scalar(i,k,j,P_NI20_PG)
    ni(k,21) = scalar(i,k,j,P_NI21_PG)
    ni(k,22) = scalar(i,k,j,P_NI22_PG)
    ni(k,23) = scalar(i,k,j,P_NI23_PG)
    ni(k,24) = scalar(i,k,j,P_NI24_PG)
    ni(k,25) = scalar(i,k,j,P_NI25_PG)
    ni(k,26) = scalar(i,k,j,P_NI26_PG)
    ni(k,27) = scalar(i,k,j,P_NI27_PG)
    ni(k,28) = scalar(i,k,j,P_NI28_PG)
    ni(k,29) = scalar(i,k,j,P_NI29_PG)
    ni(k,30) = scalar(i,k,j,P_NI30_PG)
    ni(k,31) = scalar(i,k,j,P_NI31_PG)
    ni(k,32) = scalar(i,k,j,P_NI32_PG)
    ni(k,33) = scalar(i,k,j,P_NI33_PG)
    ni(k,34) = scalar(i,k,j,P_NI34_PG)
    ni(k,35) = scalar(i,k,j,P_NI35_PG)
    ni(k,36) = scalar(i,k,j,P_NI36_PG)	
!! Rimed snowflakes number
    nsr(k,1) = scalar(i,k,j,P_NX1_PG)
    nsr(k,2) = scalar(i,k,j,P_NX2_PG)
    nsr(k,3) = scalar(i,k,j,P_NX3_PG)
    nsr(k,4) = scalar(i,k,j,P_NX4_PG)
    nsr(k,5) = scalar(i,k,j,P_NX5_PG)
    nsr(k,6) = scalar(i,k,j,P_NX6_PG)
    nsr(k,7) = scalar(i,k,j,P_NX7_PG)
    nsr(k,8) = scalar(i,k,j,P_NX8_PG)
    nsr(k,9) = scalar(i,k,j,P_NX9_PG)
    nsr(k,10) = scalar(i,k,j,P_NX10_PG)
    nsr(k,11) = scalar(i,k,j,P_NX11_PG)
    nsr(k,12) = scalar(i,k,j,P_NX12_PG)
    nsr(k,13) = scalar(i,k,j,P_NX13_PG)
    nsr(k,14) = scalar(i,k,j,P_NX14_PG)
    nsr(k,15) = scalar(i,k,j,P_NX15_PG)
    nsr(k,16) = scalar(i,k,j,P_NX16_PG)
    nsr(k,17) = scalar(i,k,j,P_NX17_PG)
    nsr(k,18) = scalar(i,k,j,P_NX18_PG)
    nsr(k,19) = scalar(i,k,j,P_NX19_PG)
    nsr(k,20) = scalar(i,k,j,P_NX20_PG)
    nsr(k,21) = scalar(i,k,j,P_NX21_PG)
    nsr(k,22) = scalar(i,k,j,P_NX22_PG)
    nsr(k,23) = scalar(i,k,j,P_NX23_PG)
    nsr(k,24) = scalar(i,k,j,P_NX24_PG)
    nsr(k,25) = scalar(i,k,j,P_NX25_PG)
    nsr(k,26) = scalar(i,k,j,P_NX26_PG)
    nsr(k,27) = scalar(i,k,j,P_NX27_PG)
    nsr(k,28) = scalar(i,k,j,P_NX28_PG)
    nsr(k,29) = scalar(i,k,j,P_NX29_PG)
    nsr(k,30) = scalar(i,k,j,P_NX30_PG)
    nsr(k,31) = scalar(i,k,j,P_NX31_PG)
    nsr(k,32) = scalar(i,k,j,P_NX32_PG)
    nsr(k,33) = scalar(i,k,j,P_NX33_PG)
    nsr(k,34) = scalar(i,k,j,P_NX34_PG)
    nsr(k,35) = scalar(i,k,j,P_NX35_PG)
    nsr(k,36) = scalar(i,k,j,P_NX36_PG)
	
!! Old variables (before advection)
  !! Mixing ratios
!! Water drops
    qw_old(k,1) = scalar_old(i,k,j,P_MC1_PG)
    qw_old(k,2) = scalar_old(i,k,j,P_MC2_PG)
    qw_old(k,3) = scalar_old(i,k,j,P_MC3_PG)
    qw_old(k,4) = scalar_old(i,k,j,P_MC4_PG)
    qw_old(k,5) = scalar_old(i,k,j,P_MC5_PG)
    qw_old(k,6) = scalar_old(i,k,j,P_MC6_PG)
    qw_old(k,7) = scalar_old(i,k,j,P_MC7_PG)
    qw_old(k,8) = scalar_old(i,k,j,P_MC8_PG)
    qw_old(k,9) = scalar_old(i,k,j,P_MC9_PG)
    qw_old(k,10) = scalar_old(i,k,j,P_MC10_PG)
    qw_old(k,11) = scalar_old(i,k,j,P_MC11_PG)
    qw_old(k,12) = scalar_old(i,k,j,P_MC12_PG)
    qw_old(k,13) = scalar_old(i,k,j,P_MC13_PG)
    qw_old(k,14) = scalar_old(i,k,j,P_MC14_PG)
    qw_old(k,15) = scalar_old(i,k,j,P_MC15_PG)
    qw_old(k,16) = scalar_old(i,k,j,P_MC16_PG)
    qw_old(k,17) = scalar_old(i,k,j,P_MC17_PG)
    qw_old(k,18) = scalar_old(i,k,j,P_MC18_PG)
    qw_old(k,19) = scalar_old(i,k,j,P_MC19_PG)
    qw_old(k,20) = scalar_old(i,k,j,P_MC20_PG)
    qw_old(k,21) = scalar_old(i,k,j,P_MC21_PG)
    qw_old(k,22) = scalar_old(i,k,j,P_MC22_PG)
    qw_old(k,23) = scalar_old(i,k,j,P_MC23_PG)
    qw_old(k,24) = scalar_old(i,k,j,P_MC24_PG)
    qw_old(k,25) = scalar_old(i,k,j,P_MC25_PG)
    qw_old(k,26) = scalar_old(i,k,j,P_MC26_PG)
    qw_old(k,27) = scalar_old(i,k,j,P_MC27_PG)
    qw_old(k,28) = scalar_old(i,k,j,P_MC28_PG)
    qw_old(k,29) = scalar_old(i,k,j,P_MC29_PG)
    qw_old(k,30) = scalar_old(i,k,j,P_MC30_PG)
    qw_old(k,31) = scalar_old(i,k,j,P_MC31_PG)
    qw_old(k,32) = scalar_old(i,k,j,P_MC32_PG)
    qw_old(k,33) = scalar_old(i,k,j,P_MC33_PG)
    qw_old(k,34) = scalar_old(i,k,j,P_MC34_PG)
    qw_old(k,35) = scalar_old(i,k,j,P_MC35_PG)
    qw_old(k,36) = scalar_old(i,k,j,P_MC36_PG)  
!! Ice crystals
    qi_old(k,1) = scalar_old(i,k,j,P_MI1_PG)
    qi_old(k,2) = scalar_old(i,k,j,P_MI2_PG)
    qi_old(k,3) = scalar_old(i,k,j,P_MI3_PG)
    qi_old(k,4) = scalar_old(i,k,j,P_MI4_PG)
    qi_old(k,5) = scalar_old(i,k,j,P_MI5_PG)
    qi_old(k,6) = scalar_old(i,k,j,P_MI6_PG)
    qi_old(k,7) = scalar_old(i,k,j,P_MI7_PG)
    qi_old(k,8) = scalar_old(i,k,j,P_MI8_PG)
    qi_old(k,9) = scalar_old(i,k,j,P_MI9_PG)
    qi_old(k,10) = scalar_old(i,k,j,P_MI10_PG)
    qi_old(k,11) = scalar_old(i,k,j,P_MI11_PG)
    qi_old(k,12) = scalar_old(i,k,j,P_MI12_PG)
    qi_old(k,13) = scalar_old(i,k,j,P_MI13_PG)
    qi_old(k,14) = scalar_old(i,k,j,P_MI14_PG)
    qi_old(k,15) = scalar_old(i,k,j,P_MI15_PG)
    qi_old(k,16) = scalar_old(i,k,j,P_MI16_PG)
    qi_old(k,17) = scalar_old(i,k,j,P_MI17_PG)
    qi_old(k,18) = scalar_old(i,k,j,P_MI18_PG)
    qi_old(k,19) = scalar_old(i,k,j,P_MI19_PG)
    qi_old(k,20) = scalar_old(i,k,j,P_MI20_PG)
    qi_old(k,21) = scalar_old(i,k,j,P_MI21_PG)
    qi_old(k,22) = scalar_old(i,k,j,P_MI22_PG)
    qi_old(k,23) = scalar_old(i,k,j,P_MI23_PG)
    qi_old(k,24) = scalar_old(i,k,j,P_MI24_PG)
    qi_old(k,25) = scalar_old(i,k,j,P_MI25_PG)
    qi_old(k,26) = scalar_old(i,k,j,P_MI26_PG)
    qi_old(k,27) = scalar_old(i,k,j,P_MI27_PG)
    qi_old(k,28) = scalar_old(i,k,j,P_MI28_PG)
    qi_old(k,29) = scalar_old(i,k,j,P_MI29_PG)
    qi_old(k,30) = scalar_old(i,k,j,P_MI30_PG)
    qi_old(k,31) = scalar_old(i,k,j,P_MI31_PG)
    qi_old(k,32) = scalar_old(i,k,j,P_MI32_PG)
    qi_old(k,33) = scalar_old(i,k,j,P_MI33_PG)
    qi_old(k,34) = scalar_old(i,k,j,P_MI34_PG)
    qi_old(k,35) = scalar_old(i,k,j,P_MI35_PG)
    qi_old(k,36) = scalar_old(i,k,j,P_MI36_PG)  
!! Snowflakes
    qs_old(k,1) = scalar_old(i,k,j,P_MR1_PG)
    qs_old(k,2) = scalar_old(i,k,j,P_MR2_PG)
    qs_old(k,3) = scalar_old(i,k,j,P_MR3_PG)
    qs_old(k,4) = scalar_old(i,k,j,P_MR4_PG)
    qs_old(k,5) = scalar_old(i,k,j,P_MR5_PG)
    qs_old(k,6) = scalar_old(i,k,j,P_MR6_PG)
    qs_old(k,7) = scalar_old(i,k,j,P_MR7_PG)
    qs_old(k,8) = scalar_old(i,k,j,P_MR8_PG)
    qs_old(k,9) = scalar_old(i,k,j,P_MR9_PG)
    qs_old(k,10) = scalar_old(i,k,j,P_MR10_PG)
    qs_old(k,11) = scalar_old(i,k,j,P_MR11_PG)
    qs_old(k,12) = scalar_old(i,k,j,P_MR12_PG)
    qs_old(k,13) = scalar_old(i,k,j,P_MR13_PG)
    qs_old(k,14) = scalar_old(i,k,j,P_MR14_PG)
    qs_old(k,15) = scalar_old(i,k,j,P_MR15_PG)
    qs_old(k,16) = scalar_old(i,k,j,P_MR16_PG)
    qs_old(k,17) = scalar_old(i,k,j,P_MR17_PG)
    qs_old(k,18) = scalar_old(i,k,j,P_MR18_PG)
    qs_old(k,19) = scalar_old(i,k,j,P_MR19_PG)
    qs_old(k,20) = scalar_old(i,k,j,P_MR20_PG)
    qs_old(k,21) = scalar_old(i,k,j,P_MR21_PG)
    qs_old(k,22) = scalar_old(i,k,j,P_MR22_PG)
    qs_old(k,23) = scalar_old(i,k,j,P_MR23_PG)
    qs_old(k,24) = scalar_old(i,k,j,P_MR24_PG)
    qs_old(k,25) = scalar_old(i,k,j,P_MR25_PG)
    qs_old(k,26) = scalar_old(i,k,j,P_MR26_PG)
    qs_old(k,27) = scalar_old(i,k,j,P_MR27_PG)
    qs_old(k,28) = scalar_old(i,k,j,P_MR28_PG)
    qs_old(k,29) = scalar_old(i,k,j,P_MR29_PG)
    qs_old(k,30) = scalar_old(i,k,j,P_MR30_PG)
    qs_old(k,31) = scalar_old(i,k,j,P_MR31_PG)
    qs_old(k,32) = scalar_old(i,k,j,P_MR32_PG)
    qs_old(k,33) = scalar_old(i,k,j,P_MR33_PG)
    qs_old(k,34) = scalar_old(i,k,j,P_MR34_PG)
    qs_old(k,35) = scalar_old(i,k,j,P_MR35_PG)
    qs_old(k,36) = scalar_old(i,k,j,P_MR36_PG) 
!! Graupel particles
    qg_old(k,1) = scalar_old(i,k,j,P_MG1_PG)
    qg_old(k,2) = scalar_old(i,k,j,P_MG2_PG)
    qg_old(k,3) = scalar_old(i,k,j,P_MG3_PG)
    qg_old(k,4) = scalar_old(i,k,j,P_MG4_PG)
    qg_old(k,5) = scalar_old(i,k,j,P_MG5_PG)
    qg_old(k,6) = scalar_old(i,k,j,P_MG6_PG)
    qg_old(k,7) = scalar_old(i,k,j,P_MG7_PG)
    qg_old(k,8) = scalar_old(i,k,j,P_MG8_PG)
    qg_old(k,9) = scalar_old(i,k,j,P_MG9_PG)
    qg_old(k,10) = scalar_old(i,k,j,P_MG10_PG)
    qg_old(k,11) = scalar_old(i,k,j,P_MG11_PG)
    qg_old(k,12) = scalar_old(i,k,j,P_MG12_PG)
    qg_old(k,13) = scalar_old(i,k,j,P_MG13_PG)
    qg_old(k,14) = scalar_old(i,k,j,P_MG14_PG)
    qg_old(k,15) = scalar_old(i,k,j,P_MG15_PG)
    qg_old(k,16) = scalar_old(i,k,j,P_MG16_PG)
    qg_old(k,17) = scalar_old(i,k,j,P_MG17_PG)
    qg_old(k,18) = scalar_old(i,k,j,P_MG18_PG)
    qg_old(k,19) = scalar_old(i,k,j,P_MG19_PG)
    qg_old(k,20) = scalar_old(i,k,j,P_MG20_PG)
    qg_old(k,21) = scalar_old(i,k,j,P_MG21_PG)
    qg_old(k,22) = scalar_old(i,k,j,P_MG22_PG)
    qg_old(k,23) = scalar_old(i,k,j,P_MG23_PG)
    qg_old(k,24) = scalar_old(i,k,j,P_MG24_PG)
    qg_old(k,25) = scalar_old(i,k,j,P_MG25_PG)
    qg_old(k,26) = scalar_old(i,k,j,P_MG26_PG)
    qg_old(k,27) = scalar_old(i,k,j,P_MG27_PG)
    qg_old(k,28) = scalar_old(i,k,j,P_MG28_PG)
    qg_old(k,29) = scalar_old(i,k,j,P_MG29_PG)
    qg_old(k,30) = scalar_old(i,k,j,P_MG30_PG)
    qg_old(k,31) = scalar_old(i,k,j,P_MG31_PG)
    qg_old(k,32) = scalar_old(i,k,j,P_MG32_PG)
    qg_old(k,33) = scalar_old(i,k,j,P_MG33_PG)
    qg_old(k,34) = scalar_old(i,k,j,P_MG34_PG)
    qg_old(k,35) = scalar_old(i,k,j,P_MG35_PG)
    qg_old(k,36) = scalar_old(i,k,j,P_MG36_PG)
!! Rimed snowflakes
    qsr_old(k,1) = scalar_old(i,k,j,P_MX1_PG)
    qsr_old(k,2) = scalar_old(i,k,j,P_MX2_PG)
    qsr_old(k,3) = scalar_old(i,k,j,P_MX3_PG)
    qsr_old(k,4) = scalar_old(i,k,j,P_MX4_PG)
    qsr_old(k,5) = scalar_old(i,k,j,P_MX5_PG)
    qsr_old(k,6) = scalar_old(i,k,j,P_MX6_PG)
    qsr_old(k,7) = scalar_old(i,k,j,P_MX7_PG)
    qsr_old(k,8) = scalar_old(i,k,j,P_MX8_PG)
    qsr_old(k,9) = scalar_old(i,k,j,P_MX9_PG)
    qsr_old(k,10) = scalar_old(i,k,j,P_MX10_PG)
    qsr_old(k,11) = scalar_old(i,k,j,P_MX11_PG)
    qsr_old(k,12) = scalar_old(i,k,j,P_MX12_PG)
    qsr_old(k,13) = scalar_old(i,k,j,P_MX13_PG)
    qsr_old(k,14) = scalar_old(i,k,j,P_MX14_PG)
    qsr_old(k,15) = scalar_old(i,k,j,P_MX15_PG)
    qsr_old(k,16) = scalar_old(i,k,j,P_MX16_PG)
    qsr_old(k,17) = scalar_old(i,k,j,P_MX17_PG)
    qsr_old(k,18) = scalar_old(i,k,j,P_MX18_PG)
    qsr_old(k,19) = scalar_old(i,k,j,P_MX19_PG)
    qsr_old(k,20) = scalar_old(i,k,j,P_MX20_PG)
    qsr_old(k,21) = scalar_old(i,k,j,P_MX21_PG)
    qsr_old(k,22) = scalar_old(i,k,j,P_MX22_PG)
    qsr_old(k,23) = scalar_old(i,k,j,P_MX23_PG)
    qsr_old(k,24) = scalar_old(i,k,j,P_MX24_PG)
    qsr_old(k,25) = scalar_old(i,k,j,P_MX25_PG)
    qsr_old(k,26) = scalar_old(i,k,j,P_MX26_PG)
    qsr_old(k,27) = scalar_old(i,k,j,P_MX27_PG)
    qsr_old(k,28) = scalar_old(i,k,j,P_MX28_PG)
    qsr_old(k,29) = scalar_old(i,k,j,P_MX29_PG)
    qsr_old(k,30) = scalar_old(i,k,j,P_MX30_PG)
    qsr_old(k,31) = scalar_old(i,k,j,P_MX31_PG)
    qsr_old(k,32) = scalar_old(i,k,j,P_MX32_PG)
    qsr_old(k,33) = scalar_old(i,k,j,P_MX33_PG)
    qsr_old(k,34) = scalar_old(i,k,j,P_MX34_PG)
    qsr_old(k,35) = scalar_old(i,k,j,P_MX35_PG)
    qsr_old(k,36) = scalar_old(i,k,j,P_MX36_PG)
!! Melted snowflakes
    qsm_old(k,1) = scalar_old(i,k,j,P_MY1_PG)
    qsm_old(k,2) = scalar_old(i,k,j,P_MY2_PG)
    qsm_old(k,3) = scalar_old(i,k,j,P_MY3_PG)
    qsm_old(k,4) = scalar_old(i,k,j,P_MY4_PG)
    qsm_old(k,5) = scalar_old(i,k,j,P_MY5_PG)
    qsm_old(k,6) = scalar_old(i,k,j,P_MY6_PG)
    qsm_old(k,7) = scalar_old(i,k,j,P_MY7_PG)
    qsm_old(k,8) = scalar_old(i,k,j,P_MY8_PG)
    qsm_old(k,9) = scalar_old(i,k,j,P_MY9_PG)
    qsm_old(k,10) = scalar_old(i,k,j,P_MY10_PG)
    qsm_old(k,11) = scalar_old(i,k,j,P_MY11_PG)
    qsm_old(k,12) = scalar_old(i,k,j,P_MY12_PG)
    qsm_old(k,13) = scalar_old(i,k,j,P_MY13_PG)
    qsm_old(k,14) = scalar_old(i,k,j,P_MY14_PG)
    qsm_old(k,15) = scalar_old(i,k,j,P_MY15_PG)
    qsm_old(k,16) = scalar_old(i,k,j,P_MY16_PG)
    qsm_old(k,17) = scalar_old(i,k,j,P_MY17_PG)
    qsm_old(k,18) = scalar_old(i,k,j,P_MY18_PG)
    qsm_old(k,19) = scalar_old(i,k,j,P_MY19_PG)
    qsm_old(k,20) = scalar_old(i,k,j,P_MY20_PG)
    qsm_old(k,21) = scalar_old(i,k,j,P_MY21_PG)
    qsm_old(k,22) = scalar_old(i,k,j,P_MY22_PG)
    qsm_old(k,23) = scalar_old(i,k,j,P_MY23_PG)
    qsm_old(k,24) = scalar_old(i,k,j,P_MY24_PG)
    qsm_old(k,25) = scalar_old(i,k,j,P_MY25_PG)
    qsm_old(k,26) = scalar_old(i,k,j,P_MY26_PG)
    qsm_old(k,27) = scalar_old(i,k,j,P_MY27_PG)
    qsm_old(k,28) = scalar_old(i,k,j,P_MY28_PG)
    qsm_old(k,29) = scalar_old(i,k,j,P_MY29_PG)
    qsm_old(k,30) = scalar_old(i,k,j,P_MY30_PG)
    qsm_old(k,31) = scalar_old(i,k,j,P_MY31_PG)
    qsm_old(k,32) = scalar_old(i,k,j,P_MY32_PG)
    qsm_old(k,33) = scalar_old(i,k,j,P_MY33_PG)
    qsm_old(k,34) = scalar_old(i,k,j,P_MY34_PG)
    qsm_old(k,35) = scalar_old(i,k,j,P_MY35_PG)
    qsm_old(k,36) = scalar_old(i,k,j,P_MY36_PG)
!! Melted graupel
    qgm_old(k,1) = scalar_old(i,k,j,P_MZ1_PG)
    qgm_old(k,2) = scalar_old(i,k,j,P_MZ2_PG)
    qgm_old(k,3) = scalar_old(i,k,j,P_MZ3_PG)
    qgm_old(k,4) = scalar_old(i,k,j,P_MZ4_PG)
    qgm_old(k,5) = scalar_old(i,k,j,P_MZ5_PG)
    qgm_old(k,6) = scalar_old(i,k,j,P_MZ6_PG)
    qgm_old(k,7) = scalar_old(i,k,j,P_MZ7_PG)
    qgm_old(k,8) = scalar_old(i,k,j,P_MZ8_PG)
    qgm_old(k,9) = scalar_old(i,k,j,P_MZ9_PG)
    qgm_old(k,10) = scalar_old(i,k,j,P_MZ10_PG)
    qgm_old(k,11) = scalar_old(i,k,j,P_MZ11_PG)
    qgm_old(k,12) = scalar_old(i,k,j,P_MZ12_PG)
    qgm_old(k,13) = scalar_old(i,k,j,P_MZ13_PG)
    qgm_old(k,14) = scalar_old(i,k,j,P_MZ14_PG)
    qgm_old(k,15) = scalar_old(i,k,j,P_MZ15_PG)
    qgm_old(k,16) = scalar_old(i,k,j,P_MZ16_PG)
    qgm_old(k,17) = scalar_old(i,k,j,P_MZ17_PG)
    qgm_old(k,18) = scalar_old(i,k,j,P_MZ18_PG)
    qgm_old(k,19) = scalar_old(i,k,j,P_MZ19_PG)
    qgm_old(k,20) = scalar_old(i,k,j,P_MZ20_PG)
    qgm_old(k,21) = scalar_old(i,k,j,P_MZ21_PG)
    qgm_old(k,22) = scalar_old(i,k,j,P_MZ22_PG)
    qgm_old(k,23) = scalar_old(i,k,j,P_MZ23_PG)
    qgm_old(k,24) = scalar_old(i,k,j,P_MZ24_PG)
    qgm_old(k,25) = scalar_old(i,k,j,P_MZ25_PG)
    qgm_old(k,26) = scalar_old(i,k,j,P_MZ26_PG)
    qgm_old(k,27) = scalar_old(i,k,j,P_MZ27_PG)
    qgm_old(k,28) = scalar_old(i,k,j,P_MZ28_PG)
    qgm_old(k,29) = scalar_old(i,k,j,P_MZ29_PG)
    qgm_old(k,30) = scalar_old(i,k,j,P_MZ30_PG)
    qgm_old(k,31) = scalar_old(i,k,j,P_MZ31_PG)
    qgm_old(k,32) = scalar_old(i,k,j,P_MZ32_PG)
    qgm_old(k,33) = scalar_old(i,k,j,P_MZ33_PG)
    qgm_old(k,34) = scalar_old(i,k,j,P_MZ34_PG)
    qgm_old(k,35) = scalar_old(i,k,j,P_MZ35_PG)
    qgm_old(k,36) = scalar_old(i,k,j,P_MZ36_PG)
	
  !! Number concentrations
!! Water drops  
    nw_old(k,1) = scalar_old(i,k,j,P_NC1_PG)
    nw_old(k,2) = scalar_old(i,k,j,P_NC2_PG)
    nw_old(k,3) = scalar_old(i,k,j,P_NC3_PG)
    nw_old(k,4) = scalar_old(i,k,j,P_NC4_PG)
    nw_old(k,5) = scalar_old(i,k,j,P_NC5_PG)
    nw_old(k,6) = scalar_old(i,k,j,P_NC6_PG)
    nw_old(k,7) = scalar_old(i,k,j,P_NC7_PG)
    nw_old(k,8) = scalar_old(i,k,j,P_NC8_PG)
    nw_old(k,9) = scalar_old(i,k,j,P_NC9_PG)
    nw_old(k,10) = scalar_old(i,k,j,P_NC10_PG)
    nw_old(k,11) = scalar_old(i,k,j,P_NC11_PG)
    nw_old(k,12) = scalar_old(i,k,j,P_NC12_PG)
    nw_old(k,13) = scalar_old(i,k,j,P_NC13_PG)
    nw_old(k,14) = scalar_old(i,k,j,P_NC14_PG)
    nw_old(k,15) = scalar_old(i,k,j,P_NC15_PG)
    nw_old(k,16) = scalar_old(i,k,j,P_NC16_PG)
    nw_old(k,17) = scalar_old(i,k,j,P_NC17_PG)
    nw_old(k,18) = scalar_old(i,k,j,P_NC18_PG)
    nw_old(k,19) = scalar_old(i,k,j,P_NC19_PG)
    nw_old(k,20) = scalar_old(i,k,j,P_NC20_PG)
    nw_old(k,21) = scalar_old(i,k,j,P_NC21_PG)
    nw_old(k,22) = scalar_old(i,k,j,P_NC22_PG)
    nw_old(k,23) = scalar_old(i,k,j,P_NC23_PG)
    nw_old(k,24) = scalar_old(i,k,j,P_NC24_PG)
    nw_old(k,25) = scalar_old(i,k,j,P_NC25_PG)
    nw_old(k,26) = scalar_old(i,k,j,P_NC26_PG)
    nw_old(k,27) = scalar_old(i,k,j,P_NC27_PG)
    nw_old(k,28) = scalar_old(i,k,j,P_NC28_PG)
    nw_old(k,29) = scalar_old(i,k,j,P_NC29_PG)
    nw_old(k,30) = scalar_old(i,k,j,P_NC30_PG)
    nw_old(k,31) = scalar_old(i,k,j,P_NC31_PG)
    nw_old(k,32) = scalar_old(i,k,j,P_NC32_PG)
    nw_old(k,33) = scalar_old(i,k,j,P_NC33_PG)
    nw_old(k,34) = scalar_old(i,k,j,P_NC34_PG)
    nw_old(k,35) = scalar_old(i,k,j,P_NC35_PG)
    nw_old(k,36) = scalar_old(i,k,j,P_NC36_PG)
!! Snowflakes	
    ns_old(k,1) = scalar_old(i,k,j,P_NR1_PG)
    ns_old(k,2) = scalar_old(i,k,j,P_NR2_PG)
    ns_old(k,3) = scalar_old(i,k,j,P_NR3_PG)
    ns_old(k,4) = scalar_old(i,k,j,P_NR4_PG)
    ns_old(k,5) = scalar_old(i,k,j,P_NR5_PG)
    ns_old(k,6) = scalar_old(i,k,j,P_NR6_PG)
    ns_old(k,7) = scalar_old(i,k,j,P_NR7_PG)
    ns_old(k,8) = scalar_old(i,k,j,P_NR8_PG)
    ns_old(k,9) = scalar_old(i,k,j,P_NR9_PG)
    ns_old(k,10) = scalar_old(i,k,j,P_NR10_PG)
    ns_old(k,11) = scalar_old(i,k,j,P_NR11_PG)
    ns_old(k,12) = scalar_old(i,k,j,P_NR12_PG)
    ns_old(k,13) = scalar_old(i,k,j,P_NR13_PG)
    ns_old(k,14) = scalar_old(i,k,j,P_NR14_PG)
    ns_old(k,15) = scalar_old(i,k,j,P_NR15_PG)
    ns_old(k,16) = scalar_old(i,k,j,P_NR16_PG)
    ns_old(k,17) = scalar_old(i,k,j,P_NR17_PG)
    ns_old(k,18) = scalar_old(i,k,j,P_NR18_PG)
    ns_old(k,19) = scalar_old(i,k,j,P_NR19_PG)
    ns_old(k,20) = scalar_old(i,k,j,P_NR20_PG)
    ns_old(k,21) = scalar_old(i,k,j,P_NR21_PG)
    ns_old(k,22) = scalar_old(i,k,j,P_NR22_PG)
    ns_old(k,23) = scalar_old(i,k,j,P_NR23_PG)
    ns_old(k,24) = scalar_old(i,k,j,P_NR24_PG)
    ns_old(k,25) = scalar_old(i,k,j,P_NR25_PG)
    ns_old(k,26) = scalar_old(i,k,j,P_NR26_PG)
    ns_old(k,27) = scalar_old(i,k,j,P_NR27_PG)
    ns_old(k,28) = scalar_old(i,k,j,P_NR28_PG)
    ns_old(k,29) = scalar_old(i,k,j,P_NR29_PG)
    ns_old(k,30) = scalar_old(i,k,j,P_NR30_PG)
    ns_old(k,31) = scalar_old(i,k,j,P_NR31_PG)
    ns_old(k,32) = scalar_old(i,k,j,P_NR32_PG)
    ns_old(k,33) = scalar_old(i,k,j,P_NR33_PG)
    ns_old(k,34) = scalar_old(i,k,j,P_NR34_PG)
    ns_old(k,35) = scalar_old(i,k,j,P_NR35_PG)
    ns_old(k,36) = scalar_old(i,k,j,P_NR36_PG)
!! Graupel particles
    ng_old(k,1) = scalar_old(i,k,j,P_NG1_PG)
    ng_old(k,2) = scalar_old(i,k,j,P_NG2_PG)
    ng_old(k,3) = scalar_old(i,k,j,P_NG3_PG)
    ng_old(k,4) = scalar_old(i,k,j,P_NG4_PG)
    ng_old(k,5) = scalar_old(i,k,j,P_NG5_PG)
    ng_old(k,6) = scalar_old(i,k,j,P_NG6_PG)
    ng_old(k,7) = scalar_old(i,k,j,P_NG7_PG)
    ng_old(k,8) = scalar_old(i,k,j,P_NG8_PG)
    ng_old(k,9) = scalar_old(i,k,j,P_NG9_PG)
    ng_old(k,10) = scalar_old(i,k,j,P_NG10_PG)
    ng_old(k,11) = scalar_old(i,k,j,P_NG11_PG)
    ng_old(k,12) = scalar_old(i,k,j,P_NG12_PG)
    ng_old(k,13) = scalar_old(i,k,j,P_NG13_PG)
    ng_old(k,14) = scalar_old(i,k,j,P_NG14_PG)
    ng_old(k,15) = scalar_old(i,k,j,P_NG15_PG)
    ng_old(k,16) = scalar_old(i,k,j,P_NG16_PG)
    ng_old(k,17) = scalar_old(i,k,j,P_NG17_PG)
    ng_old(k,18) = scalar_old(i,k,j,P_NG18_PG)
    ng_old(k,19) = scalar_old(i,k,j,P_NG19_PG)
    ng_old(k,20) = scalar_old(i,k,j,P_NG20_PG)
    ng_old(k,21) = scalar_old(i,k,j,P_NG21_PG)
    ng_old(k,22) = scalar_old(i,k,j,P_NG22_PG)
    ng_old(k,23) = scalar_old(i,k,j,P_NG23_PG)
    ng_old(k,24) = scalar_old(i,k,j,P_NG24_PG)
    ng_old(k,25) = scalar_old(i,k,j,P_NG25_PG)
    ng_old(k,26) = scalar_old(i,k,j,P_NG26_PG)
    ng_old(k,27) = scalar_old(i,k,j,P_NG27_PG)
    ng_old(k,28) = scalar_old(i,k,j,P_NG28_PG)
    ng_old(k,29) = scalar_old(i,k,j,P_NG29_PG)
    ng_old(k,30) = scalar_old(i,k,j,P_NG30_PG)
    ng_old(k,31) = scalar_old(i,k,j,P_NG31_PG)
    ng_old(k,32) = scalar_old(i,k,j,P_NG32_PG)
    ng_old(k,33) = scalar_old(i,k,j,P_NG33_PG)
    ng_old(k,34) = scalar_old(i,k,j,P_NG34_PG)
    ng_old(k,35) = scalar_old(i,k,j,P_NG35_PG)
    ng_old(k,36) = scalar_old(i,k,j,P_NG36_PG)	
!! Ice crystals
    ni_old(k,1) = scalar_old(i,k,j,P_NI1_PG)
    ni_old(k,2) = scalar_old(i,k,j,P_NI2_PG)
    ni_old(k,3) = scalar_old(i,k,j,P_NI3_PG)
    ni_old(k,4) = scalar_old(i,k,j,P_NI4_PG)
    ni_old(k,5) = scalar_old(i,k,j,P_NI5_PG)
    ni_old(k,6) = scalar_old(i,k,j,P_NI6_PG)
    ni_old(k,7) = scalar_old(i,k,j,P_NI7_PG)
    ni_old(k,8) = scalar_old(i,k,j,P_NI8_PG)
    ni_old(k,9) = scalar_old(i,k,j,P_NI9_PG)
    ni_old(k,10) = scalar_old(i,k,j,P_NI10_PG)
    ni_old(k,11) = scalar_old(i,k,j,P_NI11_PG)
    ni_old(k,12) = scalar_old(i,k,j,P_NI12_PG)
    ni_old(k,13) = scalar_old(i,k,j,P_NI13_PG)
    ni_old(k,14) = scalar_old(i,k,j,P_NI14_PG)
    ni_old(k,15) = scalar_old(i,k,j,P_NI15_PG)
    ni_old(k,16) = scalar_old(i,k,j,P_NI16_PG)
    ni_old(k,17) = scalar_old(i,k,j,P_NI17_PG)
    ni_old(k,18) = scalar_old(i,k,j,P_NI18_PG)
    ni_old(k,19) = scalar_old(i,k,j,P_NI19_PG)
    ni_old(k,20) = scalar_old(i,k,j,P_NI20_PG)
    ni_old(k,21) = scalar_old(i,k,j,P_NI21_PG)
    ni_old(k,22) = scalar_old(i,k,j,P_NI22_PG)
    ni_old(k,23) = scalar_old(i,k,j,P_NI23_PG)
    ni_old(k,24) = scalar_old(i,k,j,P_NI24_PG)
    ni_old(k,25) = scalar_old(i,k,j,P_NI25_PG)
    ni_old(k,26) = scalar_old(i,k,j,P_NI26_PG)
    ni_old(k,27) = scalar_old(i,k,j,P_NI27_PG)
    ni_old(k,28) = scalar_old(i,k,j,P_NI28_PG)
    ni_old(k,29) = scalar_old(i,k,j,P_NI29_PG)
    ni_old(k,30) = scalar_old(i,k,j,P_NI30_PG)
    ni_old(k,31) = scalar_old(i,k,j,P_NI31_PG)
    ni_old(k,32) = scalar_old(i,k,j,P_NI32_PG)
    ni_old(k,33) = scalar_old(i,k,j,P_NI33_PG)
    ni_old(k,34) = scalar_old(i,k,j,P_NI34_PG)
    ni_old(k,35) = scalar_old(i,k,j,P_NI35_PG)
    ni_old(k,36) = scalar_old(i,k,j,P_NI36_PG)	
!! Rimed snowflakes number
    nsr_old(k,1) = scalar_old(i,k,j,P_NX1_PG)
    nsr_old(k,2) = scalar_old(i,k,j,P_NX2_PG)
    nsr_old(k,3) = scalar_old(i,k,j,P_NX3_PG)
    nsr_old(k,4) = scalar_old(i,k,j,P_NX4_PG)
    nsr_old(k,5) = scalar_old(i,k,j,P_NX5_PG)
    nsr_old(k,6) = scalar_old(i,k,j,P_NX6_PG)
    nsr_old(k,7) = scalar_old(i,k,j,P_NX7_PG)
    nsr_old(k,8) = scalar_old(i,k,j,P_NX8_PG)
    nsr_old(k,9) = scalar_old(i,k,j,P_NX9_PG)
    nsr_old(k,10) = scalar_old(i,k,j,P_NX10_PG)
    nsr_old(k,11) = scalar_old(i,k,j,P_NX11_PG)
    nsr_old(k,12) = scalar_old(i,k,j,P_NX12_PG)
    nsr_old(k,13) = scalar_old(i,k,j,P_NX13_PG)
    nsr_old(k,14) = scalar_old(i,k,j,P_NX14_PG)
    nsr_old(k,15) = scalar_old(i,k,j,P_NX15_PG)
    nsr_old(k,16) = scalar_old(i,k,j,P_NX16_PG)
    nsr_old(k,17) = scalar_old(i,k,j,P_NX17_PG)
    nsr_old(k,18) = scalar_old(i,k,j,P_NX18_PG)
    nsr_old(k,19) = scalar_old(i,k,j,P_NX19_PG)
    nsr_old(k,20) = scalar_old(i,k,j,P_NX20_PG)
    nsr_old(k,21) = scalar_old(i,k,j,P_NX21_PG)
    nsr_old(k,22) = scalar_old(i,k,j,P_NX22_PG)
    nsr_old(k,23) = scalar_old(i,k,j,P_NX23_PG)
    nsr_old(k,24) = scalar_old(i,k,j,P_NX24_PG)
    nsr_old(k,25) = scalar_old(i,k,j,P_NX25_PG)
    nsr_old(k,26) = scalar_old(i,k,j,P_NX26_PG)
    nsr_old(k,27) = scalar_old(i,k,j,P_NX27_PG)
    nsr_old(k,28) = scalar_old(i,k,j,P_NX28_PG)
    nsr_old(k,29) = scalar_old(i,k,j,P_NX29_PG)
    nsr_old(k,30) = scalar_old(i,k,j,P_NX30_PG)
    nsr_old(k,31) = scalar_old(i,k,j,P_NX31_PG)
    nsr_old(k,32) = scalar_old(i,k,j,P_NX32_PG)
    nsr_old(k,33) = scalar_old(i,k,j,P_NX33_PG)
    nsr_old(k,34) = scalar_old(i,k,j,P_NX34_PG)
    nsr_old(k,35) = scalar_old(i,k,j,P_NX35_PG)
    nsr_old(k,36) = scalar_old(i,k,j,P_NX36_PG)	

END SUBROUTINE read_in_bin_pg	
!+---------------------------------------------------------+
!+---------------------------------------------------------+
SUBROUTINE write_out_bin_pg(qw,qi, 	       &
  &   		       qs,qg,qsr,qsm,qgm,nw,   &
  &		           ni,ns,ng,nsr,scalar,    &
  &		           n_scalar,               &  
  &                ids,ide, jds,jde, kds,kde,  &
  &                ims,ime, jms,jme, kms,kme,  &
  &                its,ite, jts,jte, kts,kte,  &
  &                i,j,k)
  
  
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: i,j,k
  INTEGER, INTENT(IN) :: ims,ime,kms,kme,jms,jme,ids,ide,jds,jde,kds,kde,its,ite,jts,jte,kts,kte
  INTEGER, PARAMETER :: nbin = 36
  INTEGER, INTENT(IN) :: n_scalar
  REAL, DIMENSION(IMS:IME, KMS:KME, JMS:JME, n_scalar), INTENT(INOUT) :: scalar
  REAL, DIMENSION(KTS:KTE, nbin), INTENT(IN) ::     &
  &    qw,qi,qs,qg,qsr,qsm,qgm,nw,ni,ns,ng,nsr
  
  !! Mixing ratios
!! Water drops
    scalar(i,k,j,P_MC1_PG) = qw(k,1)
    scalar(i,k,j,P_MC2_PG) = qw(k,2)
    scalar(i,k,j,P_MC3_PG) = qw(k,3) 
    scalar(i,k,j,P_MC4_PG) = qw(k,4) 
    scalar(i,k,j,P_MC5_PG) = qw(k,5)
    scalar(i,k,j,P_MC6_PG) = qw(k,6)
    scalar(i,k,j,P_MC7_PG) = qw(k,7)
    scalar(i,k,j,P_MC8_PG) = qw(k,8)
    scalar(i,k,j,P_MC9_PG) = qw(k,9)
    scalar(i,k,j,P_MC10_PG) = qw(k,10)
    scalar(i,k,j,P_MC11_PG) = qw(k,11) 
    scalar(i,k,j,P_MC12_PG) = qw(k,12) 
    scalar(i,k,j,P_MC13_PG) = qw(k,13)
    scalar(i,k,j,P_MC14_PG) = qw(k,14) 
    scalar(i,k,j,P_MC15_PG) = qw(k,15) 
    scalar(i,k,j,P_MC16_PG) = qw(k,16)
    scalar(i,k,j,P_MC17_PG) = qw(k,17)  
    scalar(i,k,j,P_MC18_PG) = qw(k,18) 
    scalar(i,k,j,P_MC19_PG) = qw(k,19) 
    scalar(i,k,j,P_MC20_PG) = qw(k,20)
    scalar(i,k,j,P_MC21_PG) = qw(k,21) 
    scalar(i,k,j,P_MC22_PG) = qw(k,22) 
    scalar(i,k,j,P_MC23_PG) = qw(k,23)
    scalar(i,k,j,P_MC24_PG) = qw(k,24)
    scalar(i,k,j,P_MC25_PG) = qw(k,25)
    scalar(i,k,j,P_MC26_PG) = qw(k,26)
    scalar(i,k,j,P_MC27_PG) = qw(k,27)
    scalar(i,k,j,P_MC28_PG) = qw(k,28)
    scalar(i,k,j,P_MC29_PG) = qw(k,29)
    scalar(i,k,j,P_MC30_PG) = qw(k,30) 
    scalar(i,k,j,P_MC31_PG) = qw(k,31)
    scalar(i,k,j,P_MC32_PG) = qw(k,32)  
    scalar(i,k,j,P_MC33_PG) = qw(k,33) 
    scalar(i,k,j,P_MC34_PG) = qw(k,34) 
    scalar(i,k,j,P_MC35_PG) = qw(k,35) 
    scalar(i,k,j,P_MC36_PG) = qw(k,36)
	
!! Ice crystals
    scalar(i,k,j,P_MI1_PG) = qi(k,1)
    scalar(i,k,j,P_MI2_PG) = qi(k,2)
    scalar(i,k,j,P_MI3_PG) = qi(k,3) 
    scalar(i,k,j,P_MI4_PG) = qi(k,4) 
    scalar(i,k,j,P_MI5_PG) = qi(k,5)
    scalar(i,k,j,P_MI6_PG) = qi(k,6)
    scalar(i,k,j,P_MI7_PG) = qi(k,7)
    scalar(i,k,j,P_MI8_PG) = qi(k,8)
    scalar(i,k,j,P_MI9_PG) = qi(k,9)
    scalar(i,k,j,P_MI10_PG) = qi(k,10)
    scalar(i,k,j,P_MI11_PG) = qi(k,11) 
    scalar(i,k,j,P_MI12_PG) = qi(k,12) 
    scalar(i,k,j,P_MI13_PG) = qi(k,13)
    scalar(i,k,j,P_MI14_PG) = qi(k,14) 
    scalar(i,k,j,P_MI15_PG) = qi(k,15) 
    scalar(i,k,j,P_MI16_PG) = qi(k,16)
    scalar(i,k,j,P_MI17_PG) = qi(k,17)  
    scalar(i,k,j,P_MI18_PG) = qi(k,18) 
    scalar(i,k,j,P_MI19_PG) = qi(k,19) 
    scalar(i,k,j,P_MI20_PG) = qi(k,20)
    scalar(i,k,j,P_MI21_PG) = qi(k,21) 
    scalar(i,k,j,P_MI22_PG) = qi(k,22) 
    scalar(i,k,j,P_MI23_PG) = qi(k,23)
    scalar(i,k,j,P_MI24_PG) = qi(k,24)
    scalar(i,k,j,P_MI25_PG) = qi(k,25)
    scalar(i,k,j,P_MI26_PG) = qi(k,26)
    scalar(i,k,j,P_MI27_PG) = qi(k,27)
    scalar(i,k,j,P_MI28_PG) = qi(k,28)
    scalar(i,k,j,P_MI29_PG) = qi(k,29)
    scalar(i,k,j,P_MI30_PG) = qi(k,30) 
    scalar(i,k,j,P_MI31_PG) = qi(k,31)
    scalar(i,k,j,P_MI32_PG) = qi(k,32)  
    scalar(i,k,j,P_MI33_PG) = qi(k,33) 
    scalar(i,k,j,P_MI34_PG) = qi(k,34) 
    scalar(i,k,j,P_MI35_PG) = qi(k,35) 
    scalar(i,k,j,P_MI36_PG) = qi(k,36)
	
!! Snowflakes
    scalar(i,k,j,P_MR1_PG) = qs(k,1)
    scalar(i,k,j,P_MR2_PG) = qs(k,2)
    scalar(i,k,j,P_MR3_PG) = qs(k,3) 
    scalar(i,k,j,P_MR4_PG) = qs(k,4) 
    scalar(i,k,j,P_MR5_PG) = qs(k,5)
    scalar(i,k,j,P_MR6_PG) = qs(k,6)
    scalar(i,k,j,P_MR7_PG) = qs(k,7)
    scalar(i,k,j,P_MR8_PG) = qs(k,8)
    scalar(i,k,j,P_MR9_PG) = qs(k,9)
    scalar(i,k,j,P_MR10_PG) = qs(k,10)
    scalar(i,k,j,P_MR11_PG) = qs(k,11) 
    scalar(i,k,j,P_MR12_PG) = qs(k,12) 
    scalar(i,k,j,P_MR13_PG) = qs(k,13)
    scalar(i,k,j,P_MR14_PG) = qs(k,14) 
    scalar(i,k,j,P_MR15_PG) = qs(k,15) 
    scalar(i,k,j,P_MR16_PG) = qs(k,16)
    scalar(i,k,j,P_MR17_PG) = qs(k,17)  
    scalar(i,k,j,P_MR18_PG) = qs(k,18) 
    scalar(i,k,j,P_MR19_PG) = qs(k,19) 
    scalar(i,k,j,P_MR20_PG) = qs(k,20)
    scalar(i,k,j,P_MR21_PG) = qs(k,21) 
    scalar(i,k,j,P_MR22_PG) = qs(k,22) 
    scalar(i,k,j,P_MR23_PG) = qs(k,23)
    scalar(i,k,j,P_MR24_PG) = qs(k,24)
    scalar(i,k,j,P_MR25_PG) = qs(k,25)
    scalar(i,k,j,P_MR26_PG) = qs(k,26)
    scalar(i,k,j,P_MR27_PG) = qs(k,27)
    scalar(i,k,j,P_MR28_PG) = qs(k,28)
    scalar(i,k,j,P_MR29_PG) = qs(k,29)
    scalar(i,k,j,P_MR30_PG) = qs(k,30) 
    scalar(i,k,j,P_MR31_PG) = qs(k,31)
    scalar(i,k,j,P_MR32_PG) = qs(k,32)  
    scalar(i,k,j,P_MR33_PG) = qs(k,33) 
    scalar(i,k,j,P_MR34_PG) = qs(k,34) 
    scalar(i,k,j,P_MR35_PG) = qs(k,35) 
    scalar(i,k,j,P_MR36_PG) = qs(k,36)
	
!! Graupel particles
    scalar(i,k,j,P_MG1_PG) = qg(k,1)
    scalar(i,k,j,P_MG2_PG) = qg(k,2)
    scalar(i,k,j,P_MG3_PG) = qg(k,3) 
    scalar(i,k,j,P_MG4_PG) = qg(k,4) 
    scalar(i,k,j,P_MG5_PG) = qg(k,5)
    scalar(i,k,j,P_MG6_PG) = qg(k,6)
    scalar(i,k,j,P_MG7_PG) = qg(k,7)
    scalar(i,k,j,P_MG8_PG) = qg(k,8)
    scalar(i,k,j,P_MG9_PG) = qg(k,9)
    scalar(i,k,j,P_MG10_PG) = qg(k,10)
    scalar(i,k,j,P_MG11_PG) = qg(k,11) 
    scalar(i,k,j,P_MG12_PG) = qg(k,12) 
    scalar(i,k,j,P_MG13_PG) = qg(k,13)
    scalar(i,k,j,P_MG14_PG) = qg(k,14) 
    scalar(i,k,j,P_MG15_PG) = qg(k,15) 
    scalar(i,k,j,P_MG16_PG) = qg(k,16)
    scalar(i,k,j,P_MG17_PG) = qg(k,17)  
    scalar(i,k,j,P_MG18_PG) = qg(k,18) 
    scalar(i,k,j,P_MG19_PG) = qg(k,19) 
    scalar(i,k,j,P_MG20_PG) = qg(k,20)
    scalar(i,k,j,P_MG21_PG) = qg(k,21) 
    scalar(i,k,j,P_MG22_PG) = qg(k,22) 
    scalar(i,k,j,P_MG23_PG) = qg(k,23)
    scalar(i,k,j,P_MG24_PG) = qg(k,24)
    scalar(i,k,j,P_MG25_PG) = qg(k,25)
    scalar(i,k,j,P_MG26_PG) = qg(k,26)
    scalar(i,k,j,P_MG27_PG) = qg(k,27)
    scalar(i,k,j,P_MG28_PG) = qg(k,28)
    scalar(i,k,j,P_MG29_PG) = qg(k,29)
    scalar(i,k,j,P_MG30_PG) = qg(k,30) 
    scalar(i,k,j,P_MG31_PG) = qg(k,31)
    scalar(i,k,j,P_MG32_PG) = qg(k,32)  
    scalar(i,k,j,P_MG33_PG) = qg(k,33) 
    scalar(i,k,j,P_MG34_PG) = qg(k,34) 
    scalar(i,k,j,P_MG35_PG) = qg(k,35) 
    scalar(i,k,j,P_MG36_PG) = qg(k,36)
	
!! Rimed snowflakes
    scalar(i,k,j,P_MX1_PG) = qsr(k,1)
    scalar(i,k,j,P_MX2_PG) = qsr(k,2)
    scalar(i,k,j,P_MX3_PG) = qsr(k,3) 
    scalar(i,k,j,P_MX4_PG) = qsr(k,4) 
    scalar(i,k,j,P_MX5_PG) = qsr(k,5)
    scalar(i,k,j,P_MX6_PG) = qsr(k,6)
    scalar(i,k,j,P_MX7_PG) = qsr(k,7)
    scalar(i,k,j,P_MX8_PG) = qsr(k,8)
    scalar(i,k,j,P_MX9_PG) = qsr(k,9)
    scalar(i,k,j,P_MX10_PG) = qsr(k,10)
    scalar(i,k,j,P_MX11_PG) = qsr(k,11) 
    scalar(i,k,j,P_MX12_PG) = qsr(k,12) 
    scalar(i,k,j,P_MX13_PG) = qsr(k,13)
    scalar(i,k,j,P_MX14_PG) = qsr(k,14) 
    scalar(i,k,j,P_MX15_PG) = qsr(k,15) 
    scalar(i,k,j,P_MX16_PG) = qsr(k,16)
    scalar(i,k,j,P_MX17_PG) = qsr(k,17)  
    scalar(i,k,j,P_MX18_PG) = qsr(k,18) 
    scalar(i,k,j,P_MX19_PG) = qsr(k,19) 
    scalar(i,k,j,P_MX20_PG) = qsr(k,20)
    scalar(i,k,j,P_MX21_PG) = qsr(k,21) 
    scalar(i,k,j,P_MX22_PG) = qsr(k,22) 
    scalar(i,k,j,P_MX23_PG) = qsr(k,23)
    scalar(i,k,j,P_MX24_PG) = qsr(k,24)
    scalar(i,k,j,P_MX25_PG) = qsr(k,25)
    scalar(i,k,j,P_MX26_PG) = qsr(k,26)
    scalar(i,k,j,P_MX27_PG) = qsr(k,27)
    scalar(i,k,j,P_MX28_PG) = qsr(k,28)
    scalar(i,k,j,P_MX29_PG) = qsr(k,29)
    scalar(i,k,j,P_MX30_PG) = qsr(k,30) 
    scalar(i,k,j,P_MX31_PG) = qsr(k,31)
    scalar(i,k,j,P_MX32_PG) = qsr(k,32)  
    scalar(i,k,j,P_MX33_PG) = qsr(k,33) 
    scalar(i,k,j,P_MX34_PG) = qsr(k,34) 
    scalar(i,k,j,P_MX35_PG) = qsr(k,35) 
    scalar(i,k,j,P_MX36_PG) = qsr(k,36)
	
!! Melted snowflakes
    scalar(i,k,j,P_MY1_PG) = qsm(k,1)
    scalar(i,k,j,P_MY2_PG) = qsm(k,2)
    scalar(i,k,j,P_MY3_PG) = qsm(k,3) 
    scalar(i,k,j,P_MY4_PG) = qsm(k,4) 
    scalar(i,k,j,P_MY5_PG) = qsm(k,5)
    scalar(i,k,j,P_MY6_PG) = qsm(k,6)
    scalar(i,k,j,P_MY7_PG) = qsm(k,7)
    scalar(i,k,j,P_MY8_PG) = qsm(k,8)
    scalar(i,k,j,P_MY9_PG) = qsm(k,9)
    scalar(i,k,j,P_MY10_PG) = qsm(k,10)
    scalar(i,k,j,P_MY11_PG) = qsm(k,11) 
    scalar(i,k,j,P_MY12_PG) = qsm(k,12) 
    scalar(i,k,j,P_MY13_PG) = qsm(k,13)
    scalar(i,k,j,P_MY14_PG) = qsm(k,14) 
    scalar(i,k,j,P_MY15_PG) = qsm(k,15) 
    scalar(i,k,j,P_MY16_PG) = qsm(k,16)
    scalar(i,k,j,P_MY17_PG) = qsm(k,17)  
    scalar(i,k,j,P_MY18_PG) = qsm(k,18) 
    scalar(i,k,j,P_MY19_PG) = qsm(k,19) 
    scalar(i,k,j,P_MY20_PG) = qsm(k,20)
    scalar(i,k,j,P_MY21_PG) = qsm(k,21) 
    scalar(i,k,j,P_MY22_PG) = qsm(k,22) 
    scalar(i,k,j,P_MY23_PG) = qsm(k,23)
    scalar(i,k,j,P_MY24_PG) = qsm(k,24)
    scalar(i,k,j,P_MY25_PG) = qsm(k,25)
    scalar(i,k,j,P_MY26_PG) = qsm(k,26)
    scalar(i,k,j,P_MY27_PG) = qsm(k,27)
    scalar(i,k,j,P_MY28_PG) = qsm(k,28)
    scalar(i,k,j,P_MY29_PG) = qsm(k,29)
    scalar(i,k,j,P_MY30_PG) = qsm(k,30) 
    scalar(i,k,j,P_MY31_PG) = qsm(k,31)
    scalar(i,k,j,P_MY32_PG) = qsm(k,32)  
    scalar(i,k,j,P_MY33_PG) = qsm(k,33) 
    scalar(i,k,j,P_MY34_PG) = qsm(k,34) 
    scalar(i,k,j,P_MY35_PG) = qsm(k,35) 
    scalar(i,k,j,P_MY36_PG) = qsm(k,36)
	
!! Melted graupel
    scalar(i,k,j,P_MZ1_PG) = qgm(k,1)
    scalar(i,k,j,P_MZ2_PG) = qgm(k,2)
    scalar(i,k,j,P_MZ3_PG) = qgm(k,3) 
    scalar(i,k,j,P_MZ4_PG) = qgm(k,4) 
    scalar(i,k,j,P_MZ5_PG) = qgm(k,5)
    scalar(i,k,j,P_MZ6_PG) = qgm(k,6)
    scalar(i,k,j,P_MZ7_PG) = qgm(k,7)
    scalar(i,k,j,P_MZ8_PG) = qgm(k,8)
    scalar(i,k,j,P_MZ9_PG) = qgm(k,9)
    scalar(i,k,j,P_MZ10_PG) = qgm(k,10)
    scalar(i,k,j,P_MZ11_PG) = qgm(k,11) 
    scalar(i,k,j,P_MZ12_PG) = qgm(k,12) 
    scalar(i,k,j,P_MZ13_PG) = qgm(k,13)
    scalar(i,k,j,P_MZ14_PG) = qgm(k,14) 
    scalar(i,k,j,P_MZ15_PG) = qgm(k,15) 
    scalar(i,k,j,P_MZ16_PG) = qgm(k,16)
    scalar(i,k,j,P_MZ17_PG) = qgm(k,17)  
    scalar(i,k,j,P_MZ18_PG) = qgm(k,18) 
    scalar(i,k,j,P_MZ19_PG) = qgm(k,19) 
    scalar(i,k,j,P_MZ20_PG) = qgm(k,20)
    scalar(i,k,j,P_MZ21_PG) = qgm(k,21) 
    scalar(i,k,j,P_MZ22_PG) = qgm(k,22) 
    scalar(i,k,j,P_MZ23_PG) = qgm(k,23)
    scalar(i,k,j,P_MZ24_PG) = qgm(k,24)
    scalar(i,k,j,P_MZ25_PG) = qgm(k,25)
    scalar(i,k,j,P_MZ26_PG) = qgm(k,26)
    scalar(i,k,j,P_MZ27_PG) = qgm(k,27)
    scalar(i,k,j,P_MZ28_PG) = qgm(k,28)
    scalar(i,k,j,P_MZ29_PG) = qgm(k,29)
    scalar(i,k,j,P_MZ30_PG) = qgm(k,30) 
    scalar(i,k,j,P_MZ31_PG) = qgm(k,31)
    scalar(i,k,j,P_MZ32_PG) = qgm(k,32)  
    scalar(i,k,j,P_MZ33_PG) = qgm(k,33) 
    scalar(i,k,j,P_MZ34_PG) = qgm(k,34) 
    scalar(i,k,j,P_MZ35_PG) = qgm(k,35) 
    scalar(i,k,j,P_MZ36_PG) = qgm(k,36)
	
  !! Number concentrations
!! Water drops  
    scalar(i,k,j,P_NC1_PG) = nw(k,1)
    scalar(i,k,j,P_NC2_PG) = nw(k,2)
    scalar(i,k,j,P_NC3_PG) = nw(k,3) 
    scalar(i,k,j,P_NC4_PG) = nw(k,4) 
    scalar(i,k,j,P_NC5_PG) = nw(k,5)
    scalar(i,k,j,P_NC6_PG) = nw(k,6)
    scalar(i,k,j,P_NC7_PG) = nw(k,7)
    scalar(i,k,j,P_NC8_PG) = nw(k,8)
    scalar(i,k,j,P_NC9_PG) = nw(k,9)
    scalar(i,k,j,P_NC10_PG) = nw(k,10)
    scalar(i,k,j,P_NC11_PG) = nw(k,11) 
    scalar(i,k,j,P_NC12_PG) = nw(k,12) 
    scalar(i,k,j,P_NC13_PG) = nw(k,13)
    scalar(i,k,j,P_NC14_PG) = nw(k,14) 
    scalar(i,k,j,P_NC15_PG) = nw(k,15) 
    scalar(i,k,j,P_NC16_PG) = nw(k,16)
    scalar(i,k,j,P_NC17_PG) = nw(k,17)  
    scalar(i,k,j,P_NC18_PG) = nw(k,18) 
    scalar(i,k,j,P_NC19_PG) = nw(k,19) 
    scalar(i,k,j,P_NC20_PG) = nw(k,20)
    scalar(i,k,j,P_NC21_PG) = nw(k,21) 
    scalar(i,k,j,P_NC22_PG) = nw(k,22) 
    scalar(i,k,j,P_NC23_PG) = nw(k,23)
    scalar(i,k,j,P_NC24_PG) = nw(k,24)
    scalar(i,k,j,P_NC25_PG) = nw(k,25)
    scalar(i,k,j,P_NC26_PG) = nw(k,26)
    scalar(i,k,j,P_NC27_PG) = nw(k,27)
    scalar(i,k,j,P_NC28_PG) = nw(k,28)
    scalar(i,k,j,P_NC29_PG) = nw(k,29)
    scalar(i,k,j,P_NC30_PG) = nw(k,30) 
    scalar(i,k,j,P_NC31_PG) = nw(k,31)
    scalar(i,k,j,P_NC32_PG) = nw(k,32)  
    scalar(i,k,j,P_NC33_PG) = nw(k,33) 
    scalar(i,k,j,P_NC34_PG) = nw(k,34) 
    scalar(i,k,j,P_NC35_PG) = nw(k,35) 
    scalar(i,k,j,P_NC36_PG) = nw(k,36)
	
!! Snowflakes	
    scalar(i,k,j,P_NR1_PG) = ns(k,1)
    scalar(i,k,j,P_NR2_PG) = ns(k,2)
    scalar(i,k,j,P_NR3_PG) = ns(k,3) 
    scalar(i,k,j,P_NR4_PG) = ns(k,4) 
    scalar(i,k,j,P_NR5_PG) = ns(k,5)
    scalar(i,k,j,P_NR6_PG) = ns(k,6)
    scalar(i,k,j,P_NR7_PG) = ns(k,7)
    scalar(i,k,j,P_NR8_PG) = ns(k,8)
    scalar(i,k,j,P_NR9_PG) = ns(k,9)
    scalar(i,k,j,P_NR10_PG) = ns(k,10)
    scalar(i,k,j,P_NR11_PG) = ns(k,11) 
    scalar(i,k,j,P_NR12_PG) = ns(k,12) 
    scalar(i,k,j,P_NR13_PG) = ns(k,13)
    scalar(i,k,j,P_NR14_PG) = ns(k,14) 
    scalar(i,k,j,P_NR15_PG) = ns(k,15) 
    scalar(i,k,j,P_NR16_PG) = ns(k,16)
    scalar(i,k,j,P_NR17_PG) = ns(k,17)  
    scalar(i,k,j,P_NR18_PG) = ns(k,18) 
    scalar(i,k,j,P_NR19_PG) = ns(k,19) 
    scalar(i,k,j,P_NR20_PG) = ns(k,20)
    scalar(i,k,j,P_NR21_PG) = ns(k,21) 
    scalar(i,k,j,P_NR22_PG) = ns(k,22) 
    scalar(i,k,j,P_NR23_PG) = ns(k,23)
    scalar(i,k,j,P_NR24_PG) = ns(k,24)
    scalar(i,k,j,P_NR25_PG) = ns(k,25)
    scalar(i,k,j,P_NR26_PG) = ns(k,26)
    scalar(i,k,j,P_NR27_PG) = ns(k,27)
    scalar(i,k,j,P_NR28_PG) = ns(k,28)
    scalar(i,k,j,P_NR29_PG) = ns(k,29)
    scalar(i,k,j,P_NR30_PG) = ns(k,30) 
    scalar(i,k,j,P_NR31_PG) = ns(k,31)
    scalar(i,k,j,P_NR32_PG) = ns(k,32)  
    scalar(i,k,j,P_NR33_PG) = ns(k,33) 
    scalar(i,k,j,P_NR34_PG) = ns(k,34) 
    scalar(i,k,j,P_NR35_PG) = ns(k,35) 
    scalar(i,k,j,P_NR36_PG) = ns(k,36)
	
!! Graupel particles
    scalar(i,k,j,P_NG1_PG) = ng(k,1)
    scalar(i,k,j,P_NG2_PG) = ng(k,2)
    scalar(i,k,j,P_NG3_PG) = ng(k,3) 
    scalar(i,k,j,P_NG4_PG) = ng(k,4) 
    scalar(i,k,j,P_NG5_PG) = ng(k,5)
    scalar(i,k,j,P_NG6_PG) = ng(k,6)
    scalar(i,k,j,P_NG7_PG) = ng(k,7)
    scalar(i,k,j,P_NG8_PG) = ng(k,8)
    scalar(i,k,j,P_NG9_PG) = ng(k,9)
    scalar(i,k,j,P_NG10_PG) = ng(k,10)
    scalar(i,k,j,P_NG11_PG) = ng(k,11) 
    scalar(i,k,j,P_NG12_PG) = ng(k,12) 
    scalar(i,k,j,P_NG13_PG) = ng(k,13)
    scalar(i,k,j,P_NG14_PG) = ng(k,14) 
    scalar(i,k,j,P_NG15_PG) = ng(k,15) 
    scalar(i,k,j,P_NG16_PG) = ng(k,16)
    scalar(i,k,j,P_NG17_PG) = ng(k,17)  
    scalar(i,k,j,P_NG18_PG) = ng(k,18) 
    scalar(i,k,j,P_NG19_PG) = ng(k,19) 
    scalar(i,k,j,P_NG20_PG) = ng(k,20)
    scalar(i,k,j,P_NG21_PG) = ng(k,21) 
    scalar(i,k,j,P_NG22_PG) = ng(k,22) 
    scalar(i,k,j,P_NG23_PG) = ng(k,23)
    scalar(i,k,j,P_NG24_PG) = ng(k,24)
    scalar(i,k,j,P_NG25_PG) = ng(k,25)
    scalar(i,k,j,P_NG26_PG) = ng(k,26)
    scalar(i,k,j,P_NG27_PG) = ng(k,27)
    scalar(i,k,j,P_NG28_PG) = ng(k,28)
    scalar(i,k,j,P_NG29_PG) = ng(k,29)
    scalar(i,k,j,P_NG30_PG) = ng(k,30) 
    scalar(i,k,j,P_NG31_PG) = ng(k,31)
    scalar(i,k,j,P_NG32_PG) = ng(k,32)  
    scalar(i,k,j,P_NG33_PG) = ng(k,33) 
    scalar(i,k,j,P_NG34_PG) = ng(k,34) 
    scalar(i,k,j,P_NG35_PG) = ng(k,35) 
    scalar(i,k,j,P_NG36_PG) = ng(k,36)
	
!! Ice crystals
    scalar(i,k,j,P_NI1_PG) = ni(k,1)
    scalar(i,k,j,P_NI2_PG) = ni(k,2)
    scalar(i,k,j,P_NI3_PG) = ni(k,3) 
    scalar(i,k,j,P_NI4_PG) = ni(k,4) 
    scalar(i,k,j,P_NI5_PG) = ni(k,5)
    scalar(i,k,j,P_NI6_PG) = ni(k,6)
    scalar(i,k,j,P_NI7_PG) = ni(k,7)
    scalar(i,k,j,P_NI8_PG) = ni(k,8)
    scalar(i,k,j,P_NI9_PG) = ni(k,9)
    scalar(i,k,j,P_NI10_PG) = ni(k,10)
    scalar(i,k,j,P_NI11_PG) = ni(k,11) 
    scalar(i,k,j,P_NI12_PG) = ni(k,12) 
    scalar(i,k,j,P_NI13_PG) = ni(k,13)
    scalar(i,k,j,P_NI14_PG) = ni(k,14) 
    scalar(i,k,j,P_NI15_PG) = ni(k,15) 
    scalar(i,k,j,P_NI16_PG) = ni(k,16)
    scalar(i,k,j,P_NI17_PG) = ni(k,17)  
    scalar(i,k,j,P_NI18_PG) = ni(k,18) 
    scalar(i,k,j,P_NI19_PG) = ni(k,19) 
    scalar(i,k,j,P_NI20_PG) = ni(k,20)
    scalar(i,k,j,P_NI21_PG) = ni(k,21) 
    scalar(i,k,j,P_NI22_PG) = ni(k,22) 
    scalar(i,k,j,P_NI23_PG) = ni(k,23)
    scalar(i,k,j,P_NI24_PG) = ni(k,24)
    scalar(i,k,j,P_NI25_PG) = ni(k,25)
    scalar(i,k,j,P_NI26_PG) = ni(k,26)
    scalar(i,k,j,P_NI27_PG) = ni(k,27)
    scalar(i,k,j,P_NI28_PG) = ni(k,28)
    scalar(i,k,j,P_NI29_PG) = ni(k,29)
    scalar(i,k,j,P_NI30_PG) = ni(k,30) 
    scalar(i,k,j,P_NI31_PG) = ni(k,31)
    scalar(i,k,j,P_NI32_PG) = ni(k,32)  
    scalar(i,k,j,P_NI33_PG) = ni(k,33) 
    scalar(i,k,j,P_NI34_PG) = ni(k,34) 
    scalar(i,k,j,P_NI35_PG) = ni(k,35) 
    scalar(i,k,j,P_NI36_PG) = ni(k,36)
	
!! Rimed snowflakes number
    scalar(i,k,j,P_NX1_PG) = nsr(k,1)
    scalar(i,k,j,P_NX2_PG) = nsr(k,2)
    scalar(i,k,j,P_NX3_PG) = nsr(k,3) 
    scalar(i,k,j,P_NX4_PG) = nsr(k,4) 
    scalar(i,k,j,P_NX5_PG) = nsr(k,5)
    scalar(i,k,j,P_NX6_PG) = nsr(k,6)
    scalar(i,k,j,P_NX7_PG) = nsr(k,7)
    scalar(i,k,j,P_NX8_PG) = nsr(k,8)
    scalar(i,k,j,P_NX9_PG) = nsr(k,9)
    scalar(i,k,j,P_NX10_PG) = nsr(k,10)
    scalar(i,k,j,P_NX11_PG) = nsr(k,11) 
    scalar(i,k,j,P_NX12_PG) = nsr(k,12) 
    scalar(i,k,j,P_NX13_PG) = nsr(k,13)
    scalar(i,k,j,P_NX14_PG) = nsr(k,14) 
    scalar(i,k,j,P_NX15_PG) = nsr(k,15) 
    scalar(i,k,j,P_NX16_PG) = nsr(k,16)
    scalar(i,k,j,P_NX17_PG) = nsr(k,17)  
    scalar(i,k,j,P_NX18_PG) = nsr(k,18) 
    scalar(i,k,j,P_NX19_PG) = nsr(k,19) 
    scalar(i,k,j,P_NX20_PG) = nsr(k,20)
    scalar(i,k,j,P_NX21_PG) = nsr(k,21) 
    scalar(i,k,j,P_NX22_PG) = nsr(k,22) 
    scalar(i,k,j,P_NX23_PG) = nsr(k,23)
    scalar(i,k,j,P_NX24_PG) = nsr(k,24)
    scalar(i,k,j,P_NX25_PG) = nsr(k,25)
    scalar(i,k,j,P_NX26_PG) = nsr(k,26)
    scalar(i,k,j,P_NX27_PG) = nsr(k,27)
    scalar(i,k,j,P_NX28_PG) = nsr(k,28)
    scalar(i,k,j,P_NX29_PG) = nsr(k,29)
    scalar(i,k,j,P_NX30_PG) = nsr(k,30) 
    scalar(i,k,j,P_NX31_PG) = nsr(k,31)
    scalar(i,k,j,P_NX32_PG) = nsr(k,32)  
    scalar(i,k,j,P_NX33_PG) = nsr(k,33) 
    scalar(i,k,j,P_NX34_PG) = nsr(k,34) 
    scalar(i,k,j,P_NX35_PG) = nsr(k,35) 
    scalar(i,k,j,P_NX36_PG) = nsr(k,36)

END SUBROUTINE write_out_bin_pg	
!----+------------------------------------------------------------------+

      END MODULE module_mp_detailed
